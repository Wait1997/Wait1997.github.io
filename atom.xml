<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wait1997</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-06T14:33:59.486Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaoxiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6—Iterator的理解</title>
    <link href="http://yoursite.com/2020/02/06/ES6%E2%80%94Iterator%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/02/06/ES6%E2%80%94Iterator%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-02-06T11:11:47.611Z</published>
    <updated>2020-02-06T14:33:59.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6—Iterator的理解"><a href="#ES6—Iterator的理解" class="headerlink" title="ES6—Iterator的理解"></a>ES6—<code>Iterator</code>的理解</h3><blockquote><p><code>Iterator</code>可以说是ES6内相当重大的一个特性</p></blockquote><h4 id="1-从一个变量说起"><a href="#1-从一个变量说起" class="headerlink" title="1. 从一个变量说起"></a>1. 从一个变量说起</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'红'</span>, <span class="string">'绿'</span>, <span class="string">'蓝'</span>];</span><br></pre></td></tr></table></figure><p>如果要获取它的每一项数据，可以使用普通的<code>for</code>循环或者<code>forEach</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="当变量是字符串的时候"><a href="#当变量是字符串的时候" class="headerlink" title="当变量是字符串的时候"></a>当变量是字符串的时候</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'1234567890'</span>;</span><br></pre></td></tr></table></figure><p>可以使用<code>for...in</code>,也可以使用<code>for</code>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">in</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者转换成数组</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(str);</span><br></pre></td></tr></table></figure><p><code>for in</code> 不是用来获取数据的，他会遍历对象上所有可枚举的属性，包括自身的和原型链上的</p><h5 id="看下面给定的一个map对象，然后输出它的每一项数据"><a href="#看下面给定的一个map对象，然后输出它的每一项数据" class="headerlink" title="看下面给定的一个map对象，然后输出它的每一项数据"></a>看下面给定的一个<code>map</code>对象，然后输出它的每一项数据</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'zhu'</span>, <span class="string">'18'</span>);</span><br><span class="line">map.set(<span class="string">'zhang'</span>, <span class="string">'20'</span>);</span><br><span class="line">map.set(<span class="string">'wang'</span>, <span class="string">'23'</span>);</span><br></pre></td></tr></table></figure><p>用<code>map</code>方法中的<code>forEach</code>循环遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val, key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h5><p>在上一步几个简单的问题中，我们的操作都是获得他们的每一项数据。</p><p>当然方法有很多种，实现方式也有很多，<code>for 循环</code>，<code>forEach</code>，<code>for in</code> 等</p><p>但是有没有发现一个问题，或者我们站在一个更高的维度去看待，其实这些方法都不能通用，也就是说上面的这几种集合数据不能使用统一的遍历方法来进行数据获取</p><h4 id="2-ES6-for-of循环"><a href="#2-ES6-for-of循环" class="headerlink" title="2. ES6 for...of循环"></a>2. ES6 <code>for...of</code>循环</h4><blockquote><p>这个可以对不同数据结构进行统一遍历的方式就是 <code>es6</code>的 <code>for of</code> 循环</p><p><code>for of</code> 循环 和 古老的<code>for 循环</code>很像呀。不就是个新增语法么</p></blockquote><h5 id="并不是所有的对象都能使用-for-of，只有实现了Iterator接口的对象才能够使用-for-of-来进行遍历取值"><a href="#并不是所有的对象都能使用-for-of，只有实现了Iterator接口的对象才能够使用-for-of-来进行遍历取值" class="headerlink" title="并不是所有的对象都能使用 for of，只有实现了Iterator接口的对象才能够使用 for of 来进行遍历取值"></a>并不是所有的对象都能使用 <code>for of</code>，只有实现了<code>Iterator</code>接口的对象才能够使用 <code>for of</code> 来进行遍历取值</h5><h4 id="3-Iterator-迭代器"><a href="#3-Iterator-迭代器" class="headerlink" title="3. Iterator 迭代器"></a>3. <code>Iterator</code> 迭代器</h4><blockquote><p><code>Iterator</code> 是一种接口，目的是为不同的数据结构提供统一的数据访问机制。也可以理解为 <code>Iterator</code> 接口主要为 <code>for of</code> 服务的，供<code>for...of</code>进行消费</p></blockquote><h5 id="既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？"><a href="#既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？" class="headerlink" title="既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？"></a>既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？</h5><blockquote><p>因为 <code>javascript</code> 语言里没有接口的概念，这里我们可以理解成它是一种特殊的对象 - 迭代器对象，返回此对象的方法叫做迭代器方法</p></blockquote><p>首先他作为一个对象，此对象具有一个<code>next</code>方法，每次调用 <code>next</code> 方法都会返回一个结果值。</p><p>这个结果值是一个 <code>object</code>，包含两个属性，<code>value</code> 和 <code>done</code>。</p><p><code>value</code>表示具体的返回值，<code>done</code> 是布尔类型的，表示集合是否遍历完成或者是否后续还有可用数据，没有可用数据则返回 <code>true</code>，否则返回 <code>false</code>。</p><p>另外内部会维护一个指针，用来指向当前集合的位置，每调用一次 <code>next</code> 方法，指针都会向后移动一个位置(可以想象成数组的索引)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIterator</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> done = (i &gt;= list.length);</span><br><span class="line">      <span class="keyword">let</span> value = !done ? list[i++] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = getIterator([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;value: "a", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;value: "b", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;value: "c", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure><p>上面代码便是根据迭代器的基本概念衍生出来的一个模拟实现</p><ul><li><code>getIterator</code>方法返回一个对象 - 可迭代对象</li><li>对象具有一个<code>next</code> 方法，<code>next</code> 方法内部通过闭包来保存指针 <code>i</code> 的值，每次调用 <code>next</code> 方法 <code>i</code> 的值都会<code>+1</code></li><li>然后根据 <code>i</code> 的值从数组内取出数据作为 <code>value</code>，然后通过索引判断得到 <code>done</code>的值</li><li>当 <code>i=3</code>的时候，超过数组的最大索引，无可用数据返回，此时done 为<code>true</code>，遍历完成</li></ul><h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p>到这里我们已经大概了解了 <code>Iterator</code>, 以及如何创建一个迭代器对象。但是它和 <code>for of</code> 有什么关系呢？</p><h4 id="4-for-of-运行机制"><a href="#4-for-of-运行机制" class="headerlink" title="4. for of 运行机制"></a>4. for of 运行机制</h4><blockquote><p>当 <code>for of</code>执行的时候，循环过程中引擎就会自动调用这个<code>对象上的迭代器方法</code>， 依次执行迭代器对象的 <code>next</code> 方法,将 <code>next</code> 返回值赋值给 <code>for of</code> 内的变量，从而得到具体的值</p></blockquote><h5 id="实现可迭代对象"><a href="#实现可迭代对象" class="headerlink" title="实现可迭代对象"></a>实现可迭代对象</h5><blockquote><p>对象上怎么会有迭代器方法呢？</p></blockquote><p><code>ES6</code>里规定，只要在对象的属性上部署了<code>Iterator</code>接口，具体形式为给对象添加<code>Symbol.iterator</code>属性，此属性指向一个迭代器方法，这个迭代器会返回一个特殊的对象 - 迭代器对象。</p><p>而部署这个属性并且实现了迭代器方法后的对象叫做<code>可迭代对象</code></p><p>此时，这个对象就是可迭代的，也就是可以被 <code>for of</code> 遍历</p><blockquote><p>Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值。</p></blockquote><p>例如：普通对象是不能被 <code>for of</code> 遍历的，直接使用会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错 obj is not iterable</span></span><br></pre></td></tr></table></figure><p>如何让一个对象变成可迭代对象，按照协议也就是规定来实现即可</p><h5 id="iterableObj-对象上部署-Symbol-iterator属性，然后为其创建一个迭代器方法，迭代器的规则上面我们已经说过啦"><a href="#iterableObj-对象上部署-Symbol-iterator属性，然后为其创建一个迭代器方法，迭代器的规则上面我们已经说过啦" class="headerlink" title="iterableObj 对象上部署 Symbol.iterator属性，然后为其创建一个迭代器方法，迭代器的规则上面我们已经说过啦"></a><code>iterableObj</code> 对象上部署 <code>Symbol.iterator</code>属性，然后为其创建一个迭代器方法，迭代器的规则上面我们已经说过啦</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObj = &#123;</span><br><span class="line">  items: [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> done = (i &gt;= self.items.length);</span><br><span class="line">        <span class="keyword">let</span> value = !done ? self.items[i++] : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          done: done,</span><br><span class="line">          value: value</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历它</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterableObj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">//100,200,300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个对象就是可迭代对象了，可以被 <code>for of</code> 消费了</p><h4 id="5-Iterator-原生应用场景"><a href="#5-Iterator-原生应用场景" class="headerlink" title="5. Iterator 原生应用场景"></a>5. <code>Iterator</code> 原生应用场景</h4><p>再回到最开始使用 <code>for of</code> 来进行遍历<strong>字符串、数组、map</strong>，我们并没有为他们部署<code>Iterator</code>接口，仍然可以使用 <code>for of</code> 遍历。</p><p>这是因为在 <code>ES6</code>中有些对象已经默认部署了此接口，不需要做任何处理，就可以使用 <code>for of</code> 来进行遍历取值。</p><ol><li><p>数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iteratorObj = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj); <span class="comment">// Object [Array Iterator] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next()); <span class="comment">// &#123; value: 100, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next()); <span class="comment">// &#123; value: 200, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next()); <span class="comment">// &#123; value: 300, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><p>因为字符串本身的值是有序的，并且具有类数组的特性，支持通过索引访问，所以也默认部署了<code>iterator</code>接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strIteratorObj = str[<span class="built_in">Symbol</span>.iterator]();<span class="comment">//得到迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(strIteratorObj.next()); <span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(strIteratorObj.next()); <span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(strIteratorObj.next()); <span class="comment">// &#123; value: 'c', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(strIteratorObj.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>arguments</code>类数组</p><p>函数内的<code>arguments</code> 是一个类数组，他也支持 <code>for of</code>，因为他内部也部署了<code>Iterator</code> 接口</p><p>我们都知道对象是默认没有部署这个接口的，所以<code>arguments</code>这个属性没有在原型上，而在在对象自身的属性上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> obj = <span class="built_in">arguments</span>[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// 得到可迭代对象</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.hasOwnProperty(<span class="built_in">Symbol</span>.iterator)); <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// [0, 1, 3]</span></span><br><span class="line">   <span class="built_in">console</span>.log(obj.next()); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>总结来说，已默认部署 Iterator 接口的对象主要包括数组、字符串、Set、Map 、类似数组的对象（比如arguments对象、DOM NodeList 对象）</p></li></ol><h4 id="6-Iterator-另外一个作用"><a href="#6-Iterator-另外一个作用" class="headerlink" title="6. Iterator 另外一个作用"></a>6. <code>Iterator 另外一个作用</code></h4><blockquote><p><code>Iterator</code>除了可以为不同的数据结构提供一种统一的数据访问方式，还有没有发现其他的作用？</p><p>那就是数据可定制性，因为我们可以随意的控制迭代器的 <code>value</code> 值</p></blockquote><p>例如：数组本身就是一个可迭代的，我们可以覆盖它的默认迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 100 200 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己实现</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> done = (i &gt;= self.length);</span><br><span class="line">      <span class="keyword">let</span> value = !done ? self[i++] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象为什么没有默认部署"><a href="#对象为什么没有默认部署" class="headerlink" title="对象为什么没有默认部署"></a>对象为什么没有默认部署</h5><blockquote><p>对象可能有各种属性，不像数组的值是有序的。</p><p>所以遍历的时候根本不知道如何确定他们的先后顺序，所以需要我们根据情况手动实现</p></blockquote><h4 id="7-扩展"><a href="#7-扩展" class="headerlink" title="7. 扩展"></a>7. 扩展</h4><h5 id="for-of-中断"><a href="#for-of-中断" class="headerlink" title="for of 中断"></a><code>for of</code> 中断</h5><p>普通的 <code>for</code> 循环是可以随时中断的，那 <code>for of</code> 是否可以呢？</p><p>答案是肯定的，<code>for of</code>机制兼顾了<code>for</code>和<code>forEach</code>。</p><p>迭代器除了必须<code>next</code> 方法外，还有两个可选的方法 <code>return</code>和<code>throw</code>方法</p><p>如果 <code>for of</code> 循环提前退出，则会自动调用 <code>return</code> 方法，需要注意的是 <code>return</code> 方法必须有返回值，且返回值必须是 一个<code>object</code>。</p><h4 id="8-解构赋值"><a href="#8-解构赋值" class="headerlink" title="8. 解构赋值"></a>8. 解构赋值</h4><blockquote><p>对可迭代对象进行解构赋值的时候，会默认调用<code>Symbol.iterator</code>方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'12345'</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b] = str;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'1'</span>, <span class="string">'11'</span>);</span><br><span class="line">map.set(<span class="string">'2'</span>, <span class="string">'12'</span>);</span><br><span class="line">map.set(<span class="string">'3'</span>, <span class="string">'13'</span>);</span><br><span class="line">map.set(<span class="string">'4'</span>, <span class="string">'14'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [d, e] = map;</span><br><span class="line"><span class="built_in">console</span>.log([...map]);</span><br><span class="line"><span class="built_in">console</span>.log(d, e); <span class="comment">// ["1", "11"] ["2", "12"]</span></span><br></pre></td></tr></table></figure><p><strong>同样如果对一个普通对象进行解构，则会报错。</strong></p><p><strong>因为普通对象不是可迭代对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [d,e]=&#123;<span class="attr">name</span>:<span class="string">'zhang'</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h5 id="从一个自定义的可迭代对象进行解构赋值"><a href="#从一个自定义的可迭代对象进行解构赋值" class="headerlink" title="从一个自定义的可迭代对象进行解构赋值"></a>从一个自定义的可迭代对象进行解构赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObj = &#123;</span><br><span class="line">  items: [<span class="string">'红'</span>, <span class="string">'绿'</span>, <span class="string">'蓝'</span>],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> done = (i &gt;= self.items.length);</span><br><span class="line">        <span class="keyword">let</span> value = !done ? self.items[i++] : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          done: done,</span><br><span class="line">          value: value</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [d, e] = iterableObj;</span><br><span class="line"><span class="built_in">console</span>.log(d, e); <span class="comment">//红 绿</span></span><br></pre></td></tr></table></figure><p><strong>解构赋值的变量的值就是迭代器对象的 next 方法的返回值，且是按顺序返回</strong></p><h4 id="9-扩展运算符"><a href="#9-扩展运算符" class="headerlink" title="9. 扩展运算符"></a>9. 扩展运算符</h4><blockquote><p>扩展运算符的执行(…)也会默认调用它的<code>Symbol.iterator</code>方法，可以将当前迭代对象转换为数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'1234'</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...str]); <span class="comment">//[1,2,3,4]  转换为数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//map 对象</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">]);</span><br><span class="line">[...map] <span class="comment">//[[1,2],[3,4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set 对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">[...<span class="keyword">set</span>] //[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>普通对象是不可以用扩展运算符的</strong></p><h4 id="10-yield-关键字"><a href="#10-yield-关键字" class="headerlink" title="10. yield* 关键字"></a>10. <code>yield*</code> 关键字</h4><blockquote><p>yield*后面跟的是一个可遍历的结构，执行时也会调用迭代器函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="11-判断对象是否可迭代"><a href="#11-判断对象是否可迭代" class="headerlink" title="11. 判断对象是否可迭代"></a>11. 判断对象是否可迭代</h4><blockquote><p>既然可迭代对象的规则必须在对象上部署<code>Symbol.iterator</code>属性，那么我们基本上就可以通过此属来判断对象是否为可迭代对象，然后就可以知道是否能使用 <code>for of</code> 取值了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'abcdefg'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>())); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>())); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p><code>ES6</code>的出现带来了很多新的数据结构，比如 <code>Map</code> ,<code>Set</code> ，所以为了数据获取的方便，增加了一种统一获取数据的方式 <code>for of</code> 。 而 <code>for of</code> 执行的时候引擎会自动调用对象的迭代器来取值。</p><p>不是所有的对象都支持这种方式，必须是实现了<code>Iterator</code>接口的才可以，这样的对象我们称他们为可迭代对象。</p><p>迭代器实现方式根据可迭代协议，迭代器协议实现即可。</p><p>除了统一数据访问方式，还可以自定义得到的数据内容，随便怎样，只要是你需要的。</p><p>迭代器是一个方法， 用来返回迭代器对象。</p><p>可迭代对象是部署了 <code>Iterator</code> 接口的对象，同时拥有正确的迭代器方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6—Iterator的理解&quot;&gt;&lt;a href=&quot;#ES6—Iterator的理解&quot; class=&quot;headerlink&quot; title=&quot;ES6—Iterator的理解&quot;&gt;&lt;/a&gt;ES6—&lt;code&gt;Iterator&lt;/code&gt;的理解&lt;/h3&gt;&lt;blockqu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—Set和Map数据结构下</title>
    <link href="http://yoursite.com/2020/02/06/ES6%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/"/>
    <id>http://yoursite.com/2020/02/06/ES6%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/</id>
    <published>2020-02-06T08:52:51.512Z</published>
    <updated>2020-02-06T11:06:15.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6的Set和Map数据结构下"><a href="#ES6的Set和Map数据结构下" class="headerlink" title="ES6的Set和Map数据结构下"></a>ES6的Set和Map数据结构下</h3><h4 id="2-字典："><a href="#2-字典：" class="headerlink" title="2. 字典："></a>2. 字典：</h4><p>在数据结构还有一种结构叫做<strong>字典</strong>，它就是实现基于ES6中的Map类的结构</p><p>那么集合又和字典有什么区别呢：</p><ul><li>共同点：集合、字典可以存储不重复的值</li><li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li></ul><p>Map其实的主要用途也是用于存储数据的，相比于Object只提供“字符串—值”的对应，Map提供了“键—值”的对应。也就是说如果你需要“键值对”的数据结构，Map比Object更合适</p><p>下面来看一下基本使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  p: <span class="string">'Hello World'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(o)); <span class="comment">// content</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.has(o)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.delete(o)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.has(o)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>以上是Map的基本使用。</p><h5 id="Map语法"><a href="#Map语法" class="headerlink" title="Map语法"></a>Map语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([iterable])</span><br></pre></td></tr></table></figure><p><code>Iterable</code>参数可以是一个<code>数组</code>或者其他 <code>iterable</code>对象，其元素为键值对<strong><code>(两个元素的数组，例如: [[ 1, &#39;one&#39; ],[ 2, &#39;two&#39; ]])</code></strong>。 每个键值对都会添加到新的 Map。<code>null</code> 会被当做 <code>undefined。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[ <span class="number">1</span>, <span class="string">'one'</span> ],[ <span class="number">2</span>, <span class="string">'two'</span> ]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// Map &#123; 1 =&gt; 'one', 2 =&gt; 'two' &#125;</span></span><br></pre></td></tr></table></figure><p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 个  <code>for...of</code> 循环，在每次迭代后会返回一个形式为<code>[key，value]</code>的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[ <span class="number">1</span>, <span class="string">'one'</span> ],[ <span class="number">2</span>, <span class="string">'two'</span> ]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'key:'</span> + key + <span class="string">','</span> + <span class="string">'value:'</span> + value); <span class="comment">// key:1,value:one key:2,value:two</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Map的属性和方法"><a href="#Map的属性和方法" class="headerlink" title="Map的属性和方法"></a>Map的属性和方法</h5><p>属性：</p><ul><li>size：返回字典所包含的元素个数</li></ul><p>操作方法：</p><ul><li>set(key, val): 向字典中添加新元素</li><li>get(key):通过键值查找特定的数值并返回</li><li>has(key):如果键存在字典中返回true,否则false</li><li>delete(key): 通过键值从字典中移除对应的数据</li><li>clear():将这个字典中的所有元素删除</li></ul><p>遍历方法：</p><ul><li>keys():将字典中包含的所有键名以数组形式返回</li><li>values():将字典中包含的所有数值以数组形式返回</li><li>forEach()：遍历字典的所有成员</li></ul><h5 id="创建一个字典"><a href="#创建一个字典" class="headerlink" title="创建一个字典"></a>创建一个字典</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>创建好了字典这个骨架，那就开始添加一些方法了</p><h5 id="has方法"><a href="#has方法" class="headerlink" title="has方法"></a>has方法</h5><p>首先是has了，因为在set和get里都会用到，实现思路和之前写的集合也很类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="comment">// has(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>实现了has方法后，我们可以来判断字典中是否包含该属性了，继续来实现其他方法</p><h5 id="set和get方法"><a href="#set和get方法" class="headerlink" title="set和get方法"></a>set和get方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="comment">// has(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// set(key, val)方法</span></span><br><span class="line">  <span class="comment">// set相同key时，后面声明的会覆盖前面</span></span><br><span class="line">  <span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">    items[key] = val;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// get(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有key，如果有的话直接返回对应的值</span></span><br><span class="line">    <span class="comment">// 如果读取一个未知的键，则返回undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>set和get方法写好了，再接着搞delete和clear方法</p><h5 id="delete和clear方法"><a href="#delete和clear方法" class="headerlink" title="delete和clear方法"></a>delete和clear方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(key)) &#123;    <span class="comment">// 如果有key值</span></span><br><span class="line">      <span class="keyword">delete</span> items[key];  <span class="comment">// 直接删掉items上对应的属性</span></span><br><span class="line">      <span class="keyword">this</span>.size--;        <span class="comment">// 让size总数减1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clear()方法</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h5 id="遍历方法-keys-values-forEach"><a href="#遍历方法-keys-values-forEach" class="headerlink" title="遍历方法(keys(),values(),forEach())"></a>遍历方法(keys(),values(),forEach())</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys()方法</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// values()方法</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(items);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">Object</span>.values(items)[i];</span><br><span class="line">      fn.call(context, value, key, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h5 id="Map的完整代码"><a href="#Map的完整代码" class="headerlink" title="Map的完整代码"></a>Map的完整代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 记录数量</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// has(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// set(key, val)方法</span></span><br><span class="line">  <span class="comment">// set相同key时，后面声明的会覆盖前面</span></span><br><span class="line">  <span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">      items[key] = val;</span><br><span class="line">      <span class="keyword">this</span>.size++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// get(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有key，如果有的话直接返回对应的值</span></span><br><span class="line">    <span class="comment">// 如果读取一个未知的键，则返回undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// delete(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(key)) &#123;    <span class="comment">// 如果有key值</span></span><br><span class="line">      <span class="keyword">delete</span> items[key];  <span class="comment">// 直接删掉items上对应的属性</span></span><br><span class="line">      <span class="keyword">this</span>.size--;        <span class="comment">// 让size总数减1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clear()方法</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// keys()方法</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// values()方法</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(items);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">Object</span>.values(items)[i];</span><br><span class="line">      fn.call(context, value, key, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Map</span>;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Map</span> = <span class="built_in">require</span>(<span class="string">'./map'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'Jay'</span>, <span class="string">'Jay的值'</span>);</span><br><span class="line">map.set(<span class="string">'true'</span>, <span class="string">'真的'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'Jay'</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// [ 'Jay', 'true' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">// [ 'Jay的值', '真的' ]</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`value=<span class="subst">$&#123;value&#125;</span>,key=<span class="subst">$&#123;key&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// value=Jay的值,key=Jay value=真的,key=true</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// [ 'Jay' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">// [ 'Jay的值' ]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6的Set和Map数据结构下&quot;&gt;&lt;a href=&quot;#ES6的Set和Map数据结构下&quot; class=&quot;headerlink&quot; title=&quot;ES6的Set和Map数据结构下&quot;&gt;&lt;/a&gt;ES6的Set和Map数据结构下&lt;/h3&gt;&lt;h4 id=&quot;2-字典：&quot;&gt;&lt;a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—Set和Map数据结构上</title>
    <link href="http://yoursite.com/2020/02/06/ES6%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/"/>
    <id>http://yoursite.com/2020/02/06/ES6%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/</id>
    <published>2020-02-06T06:59:41.575Z</published>
    <updated>2020-02-06T08:52:11.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6的Set和Map数据结构上"><a href="#ES6的Set和Map数据结构上" class="headerlink" title="ES6的Set和Map数据结构上"></a>ES6的Set和Map数据结构上</h3><blockquote><p>Set和Map主要的应用场景在于<strong>数组去重</strong>和<strong>数据存储</strong></p><p>Set是一种叫做<strong>集合</strong>的数据结构，Map是一种叫做<strong>字典</strong>的数据结构</p></blockquote><h4 id="1-集合"><a href="#1-集合" class="headerlink" title="1. 集合"></a>1. 集合</h4><ul><li>集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组</li><li>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值</li><li>Set 本身是一个构造函数，用来生成 Set 数据结构</li><li>这里说的Set其实就是我们所要讲到的集合，先来看下基础用法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);   <span class="comment">// 2 3 5 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>];</span><br><span class="line">[...new <span class="built_in">Set</span>(array)]     <span class="comment">// [1, 2, 4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>首先来看一下ES6中Set类(数据结构)为基础实现的集合</p><h5 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h5><ul><li><p>Set的属性：</p><ul><li>size：返回集合所包含元素的数量</li></ul></li><li><p>Set的方法：</p><ul><li><p>操作方法</p><ul><li>add(value)：向集合添加一个新的项</li><li>delete(value)：从集合中移除一个值</li><li>has(value)：如果值在集合中存在，返回true,否则false</li><li>clear(): 移除集合里所有的项</li></ul></li><li><p>遍历方法</p><ul><li>keys()：返回一个包含集合中所有键的数组</li><li>values()：返回一个包含集合中所有值的数组</li><li>entries：返回一个包含集合中所有键值对的数组</li><li>forEach()：用于对集合成员执行某种操作，没有返回值</li></ul></li></ul></li></ul><h5 id="创建一个集合"><a href="#创建一个集合" class="headerlink" title="创建一个集合"></a>创建一个集合</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params">arr = []</span>) </span>&#123;    <span class="comment">// 可以传入数组</span></span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;  <span class="comment">// 记录集合中成员的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Set</span>;</span><br></pre></td></tr></table></figure><p>这里用<code>{}</code>对象来表示集合，也是因为对象不允许一个键指向两个不同的属性，保证了集合里的元素都是唯一的</p><p>接下来，就需要按照ES6中Set类的实现，添加一些集合的<strong>操作方法</strong>了</p><h5 id="has方法"><a href="#has方法" class="headerlink" title="has方法"></a>has方法</h5><p>首先要实现的是has方法，因为在add和delete等其他方法中都会被调用，下面来看一下它的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// has(val)方法</span></span><br><span class="line">    <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对象都有hasOwnProperty方法，判断是否拥有特定属性</span></span><br><span class="line">        <span class="keyword">return</span> items.hasOwnProperty(val);  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><p>接下来要实现add方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add(val)方法</span></span><br><span class="line"><span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">     items[val] = val;</span><br><span class="line">     <span class="keyword">this</span>.size++;    <span class="comment">// 累加集合成员数量</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于给定的val，可以检测是否存在于集合中</p><ul><li>如果不存在，就添加到集合中，返回true</li><li>如果存在，就直接返回false，不做任何操作</li></ul><h5 id="delete和clear方法"><a href="#delete和clear方法" class="headerlink" title="delete和clear方法"></a>delete和clear方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete(val)方法</span></span><br><span class="line"><span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> items[val];  <span class="comment">// 将items对象上的属性删掉</span></span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// clear方法</span></span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;     <span class="comment">// 直接将集合赋一个空对象即可</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在delete方法中，判断val是否存在于集合中，如果存在就直接从集合中删掉，返回true</p><p>以上完成的都是<strong>操作方法</strong>，下面我们再来实现一下<strong>遍历方法</strong></p><h5 id="keys和values方法"><a href="#keys和values方法" class="headerlink" title="keys和values方法"></a>keys和values方法</h5><p>因为通过ES6对Object的扩展可以轻松实现对应的方法，下面看一下具体实现，上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">Set</span> = <span class="built_in">require</span>(<span class="string">'./set'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(3);</span><br><span class="line"><span class="keyword">set</span>.add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>.keys()); //[ '1', '2', '3' ]</span><br><span class="line">console.log(<span class="keyword">set</span>.values()); //[ 1, 2, 3 ]</span><br><span class="line">console.log(<span class="keyword">set</span>.has(1)); //true</span><br><span class="line">console.log(<span class="keyword">set</span>.delete(1)); //true</span><br><span class="line">console.log(<span class="keyword">set</span>.size); //true</span><br></pre></td></tr></table></figure><p>这里我们看到和ES6中的Set有点区别，因为Object的这几个方法都是按照数值大小，从小到大遍历的数组，具体实现还是有些不同的</p><h5 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h5><p>ES6中Set结构的实例上带的forEach方法，其实和数组的forEach方法很相似，只不过Set结构的键名就是键值，所以第一个参数与第二个参数的值永远都是一样的</p><p>下面就按照实现数组的forEach方法，我们来完成Set的forEach方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      fn.call(context, item, item, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>使用forEach方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Set</span> = <span class="built_in">require</span>(<span class="string">'./set'</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(4);</span><br><span class="line"><span class="keyword">set</span>.add('3');</span><br><span class="line"><span class="keyword">set</span>.forEach((value, key) =&gt; console.log(key + ' : ' + value));  // 1:1, 3:3, 4:4</span><br><span class="line">let arr = <span class="keyword">set</span>.values();     // [ 1, 3, 4 ]</span><br></pre></td></tr></table></figure><p>基本上实现了Set结构的方法，不过，发现一个问题，那就是每次添加一个元素都要add这样写起来确实好麻烦，Set是可以接收一个数组作为参数的，那么把这个也实现一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params">arr = []</span>) </span>&#123; <span class="comment">// 可以传入一个数组</span></span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.size = <span class="number">0</span>; <span class="comment">//记录集合中成员的数量</span></span><br><span class="line">  <span class="comment">// has(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对象都有hasOwnProperty方法，判断是否拥有特定属性</span></span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// add(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">      items[val] = val;</span><br><span class="line">      <span class="keyword">this</span>.size++;    <span class="comment">// 累加集合成员数量</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// delete(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> items[val];  <span class="comment">// 将items对象上的属性删掉</span></span><br><span class="line">      <span class="keyword">this</span>.size--;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clear方法</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;     <span class="comment">// 直接将集合赋一个空对象即可</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// keys()方法</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);  <span class="comment">// 返回遍历集合的所有键名的数组</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// values()方法</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(items);  <span class="comment">// 返回遍历集合的所有键值的数组</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      fn.call(context, item, item, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">val, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.add(val);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Set</span>;</span><br></pre></td></tr></table></figure><p>再看看现在能不能支持传入数组了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Set</span> = <span class="built_in">require</span>(<span class="string">'./set'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).values();</span><br><span class="line"></span><br><span class="line">m = <span class="keyword">new</span> <span class="built_in">Set</span>(arr.map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">new</span> <span class="built_in">Set</span>(arr.filter(<span class="function"><span class="params">x</span> =&gt;</span> x&gt;<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.values());    <span class="comment">// [ 2, 4, 6 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(f.values());    <span class="comment">// [ 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>]).values();</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// [ 1, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure><h5 id="除此之外，Set还可以实现并集-union-交集-intersect-差集-difference"><a href="#除此之外，Set还可以实现并集-union-交集-intersect-差集-difference" class="headerlink" title="除此之外，Set还可以实现并集(union),交集(intersect),差集(difference)"></a>除此之外，Set还可以实现并集(union),交集(intersect),差集(difference)</h5><h5 id="union并集和intersect交集"><a href="#union并集和intersect交集" class="headerlink" title="union并集和intersect交集"></a>union并集和intersect交集</h5><ul><li>并集的数学概念，集合A和集合B的并集，表示为A∪B</li><li>交集的数学概念，集合A和集合B的交集，表示为A∩B</li></ul><p><img src="..%5Cimage%5CSet%5C%E4%BA%A4%E5%B9%B6.png" alt="交并"></p><p>先来实现union方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line">  <span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      union.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    values = other.values();    <span class="comment">// 将values重新赋值为新的集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      union.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> union;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 交集</span></span><br><span class="line">  <span class="keyword">this</span>.intersect = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (other.has(values[i])) &#123;     <span class="comment">// 查看是否也存在于other中</span></span><br><span class="line">        intersect.add(values[i]);   <span class="comment">// 存在的话就像intersect中添加元素</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersect;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>再看下difference差集的实现</p><ul><li><p>差集的数学概念，集合A和集合B的差集，表示为A-B</p><p><img src="..%5Cimage%5CSet%5C%E5%B7%AE%E9%9B%86.png" alt="差集"></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差集</span></span><br><span class="line">  <span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!other.has(values[i])) &#123;    <span class="comment">// 将不存在于other集合中的添加到新的集合中</span></span><br><span class="line">        difference.add(values[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h5 id="Set的完整实现"><a href="#Set的完整实现" class="headerlink" title="Set的完整实现"></a>Set的完整实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params">arr = []</span>) </span>&#123; <span class="comment">// 可以传入一个数组</span></span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.size = <span class="number">0</span>; <span class="comment">//记录集合中成员的数量</span></span><br><span class="line">  <span class="comment">// has(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对象都有hasOwnProperty方法，判断是否拥有特定属性</span></span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// add(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">      items[val] = val;</span><br><span class="line">      <span class="keyword">this</span>.size++;    <span class="comment">// 累加集合成员数量</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// delete(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> items[val];  <span class="comment">// 将items对象上的属性删掉</span></span><br><span class="line">      <span class="keyword">this</span>.size--;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clear方法</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;     <span class="comment">// 直接将集合赋一个空对象即可</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// keys()方法</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);  <span class="comment">// 返回遍历集合的所有键名的数组</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// values()方法</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(items);  <span class="comment">// 返回遍历集合的所有键值的数组</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      fn.call(context, item, item, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 并集</span></span><br><span class="line">  <span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      union.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    values = other.values();    <span class="comment">// 将values重新赋值为新的集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      union.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> union;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 交集</span></span><br><span class="line">  <span class="keyword">this</span>.intersect = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (other.has(values[i])) &#123;     <span class="comment">// 查看是否也存在于other中</span></span><br><span class="line">        intersect.add(values[i]);   <span class="comment">// 存在的话就像intersect中添加元素</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersect;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 差集</span></span><br><span class="line">  <span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!other.has(values[i])) &#123;    <span class="comment">// 将不存在于other集合中的添加到新的集合中</span></span><br><span class="line">        difference.add(values[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 子集</span></span><br><span class="line">  <span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt; other.size) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!other.has(values[i])) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">val, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.add(val);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Set</span>;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Set</span> = <span class="built_in">require</span>(<span class="string">'./set'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.values()); //[ 1, 2, 3 ]</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.keys());// [ '1', '2', '3' ]</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 3</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.delete(2);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.values()); // [1, 3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 0</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let a = [1, 2, 3];</span><br><span class="line">let b = new Set([4, 3, 2]);</span><br><span class="line">let union = new Set(a).union(b).values();</span><br><span class="line">console.log(union); // [ 1, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let c = new Set([4, 3, 2]);</span><br><span class="line">let intersect = new Set([1, 2, 3]).intersect(c).values();</span><br><span class="line">console.log(intersect); // [2, 3]</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let d = new Set([4, 3, 2]);</span><br><span class="line">let difference = new Set([1, 2, 3]).difference(d).values();</span><br><span class="line">console.log(difference); // [1]</span><br><span class="line"></span><br><span class="line">// 子集</span><br><span class="line">let e = new Set([1, 2, 3, 4]);</span><br><span class="line">let subset = new Set([1, 2, 3]).subset(e);</span><br><span class="line">console.log(subset); // true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6的Set和Map数据结构上&quot;&gt;&lt;a href=&quot;#ES6的Set和Map数据结构上&quot; class=&quot;headerlink&quot; title=&quot;ES6的Set和Map数据结构上&quot;&gt;&lt;/a&gt;ES6的Set和Map数据结构上&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;S
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue学习—防抖节流的使用</title>
    <link href="http://yoursite.com/2020/02/06/Vue%E5%AD%A6%E4%B9%A0%E2%80%94%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/Vue%E5%AD%A6%E4%B9%A0%E2%80%94%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-06T06:30:12.567Z</published>
    <updated>2020-02-06T06:30:12.567Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—深浅拷贝</title>
    <link href="http://yoursite.com/2020/02/06/JavaScript%E2%80%94%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/02/06/JavaScript%E2%80%94%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-02-06T06:28:24.796Z</published>
    <updated>2020-02-06T14:42:50.022Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6S—遍历对象属性的几种方式</title>
    <link href="http://yoursite.com/2020/02/06/ES6S%E2%80%94%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/06/ES6S%E2%80%94%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-02-06T04:38:25.871Z</published>
    <updated>2020-02-06T11:07:37.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript遍历对象的几种方式"><a href="#JavaScript遍历对象的几种方式" class="headerlink" title="JavaScript遍历对象的几种方式"></a>JavaScript遍历对象的几种方式</h3><h4 id="1-自身可枚举属性"><a href="#1-自身可枚举属性" class="headerlink" title="1. 自身可枚举属性"></a>1. 自身可枚举属性</h4><blockquote><p><code>Object.keys()</code>方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和<code>for...in</code>循环遍历该对象时返回的顺序一致。如果对象的键-值都不可枚举，那么将返回由键组成的数组。</p></blockquote><p>这是合理的，因为大多数时候只需要关注对象自身的属性。</p><h5 id="来看看一个对象拥有自身和继承属性的例子，Object-keys-只返回自己的属性键"><a href="#来看看一个对象拥有自身和继承属性的例子，Object-keys-只返回自己的属性键" class="headerlink" title="来看看一个对象拥有自身和继承属性的例子，Object.keys()只返回自己的属性键"></a>来看看一个对象拥有自身和继承属性的例子，<code>Object.keys()</code>只返回自己的属性键</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleColors = &#123;</span><br><span class="line">   colorA: <span class="string">'white'</span>,</span><br><span class="line">   colorB: <span class="string">'black'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> natureColors = &#123;</span><br><span class="line">   colorC: <span class="string">'green'</span>,</span><br><span class="line">   colorD: <span class="string">'yellow'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(natureColors, simpleColors);</span><br><span class="line"><span class="built_in">console</span>.dir(natureColors);<span class="comment">//simpleColors对象在natureColors原型上</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(natureColors)); <span class="comment">//["colorC", "colorD"]</span></span><br><span class="line"><span class="built_in">console</span>.log(natureColors[<span class="string">'colorA'</span>]); <span class="comment">//white</span></span><br><span class="line"><span class="built_in">console</span>.log(natureColors[<span class="string">'colorB'</span>]); <span class="comment">//black</span></span><br></pre></td></tr></table></figure><p><code>Object.setPrototype()</code>方法设置一个指定的对象的原型到另一个对象或null</p><p><code>Object.keys(natureColors)</code>返回<code>natureColors</code>对象自身可枚举属性键:<code>[&#39;colorC&#39;, &#39;colorD&#39;]</code>。<code>natureColors</code>包含从<code>simpleColors</code>原型对象继承的属性，但是<code>Object.keys()</code>函数会跳过它们。<code>Object.keys()</code>函数会跳过它们。<code>Object.value和Object.entries()</code>也都是返回一个给定对象自身可枚举属性的键值对数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleColors = &#123;</span><br><span class="line">      colorA: <span class="string">'white'</span>,</span><br><span class="line">      colorB: <span class="string">'black'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> natureColors = &#123;</span><br><span class="line">      colorC: <span class="string">'green'</span>,</span><br><span class="line">      colorD: <span class="string">'yellow'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(natureColors, simpleColors);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(natureColors)); <span class="comment">//["colorC", "colorD"]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(natureColors)); <span class="comment">//["green", "yellow"]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(natureColors)); <span class="comment">//[Array(2), Array(2)]</span></span><br></pre></td></tr></table></figure><p>现在注意与<code>for...in</code>语句的区别，<code>for...in</code>不仅可以循环枚举自身属性还可以枚举原型链中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleColors = &#123;</span><br><span class="line">      colorA: <span class="string">'white'</span>,</span><br><span class="line">      colorB: <span class="string">'black'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> natureColors = &#123;</span><br><span class="line">      colorC: <span class="string">'green'</span>,</span><br><span class="line">      colorD: <span class="string">'yellow'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(natureColors, simpleColors);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> enumerableKeys = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> natureColors) &#123;</span><br><span class="line">      enumerableKeys.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(enumerableKeys); <span class="comment">// ["colorC", "colorD", "colorA", "colorB"]</span></span><br></pre></td></tr></table></figure><p><code>enumerableKeys</code>数组包含<code>natureColors</code>自身属性键：<code>colorC</code>、<code>colorD</code>。</p><p>另外<code>for...in</code>也遍历了从<code>simpleColors</code>原型对象继承的属性</p><h4 id="2-Object-values-返回属性值"><a href="#2-Object-values-返回属性值" class="headerlink" title="2. Object.values()返回属性值"></a>2. <code>Object.values()</code>返回属性值</h4><blockquote><p><code>Object.values()</code>方法返回一个给定对象自身的所有可枚举属性值的数组，值顺序与使用<code>foe..in</code>循环的循序相同（区别在于<code>for...in</code>循环枚举原型链中的属性）。</p></blockquote><p>使用<code>Object.keys()</code>收集keys，然后通过key去对象取对应的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meals = &#123;</span><br><span class="line">      mealA: <span class="string">'Breakfast'</span>,</span><br><span class="line">      mealB: <span class="string">'Lunch'</span>,</span><br><span class="line">      mealC: <span class="string">'Dinner'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(meals)) &#123;</span><br><span class="line">      <span class="keyword">let</span> mealName = meals[key];</span><br><span class="line">      <span class="built_in">console</span>.log(mealName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>meal</code>是一个普通对象。使用<code>Object.keys(meals)</code>和枚举的<code>for...of</code>循环获取对象键值。但是<code>let mealName = meals[key];</code>没有多大的必要，可以进一步优化代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meals = &#123;</span><br><span class="line">      mealA: <span class="string">'Breakfast'</span>,</span><br><span class="line">      mealB: <span class="string">'Lunch'</span>,</span><br><span class="line">      mealC: <span class="string">'Dinner'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> mealName <span class="keyword">of</span> <span class="built_in">Object</span>.values(meals)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(mealName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为<code>Object.values(meals)</code>返回数组中的对象属性值，所以可以直接在 <code>for..of</code>中简化。<code>mealName</code>直接在循环中赋值。</p><h4 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3.Object.entries()"></a>3.<code>Object.entries()</code></h4><blockquote><p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 <code>for...in</code>循环遍历该对象时返回的顺序一致（区别在于 <code>for...in</code>循环也枚举原型链中的属性）</p></blockquote><p><code>Object.entries()</code> 返回键值对数组，如 <code>[[key1,value1],[key2,value2],...,[keyN,valueN]]</code></p><h5 id="可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示："><a href="#可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示：" class="headerlink" title="可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示："></a>可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meals = &#123;</span><br><span class="line">      mealA: <span class="string">'Breakfast'</span>,</span><br><span class="line">      mealB: <span class="string">'Lunch'</span>,</span><br><span class="line">      mealC: <span class="string">'Dinner'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(meals)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key + <span class="string">':'</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 'mealA:Breakfast' 'mealB:Lunch' 'mealC:Dinner'</span></span><br></pre></td></tr></table></figure><p>如上所示，因为 <code>Object.entries()</code>返回一个与数组解构赋值兼容的集合，因此不需要为赋值或声明添加额外的行</p><h5 id="当普通对象要转换成-Map-时Object-entries-就很有用，因为-Object-entries-返回的格式与-Map构造函数接受的格式完全相同：-key-value-。"><a href="#当普通对象要转换成-Map-时Object-entries-就很有用，因为-Object-entries-返回的格式与-Map构造函数接受的格式完全相同：-key-value-。" class="headerlink" title="当普通对象要转换成 Map 时Object.entries()就很有用，因为 Object.entries()返回的格式与 Map构造函数接受的格式完全相同：(key,value)。"></a>当普通对象要转换成 <code>Map</code> 时<code>Object.entries()</code>就很有用，因为 <code>Object.entries()</code>返回的格式与 <code>Map</code>构造函数接受的格式完全相同：<code>(key,value)</code>。</h5><p>使用常规的 Map构造函数可以将一个二维键值对数组转换成一个 Map对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greetings = &#123;</span><br><span class="line">      morning: <span class="string">'Good morning'</span>,</span><br><span class="line">      midday: <span class="string">'Good day'</span>,</span><br><span class="line">      evening: <span class="string">'Good evening'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> greetingsMap = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(greetings));</span><br><span class="line">    <span class="built_in">console</span>.log(greetingsMap); <span class="comment">// &#123;"morning" =&gt; "Good morning", "midday" =&gt; "Good day", "evening" =&gt; "Good evening"&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log([...greetingsMap]); <span class="comment">// =&gt; Object.entries(greetings)</span></span><br><span class="line">    <span class="built_in">console</span>.log(greetingsMap.get(<span class="string">'morning'</span>)); <span class="comment">// Good morning</span></span><br><span class="line">    <span class="built_in">console</span>.log(greetingsMap.get(<span class="string">'midday'</span>)); <span class="comment">// Good day</span></span><br><span class="line">    <span class="built_in">console</span>.log(greetingsMap.get(<span class="string">'evening'</span>)); <span class="comment">// Good evening</span></span><br></pre></td></tr></table></figure><p><code>Map</code> 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值</p><p>有趣的是， Map提供了与 <code>Object.values()</code>和 <code>Object.entries()</code> 等效的方法（只是它们返回<code>Iterators</code>），以便为 <code>Map</code>实例提取属性值或键值对：</p><ul><li><code>Map.prototype.values()</code> 等价于 <code>Object.values()</code></li><li><code>Map.prototype.entries()</code> 等价于 <code>Object.entries()</code></li></ul><p><code>map</code>是普通对象的改进版本，可以获取 <code>map</code> 的大小(对于普通对象，必须手动获取)，并使用任意对象类型作为键(普通对象使用字符串基元类型作为键)。</p><h5 id="让我们看看返回-values（）和-entries（）的-map的方法"><a href="#让我们看看返回-values（）和-entries（）的-map的方法" class="headerlink" title="让我们看看返回 .values（）和 .entries（）的 map的方法:"></a>让我们看看返回 .values（）和 .entries（）的 map的方法:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[...greetingsMap.values()];</span><br><span class="line"><span class="comment">// =&gt; ['Good morning', 'Good day', 'Good evening']</span></span><br><span class="line">[...greetingsMap.entries()];</span><br><span class="line"><span class="comment">// =&gt; [ ['morning', 'Good morning'], ['midday', 'Good day'],</span></span><br><span class="line"><span class="comment">//      ['evening', 'Good evening'] ]</span></span><br></pre></td></tr></table></figure><p>注意： <strong><code>greetingsMap.values()</code>和 <code>greetingsMap.entries()</code>返回迭代器对象。若要将结果放入数组，扩展运算符 <code>…</code>是必要的</strong></p><h4 id="4-对象属性的顺序"><a href="#4-对象属性的顺序" class="headerlink" title="4. 对象属性的顺序"></a>4. 对象属性的顺序</h4><p><code>JS</code>对象是简单的键值映射，因此，对象中属性的顺序是微不足道的， 在大多数情况下，不应该依赖它。</p><p>在<code>ES5</code>和早期标准中，根本没有指定属性的顺序。</p><p>然而，从<code>ES6</code>开始，属性的顺序是基于一个特殊的规则的，除非特指按照时间排序。通过两个新方法 <code>Object.getOwnPropertyNames</code>和 <code>Reflect.ownKeys</code>来编写示例讲解这一属性排序规则。</p><ol><li>数字：当属性的类型时数字类型时，会按照数字的从大到小的顺序进行排序；</li><li>字符串：当属性的类型是字符串时，会按照时间的先后顺序进行排序；</li><li><code>Symbol</code>：当属性的类型是<code>Symbol</code>时，会按照时间的先后顺序进行排序。</li></ol><p>如果需要有序集合，建议将数据存储到数组或 <code>Set</code>中</p><p><strong>总结</strong></p><p><code>Object.values()</code> 和 <code>Object.entries()</code> 是为<code>JS</code>开发人员提供新的标准化辅助函数的另一个改进步骤。</p><p><code>Object.entries()</code>最适用于数组解构赋值，其方式是将键和值轻松分配给不同的变量。此函数还可以轻松地将纯<code>JS对象</code>属性映射到 Map对象中</p><p>注意：<strong><code>Object.values()</code>和<code>Object.entries()</code>返回数据的顺序是不确定的，所以不要依赖该方式。</strong></p><h4 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h4><h5 id="JS对象的可枚举属性和不可枚举属性"><a href="#JS对象的可枚举属性和不可枚举属性" class="headerlink" title="JS对象的可枚举属性和不可枚举属性"></a><code>JS</code>对象的可枚举属性和不可枚举属性</h5><blockquote><p>对象的每一个属性都有一个描述对象，用来描述和控制该属性的行为，用<code>Object.getOwnPropertyDescriptor</code>方法来获取该描述对象（用<code>Object.defineProperty</code>方法来设置）。</p></blockquote><p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">start</span>: <span class="string">'123'</span> &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'start'</span>))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出内容：</span></span><br><span class="line">     configurable: <span class="literal">true</span></span><br><span class="line">     enumerable: <span class="literal">true</span></span><br><span class="line">     value: <span class="string">"123"</span></span><br><span class="line">     writable: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h5><ol><li><code>configurable</code>：表示能否通过<code>delete</code>删除此属性，能否修改属性的特性，或能否修改把属性修改为访问器属性，如果直接使用字面量定义对象，默认值为true</li><li><code>enumerable</code>: 表示该属性是否可枚举，即是否通过for-in循环或<code>Object.keys()</code>返回属性，如果直接使用字面量定义对象，默认值为true</li><li><code>writable</code>: 能否修改属性的值，如果直接使用字面量定义对象，默认值为true</li><li><code>value</code>: 该属性对应的值，默认为undefined</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            value: <span class="string">'祖宗'</span>,</span><br><span class="line">            enumerable: <span class="literal">false</span>,  <span class="comment">//不可枚举</span></span><br><span class="line">        &#125;,</span><br><span class="line">        age: &#123;</span><br><span class="line">            value: <span class="number">88</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,   <span class="comment">//可枚举</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"key:"</span> + key + <span class="string">','</span> + <span class="string">'value:'</span> + obj[key]) <span class="comment">//key: value, value: 88</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="目前-有四个操作会忽略enumerable为false的属性。"><a href="#目前-有四个操作会忽略enumerable为false的属性。" class="headerlink" title="目前,有四个操作会忽略enumerable为false的属性。"></a>目前,有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</h5><ol><li><code>for…in循环</code>：只遍历对象自身的和继承的可枚举的属性</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性</li><li><code>Object.assign()</code>： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JavaScript遍历对象的几种方式&quot;&gt;&lt;a href=&quot;#JavaScript遍历对象的几种方式&quot; class=&quot;headerlink&quot; title=&quot;JavaScript遍历对象的几种方式&quot;&gt;&lt;/a&gt;JavaScript遍历对象的几种方式&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—async与await</title>
    <link href="http://yoursite.com/2020/02/05/ES6%E2%80%94async%E4%B8%8Eawait/"/>
    <id>http://yoursite.com/2020/02/05/ES6%E2%80%94async%E4%B8%8Eawait/</id>
    <published>2020-02-05T15:11:02.040Z</published>
    <updated>2020-02-05T16:21:55.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="async-await的使用"><a href="#async-await的使用" class="headerlink" title="async/await的使用"></a><code>async</code>/<code>await</code>的使用</h3><h4 id="1-async-await的具体使用规则"><a href="#1-async-await的具体使用规则" class="headerlink" title="1. async/await的具体使用规则"></a>1. <code>async</code>/<code>await</code>的具体使用规则</h4><p>在我们处理异步的时候，比起回调函数，<code>Promise</code>的then方法会显得较为简洁和清晰，但是在处理多个<strong>彼此之间相互依赖的请求的时候</strong>，就会显的有些累赘。这时候，用<code>async</code>和<code>await</code>更加优雅</p><h5 id="async-await使用规则一：凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象"><a href="#async-await使用规则一：凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象" class="headerlink" title="async/await使用规则一：凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象"></a><strong><code>async/await</code>使用规则一：凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = test()</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//test()返回Promise对象</span></span><br></pre></td></tr></table></figure><h5 id="async-await使用规则二：await必须在async函数里使用，不能单独使用"><a href="#async-await使用规则二：await必须在async函数里使用，不能单独使用" class="headerlink" title="async/await使用规则二：await必须在async函数里使用，不能单独使用"></a><strong><code>async/await</code>使用规则二：await必须在async函数里使用，不能单独使用</strong></h5><p>错误的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>正确的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(result); <span class="comment">// success</span></span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br></pre></td></tr></table></figure><p><strong><code>async/await</code>使用规则三：await后面需要跟Promise对象，不然就没有意义，而且await后面的Promise对象不必写then，因为await的作用之一就是获取后面Promise对象成功状态传递出来的参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">'success'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">await</span> fn() <span class="comment">//因为fn会返回一个Promise对象</span></span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">//这里会打出Promise成功后传递过来的'success'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><h4 id="2-async-await的错误处理方式一"><a href="#2-async-await的错误处理方式一" class="headerlink" title="2. async/await的错误处理方式一"></a>2. <code>async</code>/<code>await</code>的错误处理方式一</h4><blockquote><p>关于错误处理，如规则三所说，await可以直接获取到后面Promise成功状态传递的参数，但是却捕捉不到失败状态。在这里，我们通过给包裹await的async函数添加then/catch方法来解决，因为根据规则一，async函数本身就会返回一个Promise对象</p></blockquote><p>包含错误处理的完整的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promiseDemo = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">        <span class="keyword">if</span> (random &gt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">            resolve(<span class="string">'success'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'failed'</span>)</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> promiseDemo</span><br><span class="line">    <span class="keyword">return</span> result  <span class="comment">//这里的result是promiseDemo成功状态的值，如果失败了，代码就直接跳到下面的catch了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response) </span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：<strong>一是async函数需要主动return一下，如果Promise的状态是成功的，那么return的这个值就会被下面的then方法捕捉到；二是，如果async函数有任何错误，都被catch捕捉到！</strong></p><h4 id="3-async-await的错误处理方式二"><a href="#3-async-await的错误处理方式二" class="headerlink" title="3.async/await的错误处理方式二"></a>3.<code>async</code>/<code>await</code>的错误处理方式二</h4><blockquote><p>使用<code>try{}catch(e){}</code>来捕获promise错误的时候</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseDemo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">          <span class="keyword">if</span>(random &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            resolve(<span class="string">'success'</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'failed'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> promiseDemo();</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e + <span class="string">'错误'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test();</span><br></pre></td></tr></table></figure><h4 id="4-同步和异步"><a href="#4-同步和异步" class="headerlink" title="4. 同步和异步"></a>4. 同步和异步</h4><blockquote><p>在async函数中使用await，那么await这里的代码就会变成同步的了，意思就是说只有等await后面的Promise执行完成得到结果才会继续下去，await就是等待，这样虽然避免了异步，但是它也会阻塞代码，所以使用的时候要考虑周全</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>成功`</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> p1 = <span class="keyword">await</span> fn(<span class="string">'小红'</span>);</span><br><span class="line">      <span class="keyword">let</span> p2 = <span class="keyword">await</span> fn(<span class="string">'小明'</span>);</span><br><span class="line">      <span class="keyword">let</span> p3 = <span class="keyword">await</span> fn(<span class="string">'小华'</span>);</span><br><span class="line">      <span class="keyword">return</span> [p1, p2, p3];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>成功`</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'xxxxxxxxxxxxxxxxxxx'</span>);</span><br><span class="line">      <span class="keyword">let</span> p1 = <span class="keyword">await</span> fn(<span class="string">'小红'</span>);</span><br><span class="line">      <span class="keyword">let</span> p2 = <span class="keyword">await</span> fn(<span class="string">'小明'</span>);</span><br><span class="line">      <span class="keyword">let</span> p3 = <span class="keyword">await</span> fn(<span class="string">'小华'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log([p1,p2,p3]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    test();</span><br></pre></td></tr></table></figure><p>这样写虽然是可以的，但是这里await会阻塞代码，每个await都必须等后面的fn()执行完成才会执行下一行代码，所以test函数执行需要3秒。如果不是遇到特定的场景，最好还是不要这样用。</p><h4 id="5-一个适合使用async-await的业务场景"><a href="#5-一个适合使用async-await的业务场景" class="headerlink" title="5. 一个适合使用async/await的业务场景"></a>5. 一个适合使用<code>async</code>/<code>await</code>的业务场景</h4><blockquote><p>在前端编程中，我们偶尔会遇到这样一个场景：我们需要发送多个请求，而<strong>后面请求的发送总是需要依赖上一个请求返回的数据</strong>。对于这个问题，我们既可以用的Promise的链式调用来解决，也可以用<code>async/await</code>来解决，然而后者会更简洁些</p></blockquote><p>使用promise链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(time)</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(<span class="number">500</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(result + <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(result + <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用<code>async/await</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(time)</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="keyword">await</span> request(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="keyword">await</span> request(p1 + <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="keyword">await</span> request(p2 + <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> p3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getResult().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相对于使用then不停地进行链式调用， 使用<code>async/await</code>会显的更加易读一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;async-await的使用&quot;&gt;&lt;a href=&quot;#async-await的使用&quot; class=&quot;headerlink&quot; title=&quot;async/await的使用&quot;&gt;&lt;/a&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;的使用&lt;/h3
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—promise使用</title>
    <link href="http://yoursite.com/2020/02/05/ES6%E2%80%94promise%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/05/ES6%E2%80%94promise%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-05T14:01:09.685Z</published>
    <updated>2020-02-05T15:09:39.077Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Promise的使用"><a href="#Promise的使用" class="headerlink" title="Promise的使用"></a>Promise的使用</h3><blockquote><p>一个 Promise 就是一个代表了异步操作最终完成或者失败的对象。这是MDN上关于Promise的解释。在前端开发中，Promise经常被拿来用于处理异步和回调的问题，来规避回调地狱和更好排布异步相关的代码</p></blockquote><h4 id="1-Promise的三种状态"><a href="#1-Promise的三种状态" class="headerlink" title="1. Promise的三种状态"></a>1. Promise的三种状态</h4><p>从字面的意思理解，Promise即是<strong>承诺</strong>，那承诺的结果就会有成功和失败两种。而且，我们许下承诺之后不会立即得到结果，在获得成功或是失败的结果之前，我们还需要一点时间来履行这个承诺。Promise的构造其实像极了我们生活中的承诺。</p><p><img src="..%5Cimage%5Cpromise%5Cpending.png" alt="pending"></p><p>以上是<code>Promise</code>的结构图。其中<code>Promise</code>存在三种状态，一种是pending状态、一种是成功时的<code>Fullfilled</code>状态、一种是失败时的<code>Rejected</code>状态。</p><h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> love = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> happy = <span class="built_in">Math</span>.random() &gt;= <span class="number">0.3</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(happy) &#123;</span><br><span class="line">          resolve(<span class="string">'marry'</span>); <span class="comment">//成功</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="string">'break'</span>); <span class="comment">//失败</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;<span class="comment">//成功的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(result); </span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;<span class="comment">// 失败的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>注意：<strong>Promise在经过pending状态达到成功或失败状态时就会凝固，即到达成功状态后再也不会失败，失败以后也不会回到成功状态。</strong>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> love = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">'break'</span>)</span><br><span class="line">      resolve(<span class="string">'marry'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e) <span class="comment">// break</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="2-Promise的then与catch的几种写法"><a href="#2-Promise的then与catch的几种写法" class="headerlink" title="2. Promise的then与catch的几种写法"></a>2. Promise的then与catch的几种写法</h4><ol><li><p>第一种，最常见的就是上面的写法, 使用then来捕捉resolve状态，使用catch来捕捉reject状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;<span class="comment">//成功的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(result); </span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;<span class="comment">// 失败的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>第二种，不写catch, 把用来捕捉reject状态的函数也写到then里，但是效果和上面一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;, result =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>第三种，分开写，也是可以的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;     <span class="comment">//只捕捉和处理成功状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">love.catch(<span class="function"><span class="params">result</span> =&gt;</span> &#123;    <span class="comment">//只捕捉和处理失败状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-快速构建一个成功或是失败状态的Promise"><a href="#3-快速构建一个成功或是失败状态的Promise" class="headerlink" title="3. 快速构建一个成功或是失败状态的Promise"></a>3. 快速构建一个成功或是失败状态的Promise</h4><h5 id="Promise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是Promise-resolve-用于构建成功状态的Promise-另一个是Promise-reject-，用于构建失败状态的Promise"><a href="#Promise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是Promise-resolve-用于构建成功状态的Promise-另一个是Promise-reject-，用于构建失败状态的Promise" class="headerlink" title="Promise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是Promise.resolve(), 用于构建成功状态的Promise;另一个是Promise.reject()，用于构建失败状态的Promise"></a>Promise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是<code>Promise.resolve()</code>, 用于构建成功状态的Promise;另一个是<code>Promise.reject()</code>，用于构建失败状态的Promise</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">    p1.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result); <span class="comment">// success</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">'failed'</span>);</span><br><span class="line">    p2.catch(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result); <span class="comment">// failed</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="4-使用Promise-all-来处理前端场景"><a href="#4-使用Promise-all-来处理前端场景" class="headerlink" title="4. 使用Promise.all()来处理前端场景"></a>4. 使用<code>Promise.all()</code>来处理前端场景</h4><p>在前端的开发实践中，我们有时会遇到需要发送多个请求并根据请求顺序返回数据的需求，比如，我们要发送a、b、c三个请求，这三个请求返回的数据分别为a1、a2、a3，而我们想要a1、a2、a3按照我们希望的顺序返回。那么，使用<code>Promise.all()</code>方法可以完美的解决这一问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟异步请求的函数</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="function">(<span class="params">name, time</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">          <span class="keyword">if</span> (random &gt;= <span class="number">0.2</span>) &#123;</span><br><span class="line">            resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>成功了`</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">`<span class="subst">$&#123;name&#125;</span>失败了`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, time)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建三个Promise实例</span></span><br><span class="line">    <span class="keyword">let</span> a = request(<span class="string">'小明'</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">let</span> b = request(<span class="string">'小红'</span>, <span class="number">500</span>)</span><br><span class="line">    <span class="keyword">let</span> c = request(<span class="string">'小华'</span>, <span class="number">1500</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Promise.all(), 注意它接收的是一个数组作为参数 </span></span><br><span class="line">    <span class="built_in">Promise</span>.all([c, a, b]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">//["小华成功了", "小明成功了", "小红成功了"]</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>把上面的代码复制下来放到浏览器的调试控制台里多执行几次（第二次执行需要刷新）会发生什么事情呢？你可能猜到了：<strong>如果三个请求都成功的话，那么这三个请求所返回的数据就是按照发送请求的顺序排列的，即[“小华成功了”, “小明成功了”, “小红成功了”]，而且还是以数组形式返回的；而当其中有请求失败了的话，就只会返回最先失败的结果。</strong></p><p>当然，除了这个场景以外，<code>Promise.all()</code>方法还能用于其它地方。比如说，一个页面上有两个请求，只有拿到了这两个请求的数据，页面才会展示，在这之前会显示一个loading加载图。使用<code>Promise.all()</code>也是可以非常简洁的解决这个问题</p><h4 id="5-Promise-race-的使用"><a href="#5-Promise-race-的使用" class="headerlink" title="5. Promise.race()的使用"></a>5. <code>Promise.race()</code>的使用</h4><h5 id="顾名思义，Promse-race就是赛跑的意思，意思就是说，Promise-race-p1-p2-p3-里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态"><a href="#顾名思义，Promse-race就是赛跑的意思，意思就是说，Promise-race-p1-p2-p3-里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态" class="headerlink" title="顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态"></a>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success1'</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'success2'</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// success2</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-Promise的链式调用"><a href="#5-Promise的链式调用" class="headerlink" title="5. Promise的链式调用"></a>5. <code>Promise</code>的链式调用</h4><h5 id="上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。"><a href="#上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。" class="headerlink" title="上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。"></a>上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">    <span class="keyword">let</span> response = p.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result); <span class="comment">//success</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(response); <span class="comment">//Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>因为then之后返回的还是一个Promise对象，那我们就可以继续then，只不过后面then拿到的参数是上一个then里return的内容，而这个return的内容既可以是普通的字符串、数字等（最后都会被封装成Promise）也可以是自己写的一个Promise对象。</p><h5 id="Promise链式调用的代码："><a href="#Promise链式调用的代码：" class="headerlink" title="Promise链式调用的代码："></a><code>Promise</code>链式调用的代码：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> love = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> happy = <span class="built_in">Math</span>.random() &gt;= <span class="number">0.3</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (happy) &#123;</span><br><span class="line">          resolve(<span class="string">'marry'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="string">'break'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> haveChild = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'孩子生了！'</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">//marry</span></span><br><span class="line">      <span class="keyword">return</span> haveChild <span class="comment">// 这里返回一个Promise对象,它的resolve会被下一个then捕捉</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">//孩子生了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'最后，他们白头偕老！'</span> <span class="comment">//这里返回的字符串会传给下一个then</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">// 最后，他们白头偕老</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error) <span class="comment">//break</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>注意：链式调用的最一定要加上一个catch来捕捉链条中可能出现的错误。</p><h4 id="6-Promise链式调用可以处理的一个业务场景"><a href="#6-Promise链式调用可以处理的一个业务场景" class="headerlink" title="6. Promise链式调用可以处理的一个业务场景"></a>6. Promise链式调用可以处理的一个业务场景</h4><h5 id="当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，Promise的链式操作就可以派上用场了"><a href="#当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，Promise的链式操作就可以派上用场了" class="headerlink" title="当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，Promise的链式操作就可以派上用场了"></a>当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，<code>Promise的链式操作</code>就可以派上用场了</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = axios.get(url)  <span class="comment">//result是Promise对象</span></span><br><span class="line">    result.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(url0).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(response.data.link)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Promise的使用&quot;&gt;&lt;a href=&quot;#Promise的使用&quot; class=&quot;headerlink&quot; title=&quot;Promise的使用&quot;&gt;&lt;/a&gt;Promise的使用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个 Promise 就是一个代表了异步操作最终完
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—数组方法及数组去重</title>
    <link href="http://yoursite.com/2020/02/05/JavaScript%E2%80%94%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%8A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>http://yoursite.com/2020/02/05/JavaScript%E2%80%94%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%8A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
    <published>2020-02-05T10:25:49.344Z</published>
    <updated>2020-02-05T11:15:41.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数组的遍历方法"><a href="#1-数组的遍历方法" class="headerlink" title="1. 数组的遍历方法"></a>1. 数组的遍历方法</h3><ol><li><p><code>Array.forEach()</code></p><blockquote><p>遍历数组，和普通的for循环使用类似</p></blockquote></li><li><p><code>Array.entries()</code></p><blockquote><p>返回一个Array Iterator对象，该对象包含数组中每一个索引的键值对</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> eArr = arr.entries();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [2, "c"]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.every()</code></p><blockquote><p>every()是对数组中每一项运行给定函数，如果该函数对<strong>每一项</strong>返回true,则返回true</p></blockquote></li><li><p><code>Array.some()</code></p><blockquote><p>some()是对数组中每一项运行给定函数，如果该函数对<strong>任一项</strong>返回true,则返回true</p></blockquote></li><li><p><code>Array.filter</code></p><blockquote><p>filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组</p></blockquote></li><li><p><code>Array.map()</code></p><blockquote><p>遍历数组每一项，并且返回一个新数组</p></blockquote></li><li><p><code>Array.find()</code></p><blockquote><p>find()方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">//4</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.findIndex()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.reduce((prev,cur,index,array){},init)</code></p><blockquote><p>该方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值</p><p> <strong>array</strong> 表示原数组；<br> <strong>prev</strong> 表示上一次调用回调时的返回值，或者初始值 init;<br> <strong>cur</strong> 表示当前正在处理的数组元素；<br> <strong>index</strong> 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；<br> <strong>init</strong> 表示初始值</p></blockquote></li></ol><h3 id="2-数组去重的几种方法"><a href="#2-数组去重的几种方法" class="headerlink" title="2. 数组去重的几种方法"></a>2. 数组去重的几种方法</h3><ol><li><p>定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> repeat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArr.length; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i] === newArr[j]) &#123;</span><br><span class="line">            repeat = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!repeat) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> formArr = arr.sort();</span><br><span class="line">      <span class="keyword">var</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; formArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(formArr[i] !== formArr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">          newArr.push(formArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique2([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用对象属性存在的特性，如果没有该属性则存入新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> newArr = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">          obj[arr[i]] = <span class="number">1</span></span><br><span class="line">          newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// console.log(obj);</span></span><br><span class="line">      <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique3([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组的<code>indexOf</code>下标属性来查询。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique4</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newArr.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique4([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique5 = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(arr[i])) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique5([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的 filter 和 includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique6</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      newArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newArr.includes(item) ? <span class="string">''</span> : newArr.push(item)</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique6([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的 forEach 和 includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique7</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(item)) &#123;</span><br><span class="line">          newArr.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique7([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的reduce和include方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique8 = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> newArr = arr.reduce(<span class="function">(<span class="params">all, item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!all.includes(item)) &#123;</span><br><span class="line">          all.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all;</span><br><span class="line">      &#125;, [])</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(unique8([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>ES6 set方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique9</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique9([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">unique10</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique10([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-数组的遍历方法&quot;&gt;&lt;a href=&quot;#1-数组的遍历方法&quot; class=&quot;headerlink&quot; title=&quot;1. 数组的遍历方法&quot;&gt;&lt;/a&gt;1. 数组的遍历方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Array.forEach()&lt;/code&gt;&lt;/p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—开发技巧</title>
    <link href="http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</id>
    <published>2020-02-05T05:44:40.330Z</published>
    <updated>2020-02-05T05:44:40.330Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—性能优化1</title>
    <link href="http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%961/"/>
    <id>http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%961/</id>
    <published>2020-02-05T05:01:51.113Z</published>
    <updated>2020-02-05T07:17:50.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React性能优化1"><a href="#React性能优化1" class="headerlink" title="React性能优化1"></a>React性能优化1</h3><blockquote><h4 id="react凭借virtual-DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。"><a href="#react凭借virtual-DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。" class="headerlink" title="react凭借virtual DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。"></a>react凭借virtual DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。</h4></blockquote><h4 id="1-使用React-Memo-来缓存组件"><a href="#1-使用React-Memo-来缓存组件" class="headerlink" title="1. 使用React.Memo()来缓存组件"></a>1. 使用<code>React.Memo()</code>来缓存组件</h4><blockquote><p>父组件的每次状态更新，都会导致子组件重新渲染，即使传入子组件的状态没有变化，当类组件的输入属性相同时可以使用<code>pureComponent</code>或<code>shouldComponentUdate</code>来避免组件的渲染，函数组件中我们可以使用<code>React.memo</code>来缓存组件，这样只有当传入组件的状态值发生变化时才会重新渲染。如果传入相同的值，则返回缓存的组件。示例如下:</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(props) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;&#123;props.value&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="React-memo（浅比较）"><a href="#React-memo（浅比较）" class="headerlink" title="React.memo（浅比较）"></a><code>React.memo（浅比较）</code></h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> AreEqual <span class="keyword">from</span> <span class="string">'./component/AreEqual'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      val: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      val: <span class="keyword">this</span>.state.val</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;AreEqual &#123;...this.state&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果把nextProps传入render方法的返回结果与将</span></span><br><span class="line"><span class="comment">   * preProps传入render方法的返回结果一致则返回true</span></span><br><span class="line"><span class="comment">   * 否则返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (prevProps.val === nextProps.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AreEqual</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"渲染了"</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; val &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;val&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React.memo()两个参数 第一个是纯函数，第二个是比较函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(AreEqual, areEqual);</span><br></pre></td></tr></table></figure><h4 id="2-React-PureComponent"><a href="#2-React-PureComponent" class="headerlink" title="2. React.PureComponent"></a>2. <code>React.PureComponent</code></h4><blockquote><p>作用：</p><ol><li><code>React.PureComponent</code>和<code>React.Component</code>类似，都是定义一个组件类。</li><li>不同的是<code>React.Component</code>没有实现<code>shouldComponentUpdate()</code>，而<code>React.PureComponent</code>通过props和state的浅比较实现了。</li><li><code>React.PureComponent</code>是作用在类中，<code>React.memo</code>是作用在函数中</li></ol></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Children name=&#123;'这是React.pureComponent的使用方法'&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-使用useMemo缓存大量的计算"><a href="#3-使用useMemo缓存大量的计算" class="headerlink" title="3. 使用useMemo缓存大量的计算"></a>3. 使用<code>useMemo</code>缓存大量的计算</h4><blockquote><p>有时渲染是不可避免的，但如果您的组件是一个功能组件，重新渲染会导致每次都调用大型计算函数，这是非常消耗性能的，我们可以使用新的<code>useMemo</code>钩子来“记忆”这个计算函数的计算结果。这样只有传入的参数发生变化后，该计算函数才会重新调用计算新的结果。<br>通过这种方式，您可以使用从先前渲染计算的结果来挽救昂贵的计算耗时。总体目标是减少JavaScript在呈现组件期间必须执行的工作量，以便主线程被阻塞的时间更短。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免这样做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> someProp = heavyCalculation(props.item);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AnotherComponent</span> <span class="attr">someProp</span>=<span class="string">&#123;someProp&#125;</span> /&gt;</span> </span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">  </span></span><br><span class="line"><span class="xml">// 只有 `props.item` 改变时someProp的值才会被重新计算</span></span><br><span class="line"><span class="xml">function Component(props) &#123;</span></span><br><span class="line"><span class="xml">  const someProp = useMemo(() =&gt; heavyCalculation(props.item), [props.item]);</span></span><br><span class="line">  return &lt;AnotherComponent someProp=&#123;someProp&#125; /&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-使用React-PureComponent-shouldComponentUpdate"><a href="#4-使用React-PureComponent-shouldComponentUpdate" class="headerlink" title="4.使用React.PureComponent, shouldComponentUpdate"></a>4.使用<code>React.PureComponent</code>, <code>shouldComponentUpdate</code></h4><blockquote><p>父组件状态的每次更新，都会导致子组件的重新渲染，即使是传入相同props。但是这里的重新渲染不是说会更新DOM,而是每次都会调用diif算法来判断是否需要更新DOM。这对于大型组件例如组件树来说是非常消耗性能的。<br>在这里我们就可以使用<code>React.PureComponent</code> ,<code>shouldComponentUpdate</code>生命周期来确保只有当组件props状态改变时才会重新渲染。如下例子:</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ParentComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SomeComponent someProp=&#123;props.somePropValue&#125; /&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;AnotherComponent someOtherProp=&#123;props.someOtherPropValue&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>div&gt;</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">SomeComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;props.someProp&#125;&lt;<span class="regexp">/div&gt;  </span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 只要props.somePropValue 发生变化，不论props.someOtherPropValue是否发生变化该组件都会发生变化</span></span><br><span class="line"><span class="regexp">export default function AnotherComponent(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&#123;props.someOtherProp&#125;&lt;/</span>div&gt;  </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>React.PureComponent</code>、<code>shouldComponentUpdate</code>性能优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.someOtherProp&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props !== nextProps</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.someOtherProp&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>PureComponent</code>会进行浅比较来判断组件是否应该重新渲染，对于传入的基本类型props，只要值相同，浅比较就会认为相同，对于传入的引用类型props，浅比较只会认为传入的props是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是不同的props。<br>需要注意的是在对于那些可以忽略渲染时间的组件或者是状态一直变化的组件则要谨慎使用<code>PureComponent</code>，因为进行浅比较也会花费时间，这种优化更适用于大型的展示组件上。大型组件也可以拆分成多个小组件，并使用memo来包裹小组件，也可以提升性能。</p></blockquote><h5 id="补充：PureComponent浅比较部分核心源码"><a href="#补充：PureComponent浅比较部分核心源码" class="headerlink" title="补充：PureComponent浅比较部分核心源码"></a>补充：<code>PureComponent</code>浅比较部分核心源码</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span> (<span class="params">objA: mixed, objB: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的 is 相当于 === 的功能，只是对 + 0 和 - 0，以及 NaN 和 NaN 的情况进行了特殊处理</span></span><br><span class="line">  <span class="comment">// 第一关：基础数据类型直接比较出结果</span></span><br><span class="line">  <span class="keyword">if</span> (is (objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二关：只要有一个不是对象数据类型就返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">'object'</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三关：在这里已经可以保证两个都是对象数据类型，比较两者的属性数量</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys (objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys (objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第四关：比较两者的属性是否相等，值是否相等</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.call (objB, keysA [i]) ||</span><br><span class="line">      !is (objA [keysA [i]], objB [keysA [i]])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意：比较终究是浅比较，当出现嵌套情况就会失灵"><a href="#注意：比较终究是浅比较，当出现嵌套情况就会失灵" class="headerlink" title="注意：比较终究是浅比较，当出现嵌套情况就会失灵"></a>注意：比较终究是浅比较，当出现嵌套情况就会失灵</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state: &#123;<span class="attr">a</span> : [<span class="string">"1"</span>]&#125; -&gt; state: &#123;<span class="attr">a</span>: [<span class="string">"1"</span>, <span class="string">"2"</span>]&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式最大的弊端是由于 <code>JS</code> 引用赋值的原因，这种方式仅仅适用于无状态组件或者状态数据非常简单的组件，对于大量的应用组件无能为力</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React性能优化1&quot;&gt;&lt;a href=&quot;#React性能优化1&quot; class=&quot;headerlink&quot; title=&quot;React性能优化1&quot;&gt;&lt;/a&gt;React性能优化1&lt;/h3&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;react凭借virtual-DOM和d
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React与Vue比较2</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%832/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%832/</id>
    <published>2020-02-04T08:57:36.458Z</published>
    <updated>2020-02-05T04:56:17.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React与Vue的对比中"><a href="#React与Vue的对比中" class="headerlink" title="React与Vue的对比中"></a>React与Vue的对比中</h2><h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1.核心思想"></a>1.核心思想</h4><blockquote><h5 id="vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。"><a href="#vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。" class="headerlink" title="vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。"></a>vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。</h5></blockquote><ol><li><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><h5 id="vue的整体思想仍然式拥抱html-结构-css-表现-js-行为-的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用-v-if、v-show、v-for等指令-，在组件数据上，vue2-0通过Object-defineProperty对数据做到了更细致的监听，精准实现组件级别的更新"><a href="#vue的整体思想仍然式拥抱html-结构-css-表现-js-行为-的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用-v-if、v-show、v-for等指令-，在组件数据上，vue2-0通过Object-defineProperty对数据做到了更细致的监听，精准实现组件级别的更新" class="headerlink" title="vue的整体思想仍然式拥抱html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等指令)，在组件数据上，vue2.0通过Object.defineProperty对数据做到了更细致的监听，精准实现组件级别的更新"></a>vue的整体思想仍然式拥抱html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等指令)，在组件数据上，vue2.0通过<code>Object.defineProperty</code>对数据做到了更细致的监听，精准实现组件级别的更新</h5></li><li><h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><h5 id="react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染"><a href="#react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染" class="headerlink" title="react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染"></a>react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过<code>shouldComponentUpdate</code>或者<code>PureComponent</code>避免不必要的重新渲染</h5></li></ol><h4 id="2-组件形式"><a href="#2-组件形式" class="headerlink" title="2. 组件形式"></a>2. 组件形式</h4><blockquote><p>vue组件定义使用xx.vue文件来表示，vue组件将html、css、js组合到一起，模板部分使用<code>双括号</code>渲染数据，形式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模板(html)</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据管理(js)</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;NewComponent&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;xx&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 样式(css)</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>react推荐使用jsx或者js文件来表示组件，react支持class组件和function组件两种形式，react使用<code>{}</code>包裹变量</p></blockquote><ol><li><h5 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'xx'</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.state.name&#125;    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li><li><p>函数组件</p><p>hooks的出现赋予了function组件管理state的能力</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;name&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-数据管理（props、data、state）"><a href="#3-数据管理（props、data、state）" class="headerlink" title="3.数据管理（props、data、state）"></a>3.数据管理（props、data、state）</h4><blockquote><p>组件数据来自父组件的数据props与自身的数据</p><p>vue与react中的props都是单向数据流的，父级props的更新会向下流动到子组件中，props用来接收父组件的数据</p></blockquote><h5 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h5><ol><li><h6 id="props"><a href="#props" class="headerlink" title="props"></a>props</h6><blockquote><p>vue中的props支持传递静态、动态props</p></blockquote><h5 id="静态："><a href="#静态：" class="headerlink" title="静态："></a>静态：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">new</span>-component title=<span class="string">"study vue"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">new-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="动态："><a href="#动态：" class="headerlink" title="动态："></a>动态：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">new</span>-component :title=<span class="string">"title"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">new-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><h6 id="data"><a href="#data" class="headerlink" title="data"></a>data</h6><blockquote><p>vue中使用data来管理组件的数据，vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)。一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p></blockquote><p>注意：当一个组件被定义，data必须声明为返回一个初始数据对象的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'NewComponent'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'xxx'</span>,</span><br><span class="line">      age: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要在组件内部修改数据时，可以直接通过vue实例修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'new Name'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="react-1"><a href="#react-1" class="headerlink" title="react"></a>react</h5><ol><li><h6 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h6><blockquote><p>react中的props也与vue一样可以传递静态或动态props，静态props一般传递字符串。</p><p>函数组件和class组件都可以使用props，函数组件使用props参数获取父组件传下来的props。</p><p>函数组件获取props：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;</span><br></pre></td></tr></table></figure><p>class组件使用<code>this.props</code>获取组件<code>props</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name &#125; &#x3D; this.props;</span><br><span class="line">    return &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>动态props：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Welcome name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h6 id="state"><a href="#state" class="headerlink" title="state"></a>state</h6><blockquote><p>react中使用state来管理组件内的数据，hooks的出现使得函数组件也具备管理state的能力</p></blockquote><h5 id="class组件state"><a href="#class组件state" class="headerlink" title="class组件state"></a>class组件state</h5><p>class组件在构造函数（constructor）中定义组件内数据（state），修改数据必须通过setState修改，不能直接修改state，这点非常重要。</p><p>class组件使用state：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'xx'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.changeName = <span class="keyword">this</span>.changeName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="string">'new name'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">this</span>.state.name &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于class组建的setState有以下两点说明：</p><ul><li>1.setState更新是异步的，但是<strong>在setTimeout和原生事件中是同步的</strong>。</li><li>2.setState更新的是组件的部分数据，react会自动将数据合并。</li></ul><p>当需要使用上一个state值时，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h5 id="函数组件useState"><a href="#函数组件useState" class="headerlink" title="函数组件useState"></a>函数组件useState</h5><p>react 16.8之前函数组件只是纯的渲染组件，hooks的出现赋予了函数组件管理state的能力。</p><p>useState返回一个state，以及更新state的函数。如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于setState有以下三点说明：</p><ul><li>1.与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。</li><li>2.只能在函数最顶层调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>3.只能在 React 的函数组件或自定义hook中调用 Hook。不要在其他 JavaScript 函数中调用。</li></ul></blockquote></li></ol><h4 id="4-组件数据交互"><a href="#4-组件数据交互" class="headerlink" title="4.组件数据交互"></a>4.组件数据交互</h4><blockquote><p>组件数据交互是指父子组件、兄弟组件、跨层组件之间传递数据。 兄弟组件之间可以通过事件总线或者通过父组件传递数据</p></blockquote><h5 id="4-1-父子组件数据交互-props-自定义事件-vs-props-回调"><a href="#4-1-父子组件数据交互-props-自定义事件-vs-props-回调" class="headerlink" title="4.1 父子组件数据交互(props+自定义事件 vs props+回调)"></a>4.1 父子组件数据交互(props+自定义事件 vs props+回调)</h5><p>对于父子组件数据交互，vue中使用prop+自定义事件实现，react通过props+回调</p><h5 id="vue-2"><a href="#vue-2" class="headerlink" title="vue"></a>vue</h5><p>vue中父组件通过props传递数据给子组件，子组件使用<code>$emit</code>触发自定义事件，父组件中监听子组件的自定义事件获取子组件传递来的数据。</p><p>子组件使用<code>$emit</code>传递自定义事件<code>myEvent</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;changeName&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;NewComponent&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;xxx&#39;,</span><br><span class="line">      age: 12</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeName() &#123;</span><br><span class="line">      this.name &#x3D; &#39;new Name&#39;;</span><br><span class="line">      this.$emit(&#39;myEvent&#39;, this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>父组件使用<code>@myEvent</code>监听自定义事件，回调函数参数是子组件传回的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;new-component @myEvent&#x3D;&quot;getName&quot;&gt;&lt;&#x2F;new-component&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import NewComponent from &#39;.&#x2F;NewComponent&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    NewComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getName(name) &#123;</span><br><span class="line">      console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="react-2"><a href="#react-2" class="headerlink" title="react"></a>react</h4><p>react中父组件使用props传递数据和回调函数给子组件，子组件通过props传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据。</p><p>子组件通过props接收父组件传下来的回调事件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; myEvent &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setName(<span class="string">'new name'</span>);</span><br><span class="line">    myEvent(<span class="string">'new name'</span>);<span class="comment">//回调</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件通过回调事件获取子组件传递的参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">myEvent</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2跨组件数据交互-provide-inject-vs-Context"><a href="#4-2跨组件数据交互-provide-inject-vs-Context" class="headerlink" title="4.2跨组件数据交互(provide/inject vs Context)"></a>4.2跨组件数据交互(provide/inject vs Context)</h5><blockquote><p>vue和react都支持跨组件传递数据，vue中主要通过<code>provide / inject</code>实现，react中主要通过<code>Context</code>实现。</p></blockquote><h5 id="vue-3"><a href="#vue-3" class="headerlink" title="vue"></a>vue</h5><p>vue中通过<code>provide / inject</code>在祖先组件向所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p><p>祖先组件中定义provide选项，provide选项应该是一个对象或返回一个对象的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;new-component @myEvent&#x3D;&quot;getName&quot;&gt;&lt;&#x2F;new-component&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import NewComponent from &#39;.&#x2F;NewComponent&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123; &#x2F;&#x2F; 定义provide选项</span><br><span class="line">    message: &#39;This is a big news&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    NewComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getName(name) &#123;</span><br><span class="line">      console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件通过inject选项获取祖先组件的provide选项值，inject选项应该是一个字符串数组或者对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Children&#39;,</span><br><span class="line">  inject: [&#39;message&#39;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote><h5 id="react-3"><a href="#react-3" class="headerlink" title="react"></a>react</h5><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><p>在父组件创建一个Context对象，通过<code>Context.provider</code>的value属性向消费组件传值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Context对象</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext(&#123; <span class="attr">theme</span>: <span class="string">'black'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Context.provider向消费组件传值</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">theme:</span> '<span class="attr">white</span>' &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Children</span> <span class="attr">myEvent</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费组件获取Context有2种方式：</p><p>（1）class组件通过contextType获取最近Context上的那个值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepChildren1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextType = MyContext;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.theme&#125;123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）函数式组件通过<code>Context.Consumer</code>订阅到Context的变更。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepChildren</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;</span></span><br><span class="line"><span class="xml">      (value) =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value.theme&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">MyContext.Consumer</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Context需要注意：</p><blockquote><p>当Provider的父组件进行重渲染时，consumers组件会重新渲染，并且没有办法避免，应该尽量避免使用Context。</p></blockquote><h4 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h4><blockquote><p>组件的生命周期一般包括：初始化、挂载、更新、卸载四大阶段，接下来分别看下vue和react的生命周期</p></blockquote><h5 id="vue-4"><a href="#vue-4" class="headerlink" title="vue"></a>vue</h5><p>vue生命周期图示:</p><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Cvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue生命周期"></p><p>vue生命周期包含:</p><ul><li>beforeCreate<br> 实例组件刚创建，元素DOM和数据都还没有初始化，暂时不能在这个周期里面进行任何操作。</li><li>created<br> 数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。调用后台接口获取数据可以在这个阶段完成。</li><li>beforeMount<br> DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示<code>双括号</code>，虚拟DOM结构已经生成。</li><li>mounted<br> 数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。这个周期适合执行初始化需要操作DOM的方法。</li><li>beforeUpdate<br> 页面数据改变了都会触发，在更新前触发，此时的数据还是未更新前的数据，没有数据改变则不执行。</li><li>updated<br> 页面数据改变都会触发，在更新完成之后触发，此时的数据是更新后的数据。</li></ul><blockquote><p>注意：在这里操作数据很容易引起卡死。</p></blockquote><ul><li>beforeDestroy<br> 组件销毁之前执行，在这个周期里仍然可以访问data和method，多组件间通信需要发布信息时可以在该阶段完成。</li><li>destroyed<br> 当离开组件对应页面时组件销毁时触发，主要用于取消一些副作用（取消事件监听、取消定时器、取消不必要的请求等）</li></ul><h5 id="react-4"><a href="#react-4" class="headerlink" title="react"></a>react</h5><h5 id="16-3以前的生命周期"><a href="#16-3以前的生命周期" class="headerlink" title="16.3以前的生命周期"></a>16.3以前的生命周期</h5><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Creact%E8%80%81%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react老版生命周期"></p><p>（1）初始化</p><ul><li>constructor<br> 是class组件的默认方法，常用来初始化state或者设置属性等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props); <span class="comment">// 声明constructor时必须调用super方法</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          count: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）挂载阶段</p><ul><li>componentWillMount()<br>组件挂载之前调用，并且只会调用一次。</li><li>render<br>render是一个React组件必须定义的生命周期函数，用来渲染DOM。 并必须 return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。</li></ul><blockquote><p>不要在render里面修改state,会引起死循环导致卡死。</p></blockquote><ul><li>componentDidMount()<br>组件挂在完成之后调用，在这个阶段可以获取真实dom元素，常用来发起异步请求获取数据。</li></ul><p>（3）更新阶段</p><p>当通过setState修改state或父组件重新render引起props更新，都会引起子组件的重新render。</p><ul><li>componentWillReceiveProps(nextProps)<br>props发生变化以及父组件重新渲染时都会触发该生命周期函数。在该阶段可以通过参数nextProps获取变化后的props参数， 通过this.props访问之前的props。该生命周期内可以进行setState。</li><li>shouldComponentUpdate(nextProps,nextState)<br>组件每次setState或者父组件重新render都会引起子组件render，可以使用该钩子比较nextProps，nextState及当前组件的this.props，this.state的状态用来判断是否需要重新渲染。默认返回true，需要重新render，返回false则不触发渲染。</li></ul><blockquote><p>一般我们通过该钩子来优化性能，避免子组件不必要的渲染。</p></blockquote><ul><li>componentWillUpdate(nextProps, nextState)<br>当组件收到新的 props 或 state 时，会在渲染之前调用。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</li></ul><blockquote><p>注意：不能在此方法中调用<code>this.setState</code></p></blockquote><ul><li>componentDidUpdate(prevProps, prevState) 此方法在组件更新后被调用。首次渲染不会执行此方法。当组件更新后，可以在此处对DOM进行操作。</li></ul><blockquote><p>注意：可以在<code>componentDidUpdate()</code>中直接调用<code>setState()</code>，但是它必需被包裹在一个条件语句里，否则会导致死循环。</p></blockquote><p>（4）卸载阶段</p><ul><li>componentWillUnmount()<br>会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在<code>componentDidMount()</code> 中创建的订阅等。</li></ul><blockquote><p>注意：componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。</p></blockquote><h5 id="16-4之后"><a href="#16-4之后" class="headerlink" title="16.4之后"></a>16.4之后</h5><p>react 16.0之后移除的生命周期函数：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul><p>但是为了向下兼容，react并未删除这三个生命周期，新增以 <code>UNSAFE_</code> 前缀为别名的三个函数 <code>UNSAFE_componentWillMount()</code>、<code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code>。</p><p>新增的生命周期函数：</p><ul><li>static getDerivedStateFromProps(nextProps, prevState)</li><li>getSnapshotBeforeUpdate(prevProps, prevState)</li></ul><p>生命周期如下：</p><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Creact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react生命周期"></p><blockquote><p>总结：<br>初始化阶段保持不变 </p><p>挂载阶段: getDerivedStateFromProps =&gt; render =&gt; componentDidMount </p><p>更新阶段: getDerivedStateFromProps =&gt; shoudeComponentUpdate =&gt; render =&gt; getSnapshotBeforeUpdate  =&gt; componentDidUpdate </p><p>卸载阶段保持不变</p></blockquote><h5 id="getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。"><a href="#getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。" class="headerlink" title="getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。"></a>getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。</h5><p>（1）static getDerivedStateFromProps(props, state)</p><p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p><blockquote><p>当state的值在任何时候都取决于props的时候适用该方法。</p></blockquote><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.type !== prevState.type) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            type: nextProps.type,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>（2）getSnapshotBeforeUpdate(prevProps, prevState)</p><p>getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。应返回 snapshot 的值（或 null）。</p><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// 我们是否在 list 中添加新的 items ？</span></span><br><span class="line">    <span class="comment">// 捕获滚动位置以便我们稍后调整滚动位置。</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span></span><br><span class="line">    <span class="comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span></span><br><span class="line">    <span class="comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React与Vue的对比中&quot;&gt;&lt;a href=&quot;#React与Vue的对比中&quot; class=&quot;headerlink&quot; title=&quot;React与Vue的对比中&quot;&gt;&lt;/a&gt;React与Vue的对比中&lt;/h2&gt;&lt;h4 id=&quot;1-核心思想&quot;&gt;&lt;a href=&quot;#1-核
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—setState</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94setState/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94setState/</id>
    <published>2020-02-04T07:11:17.734Z</published>
    <updated>2020-02-04T08:36:34.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React中的state"><a href="#React中的state" class="headerlink" title="React中的state"></a>React中的state</h3><h4 id="1-不能直接修改-state"><a href="#1-不能直接修改-state" class="headerlink" title="1. 不能直接修改 state"></a>1. 不能直接修改 <code>state</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-state中数据的修改"><a href="#2-state中数据的修改" class="headerlink" title="2.state中数据的修改"></a>2.<code>state</code>中数据的修改</h4><ul><li>通过<code>setState</code>修改<code>state</code>中的数据</li></ul><blockquote><h6 id="setState中的关键点"><a href="#setState中的关键点" class="headerlink" title="setState中的关键点"></a><code>setState</code>中的关键点</h6></blockquote><ol><li><p><code>setState</code>不会立刻改变<code>React</code>组件中<code>state</code>的值 </p></li><li><p><code>setState</code>通过引发一次组件的更新过程来引发重新绘制</p><p>重绘指的就是引起<code>React</code>的更新生命周期函数4个函数：</p><ul><li><code>shouldComponentUpdate</code>（被调用时<code>this.state</code>没有更新；如果返回了<code>false</code>，生命周期被中断，虽然不调用之后的函数了，但是<code>state</code>仍然会被更新）</li><li><code>componentWillUpdate</code>（被调用时<code>this.state</code>没有更新）</li><li><code>render</code>（被调用时<code>this.state</code>得到更新）</li><li><code>componentDidUpdate</code></li></ul></li><li><p>多次<code>setState</code>函数调用产生的效果会合并。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'Pororo'</span>&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">age</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'Pororo'</span>，age: <span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面两块代码的效果是一样的。<strong>如果每次调用都引发一次生命周期更新，那性能就会消耗很大了。</strong>所以，<code>React</code>会将多个<code>this.setState</code>产生的修改<strong>放进一个队列里，</strong>等差不多的时候就会引发一次生命周期更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Eg</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">      index: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// react生命周期</span></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第一次输出</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第二次输出</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第三次输出</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第四次输出</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">     <span class="comment">// 通过 addEventListener 监听的会同步执行setState()</span></span><br><span class="line">    <span class="keyword">this</span>.refs.button.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index) <span class="comment">// 同步时输出 1 异步时（通过react事件机制定义的事件处理函数）输出 0</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index) <span class="comment">// 同步时输出 2 异步时（通过react事件机制定义的事件处理函数）输出 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>value: &#123;this.state.value&#125; index: &#123;this.state.index&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        &lt;button ref=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><h5 id="前两次setState："><a href="#前两次setState：" class="headerlink" title="前两次setState："></a>前两次<code>setState</code>：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步</span></span><br><span class="line"> <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">// 第一次输出0</span></span><br><span class="line">         <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">// 第二次输出0</span></span><br></pre></td></tr></table></figure><p>由于<code>setState</code>不会立即改变React组件中<code>state</code>的值，所以两次<code>setState</code>中<code>this.state.value</code>都是同一个值0，故而，这两次输出都是0。因而value只被加1。</p><p>既然这样，那么是不是可以直接操作<code>this.state</code>呢？比如：<code>this.state.value=this.state.value+1;</code>这样的确可以修改<code>this.state.value</code>的状态但是却不可以引发重复渲染。所以，就必须通过React设定的<code>setState</code>函数去改变<code>this.state</code>，从而引发重新渲染。</p><h5 id="setTimeout里面的两次setState"><a href="#setTimeout里面的两次setState" class="headerlink" title="setTimeout里面的两次setState:"></a><code>setTimeout</code>里面的两次<code>setState</code>:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第三次输出2</span></span><br><span class="line">           <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第四次输出3</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在<code>React</code>中，<strong>如果是由React引发的事件处理（比如：<code>onClick</code>引发的事件处理），调用<code>setState</code>不会同步更新<code>this.state</code>，除此之外的<code>setState</code>调用会同步执行t<code>his.setState</code>。</strong> “除此之外”指的是：绕过React通过<code>addEventListener</code>直接添加的事件处理函数和<code>setTimeout/setInterval</code>产生的异步调用。</p><p><img src="..%5Cimage%5CsetState%5CsetState.png" alt="setState"></p><blockquote><p>每次setState产生新的state会依次被存入一个队列，然后会根据<strong>isBathingUpdates</strong>变量判断是直接更新this.state还是放进dirtyComponent里回头再说。isBatchingUpdates默认是false，也就表示setState会同步更新this.state。但是，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，造成的后果就是由React控制的事件处理过程setState不会同步更新this.state。</p></blockquote></li></ol><h4 id="3-同步更新state的办法—函数式setState"><a href="#3-同步更新state的办法—函数式setState" class="headerlink" title="3.同步更新state的办法—函数式setState"></a>3.同步更新state的办法—函数式setState</h4><p>如果this.setState的参数不是一个对象而是一个函数时，这个函数会接收到两个参数，第一个是当前的state值，第二个是当前的props，这个函数应该返回一个对象，这个对象代表想要对this.state的更改，换句话说，之前你想给this.setState传递什么对象参数，在这种函数里就返回什么对象。不过，计算这个对象的方法有些改变，不再依赖于this.state，而是依赖于输入参数state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementMultiple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如当前this.state.count的值是0，第一次调用this.setState(increment)，传给increment的state参数是0，第二次调用时，state参数是1，第三次调用时参数是2，最终incrementMultiple让this.state.count变成了3。</p><p>对于多次调用函数式setState的情况，React会保证调用每次increment时，state都已经合并了之前的状态修改结果。</p><h4 id="4-把两种setState的用法混用"><a href="#4-把两种setState的用法混用" class="headerlink" title="4.把两种setState的用法混用"></a>4.把两种setState的用法混用</h4><h5 id="把incrementMultiple改成这样"><a href="#把incrementMultiple改成这样" class="headerlink" title="把incrementMultiple改成这样"></a>把incrementMultiple改成这样</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementMultiple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在几个函数式setState调用中插入一个传统式setState调用，最后得到的结果是让this.state.count增加了2，而不是增加4。</p><p>这是因为React会依次合并所有setState产生的效果，虽然前两个函数式setState调用产生的效果是count加2，但是中间出现一个传统式setState调用，一下子强行把积攒的效果清空，用count加1取代。</p><p>所以，传统式setState与函数式setState一定不要混用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React中的state&quot;&gt;&lt;a href=&quot;#React中的state&quot; class=&quot;headerlink&quot; title=&quot;React中的state&quot;&gt;&lt;/a&gt;React中的state&lt;/h3&gt;&lt;h4 id=&quot;1-不能直接修改-state&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React与Vue比较1</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%831/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%831/</id>
    <published>2020-02-04T06:58:44.103Z</published>
    <updated>2020-02-04T07:05:31.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React与Vue的对比上"><a href="#React与Vue的对比上" class="headerlink" title="React与Vue的对比上"></a>React与Vue的对比上</h2><h5 id="1、监听数据变化的实现原理不同"><a href="#1、监听数据变化的实现原理不同" class="headerlink" title="1、监听数据变化的实现原理不同"></a><strong>1、监听数据变化的实现原理不同</strong></h5><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用地址的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染</li></ul><p>为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。所以应该说没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。</p><p>因为一般都会用一个数据层的框架比如 Vuex 和 Redux，所以这部分不作过多解释，在最后的 vuex 和 redux的区别 中也会讲到。</p><h5 id="2、数据流的不同"><a href="#2、数据流的不同" class="headerlink" title="2、数据流的不同"></a><strong>2、数据流的不同</strong></h5><p>大家都知道Vue中默认是支持双向绑定的。在Vue1.0中我们可以实现两种双向绑定：</p><ol><li>父子组件之间，props 可以双向绑定</li><li>组件与DOM之间可以通过 v-model 双向绑定</li></ol><p>在 Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且 Vue2.x 已经不鼓励组件对自己的 props 进行任何修改了。所以现在我们只有 组件 &lt;––&gt; DOM 之间的双向绑定这一种。</p><p>然而 React 从诞生之初就不支持双向绑定，React一直提倡的是单向数据流，他称之为 onChange/setState()模式。</p><p>不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。</p><h5 id="3、模板渲染方式的不同"><a href="#3、模板渲染方式的不同" class="headerlink" title="3、模板渲染方式的不同"></a><strong>3、模板渲染方式的不同</strong></h5><p>在表层上， 模板的语法不同</p><ul><li>React 是通过JSX渲染模板</li><li>而Vue是通过一种拓展的HTML语法进行渲染</li></ul><p>但其实这只是表面现象，毕竟React并不必须依赖JSX。</p><p>在深层上，模板的原理不同，这才是他们的本质区别：</p><ul><li>React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的</li><li>Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现</li></ul><h5 id="4、Vuex-和-Redux-的区别"><a href="#4、Vuex-和-Redux-的区别" class="headerlink" title="4、Vuex 和 Redux 的区别"></a><strong>4、Vuex 和 Redux 的区别</strong></h5><p>从表面上来说，store 注入和使用方式有一些区别。</p><p>在 Vuex 中，$store 被直接注入到了组件实例中，因此可以比较灵活的使用：</p><ul><li>使用 dispatch 和 commit 提交更新</li><li>通过 mapState 或者直接通过 this.$store 来读取数据</li></ul><p>在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。</p><p>另外 Vuex 更加灵活一些，组件中既可以 dispatch action 也可以 commit updates，而 Redux 中只能进行 dispatch，并不能直接调用 reducer 进行修改。</p><p>从实现原理上来说，最大的区别是两点：</p><ul><li>Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改</li><li>Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React与Vue的对比上&quot;&gt;&lt;a href=&quot;#React与Vue的对比上&quot; class=&quot;headerlink&quot; title=&quot;React与Vue的对比上&quot;&gt;&lt;/a&gt;React与Vue的对比上&lt;/h2&gt;&lt;h5 id=&quot;1、监听数据变化的实现原理不同&quot;&gt;&lt;a h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—Create-React-App</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94Create-React-App/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94Create-React-App/</id>
    <published>2020-02-04T06:37:18.660Z</published>
    <updated>2020-02-04T06:43:01.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-create-react-app-创建及使用"><a href="#1-create-react-app-创建及使用" class="headerlink" title="1. create-react-app 创建及使用"></a>1. <code>create-react-app</code> 创建及使用</h2><blockquote><h5 id="Create-React-App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用"><a href="#Create-React-App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用" class="headerlink" title="Create React App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用"></a><code>Create React App</code>是<strong>FaceBook</strong>的React团队官方出的一个构建<code>React</code>单页面应用的脚手架工具。它本身集成了<code>Webpack</code>，并配置了一系列内置的<code>loader</code>和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用</h5></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全局安装</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建一个my-app的项目(my-app 是你的项目的名称)</span></span><br><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动编译当前的React项目，并自动打开 http://localhost:3000/</span></span><br><span class="line">npm start</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">yard start</span><br></pre></td></tr></table></figure><h5 id="注意：如果你不能确保最新版本，可以尝试卸载：npm-uninstall-g-create-react-app然后全局安装"><a href="#注意：如果你不能确保最新版本，可以尝试卸载：npm-uninstall-g-create-react-app然后全局安装" class="headerlink" title="注意：如果你不能确保最新版本，可以尝试卸载：npm uninstall -g create-react-app然后全局安装"></a>注意：如果你不能确保最新版本，可以尝试卸载：<code>npm uninstall -g create-react-app</code>然后全局安装</h5><h4 id="1-1-项目目录（默认）："><a href="#1-1-项目目录（默认）：" class="headerlink" title="1.1 项目目录（默认）："></a>1.1 项目目录（默认）：</h4><p><img src="../image%5Ccreate-react-app%5Creact%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%AE%E5%BD%95.png" alt="react初始化目录"></p><h5 id="对于要创建的项目，这些文件必须以明确的文件名存在："><a href="#对于要创建的项目，这些文件必须以明确的文件名存在：" class="headerlink" title="对于要创建的项目，这些文件必须以明确的文件名存在："></a>对于要创建的项目，这些文件必须以明确的文件名存在：</h5><ul><li><code>public/index.html</code> 是页面模板;</li><li><code>src/index.js</code> 是 JavaScript 入口点。</li><li>在 <code>src</code> 中创建子目录。 为了加快重新构建的速度，<code>Webpack</code>只处理 <code>src</code> 中的文件。 你需要<strong>将任何 JS 和 CSS 文件放在 <code>src</code> 中</strong>，否则 <code>Webpack</code>将发现不了它们 </li></ul><blockquote><h5 id="在package-json中：-只有三个依赖，分别是react，react-dom-react-scripts-依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令-都是通过调用react-scripts这个依赖下面的命令进行启动的-creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来，-如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件"><a href="#在package-json中：-只有三个依赖，分别是react，react-dom-react-scripts-依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令-都是通过调用react-scripts这个依赖下面的命令进行启动的-creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来，-如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件" class="headerlink" title="在package.json中： 只有三个依赖，分别是react，react-dom,react-scripts,依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令 都是通过调用react-scripts这个依赖下面的命令进行启动的, creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来， 如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件"></a>在<code>package.json</code>中： 只有三个依赖，分别是<code>react，react-dom,react-scripts</code>,依赖为什么这么少，是因为像<code>webpack，babel</code>等等都是被<code>creat-react-app</code>封装到了react-scripts这个项目当中，包括基本启动命令 都是通过调用<code>react-scripts</code>这个依赖下面的命令进行启动的, <code>creat-react-app</code>搭建出来的项目默认支持这4种命令，<code>start</code>以开发模式启动项目，<code>build</code>将整个项目进行构建，<code>test</code>进行测试，<code>eject</code>会将原本<code>creat-react-app</code>对webpack，babel等相关配置的封装弹射出来， 如果我们要将<code>creat-react-app</code>配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过<code>eject</code>命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件</h5></blockquote><h5 id="1-1-1-可用的Scripts"><a href="#1-1-1-可用的Scripts" class="headerlink" title="1.1.1 可用的Scripts"></a>1.1.1 可用的Scripts</h5><ul><li><p><code>npm start</code></p><p>在开发模式下运行应用程序 </p></li><li><p><code>npm test</code></p><p>以交互式监视模式启动测试运行器 </p></li><li><p><code>npm run build</code></p><p>将生产应用程序构建到 <code>build</code> 文件夹 </p></li><li><p><code>npm run eject</code></p></li></ul><h4 id="1-2在create-react-app中使用css-module两种方式"><a href="#1-2在create-react-app中使用css-module两种方式" class="headerlink" title="1.2在create-react-app中使用css module两种方式"></a>1.2在<code>create-react-app</code>中使用<code>css module</code>两种方式</h4><h5 id="1-2-1-使用-css-module-的第一种方式"><a href="#1-2-1-使用-css-module-的第一种方式" class="headerlink" title="1.2.1 使用 css module 的第一种方式"></a>1.2.1 使用 <code>css module</code> 的第一种方式</h5><blockquote><h6 id="create-react-app-中内置了使用-CSS-Modules-的配置，当前方式就是使用-create-react-app内置的用法"><a href="#create-react-app-中内置了使用-CSS-Modules-的配置，当前方式就是使用-create-react-app内置的用法" class="headerlink" title="create-react-app 中内置了使用 CSS Modules 的配置，当前方式就是使用 create-react-app内置的用法"></a><code>create-react-app</code> 中内置了使用 <code>CSS Modules</code> 的配置，当前方式就是使用 <code>create-react-app</code>内置的用法</h6></blockquote><h5 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h5><blockquote><h6 id="将所有的-css-scss等样式文件都修改成-module-css-module-scss-等。即可使用-CSS-Modules的方式进行引入使用了"><a href="#将所有的-css-scss等样式文件都修改成-module-css-module-scss-等。即可使用-CSS-Modules的方式进行引入使用了" class="headerlink" title="将所有的 .css/.scss等样式文件都修改成 .module.css/.module.scss 等。即可使用 CSS Modules的方式进行引入使用了"></a>将所有的 <code>.css/.scss</code>等样式文件都修改成 <code>.module.css/.module.scss</code> 等。即可使用 <code>CSS Modules</code>的方式进行引入使用了</h6></blockquote><h5 id="用法：编写一个css文件：union-module-css"><a href="#用法：编写一个css文件：union-module-css" class="headerlink" title="用法：编写一个css文件：union.module.css"></a>用法：编写一个css文件：<code>union.module.css</code></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在编写一个普通的-css-文件：common-css"><a href="#在编写一个普通的-css-文件：common-css" class="headerlink" title="在编写一个普通的 css 文件：common.css"></a>在编写一个普通的 css 文件：<code>common.css</code></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在App-jsx-文件中使用-CSS-Modules的方式进行引用：union-module-css"><a href="#在App-jsx-文件中使用-CSS-Modules的方式进行引用：union-module-css" class="headerlink" title="在App. jsx 文件中使用 CSS Modules的方式进行引用：union.module.css"></a>在<code>App. jsx</code> 文件中使用 <code>CSS Modules</code>的方式进行引用：<code>union.module.css</code></h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> union <span class="keyword">from</span> <span class="string">'./css/union.module.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./css/common.css'</span></span><br><span class="line"><span class="built_in">console</span>.log(union)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p className=&#123;union.error&#125;&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="在浏览器中查看效果"><a href="#在浏览器中查看效果" class="headerlink" title="在浏览器中查看效果:"></a>在浏览器中查看效果:</h4><blockquote><p>此时 App组件的背景颜色是红色，但是字体颜色却不是红色，因为使用了 <code>Css Modules</code> 之后，普通的 css 样式就不起效果了，需要用全局的方式编写才可以(:global)。 最后添加到元素上的样式结果为：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"union_error_3UaRT"</span>&gt;</span>悲催的一天开始了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用scss的效果和css效果一样-但是使用scsss时需要安装："><a href="#使用scss的效果和css效果一样-但是使用scsss时需要安装：" class="headerlink" title="使用scss的效果和css效果一样,但是使用scsss时需要安装："></a>使用<code>scss</code>的效果和<code>css</code>效果一样,但是使用<code>scsss</code>时需要安装：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i node-sass -D // 因为create-react-app中没有内置</span><br></pre></td></tr></table></figure><h5 id="然后就可以使用-scss的文件编译了"><a href="#然后就可以使用-scss的文件编译了" class="headerlink" title="然后就可以使用.scss的文件编译了"></a>然后就可以使用<code>.scss</code>的文件编译了</h5><h5 id="1-2-2-使用-css-Module的第二种方式"><a href="#1-2-2-使用-css-Module的第二种方式" class="headerlink" title="1.2.2 使用 css Module的第二种方式"></a>1.2.2 使用 <code>css Module</code>的第二种方式</h5><h5 id="方式：-1"><a href="#方式：-1" class="headerlink" title="方式："></a>方式：</h5><blockquote><h6 id="在命令行运行-npm-run-eject-命令-此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆"><a href="#在命令行运行-npm-run-eject-命令-此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆" class="headerlink" title="在命令行运行 npm run eject 命令,  此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆"></a>在命令行运行 <code>npm run eject</code> 命令,  此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆</h6></blockquote><blockquote><h6 id="运行完成之后，打开-config-目录下的webpack-config-js-文件，找到-test-cssRegex-这一行"><a href="#运行完成之后，打开-config-目录下的webpack-config-js-文件，找到-test-cssRegex-这一行" class="headerlink" title="运行完成之后，打开 config 目录下的webpack.config.js 文件，找到 test: cssRegex 这一行"></a>运行完成之后，打开 config 目录下的<code>webpack.config.js</code> 文件，找到 <code>test: cssRegex</code> 这一行</h6></blockquote><blockquote><h6 id="在-use-属性执行的方法中添加-modules-true，如下图："><a href="#在-use-属性执行的方法中添加-modules-true，如下图：" class="headerlink" title="在 use 属性执行的方法中添加 modules: true，如下图："></a>在 use 属性执行的方法中添加 <code>modules: true</code>，如下图：</h6></blockquote><p><img src="../image%5Ccreate-react-app%5Ccss_modules.png" alt="css_modules"></p><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><blockquote><h6 id="和第一种方式的用法一致，只是不需要在-css-文件后面加-module-后缀了"><a href="#和第一种方式的用法一致，只是不需要在-css-文件后面加-module-后缀了" class="headerlink" title="和第一种方式的用法一致，只是不需要在 css 文件后面加 .module 后缀了"></a>和第一种方式的用法一致，只是不需要在 css 文件后面加 .module 后缀了</h6></blockquote><h5 id="在浏览器中查看效果-1"><a href="#在浏览器中查看效果-1" class="headerlink" title="在浏览器中查看效果:"></a>在浏览器中查看效果:</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class="_2elxDxwd6P93-x9qDZkogR"&gt;悲催的一天开始了&lt;/p&gt;</span><br></pre></td></tr></table></figure><hr><blockquote><h6 id="如想使用第二种方式对-sass-和-less-也使用-CSS-Modules-的方式进行引用，则类似的在-sass-和-less-解析配置上也添加modules-true-即可。"><a href="#如想使用第二种方式对-sass-和-less-也使用-CSS-Modules-的方式进行引用，则类似的在-sass-和-less-解析配置上也添加modules-true-即可。" class="headerlink" title="如想使用第二种方式对 sass 和 less 也使用 CSS Modules 的方式进行引用，则类似的在 sass 和 less 解析配置上也添加modules: true 即可。"></a><strong>如想使用第二种方式对 sass 和 less 也使用 CSS Modules 的方式进行引用，则类似的在 sass 和 less 解析配置上也添加<code>modules: true</code> 即可。</strong></h6></blockquote><hr><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><h6 id="默认-create-react-app-脚手架不能直接使用-sass-和-less-直接编写-css，需要先进行相应配置"><a href="#默认-create-react-app-脚手架不能直接使用-sass-和-less-直接编写-css，需要先进行相应配置" class="headerlink" title="默认 create-react-app 脚手架不能直接使用 sass 和 less 直接编写 css，需要先进行相应配置"></a>默认 <code>create-react-app</code> 脚手架不能直接使用 sass 和 less 直接编写 css，需要先进行相应配置</h6></blockquote><h4 id="1-3-在-Create-React-App-中启用-Sass-和-Less"><a href="#1-3-在-Create-React-App-中启用-Sass-和-Less" class="headerlink" title="1.3 在 Create-React-App 中启用 Sass 和 Less"></a>1.3 在 <code>Create-React-App</code> 中启用 Sass 和 Less</h4><h5 id="1-3-1-启用-sass-语法编写-css"><a href="#1-3-1-启用-sass-语法编写-css" class="headerlink" title="1.3.1 启用 sass 语法编写 css"></a>1.3.1 启用 sass 语法编写 css</h5><blockquote><p> <code>create-react-app</code>脚手架中已经添加了 sass-loader 的支持，所以只需要安装 <code>node-sass</code>插件即可 </p></blockquote><h5 id="安装：node-sass插件"><a href="#安装：node-sass插件" class="headerlink" title="安装：node-sass插件"></a>安装：node-sass插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install node-sass --save</span><br><span class="line"><span class="meta">#</span><span class="bash">or</span></span><br><span class="line">yarn add node-sass</span><br></pre></td></tr></table></figure><h5 id="用法：编写-sass文件：-App-scss"><a href="#用法：编写-sass文件：-App-scss" class="headerlink" title="用法：编写 sass文件： App.scss"></a>用法：编写 sass文件： App.scss</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.App</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: hotpink;</span><br><span class="line">  <span class="selector-class">.common</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在js文件中直接使用："><a href="#在js文件中直接使用：" class="headerlink" title="在js文件中直接使用："></a>在js文件中直接使用：</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./components/User'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p className=<span class="string">"common"</span>&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;User /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">因为此时scss中没有开启模块化 所以在全局中引用该样式属性都会被使用该类的样式</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h5 id="1-3-2-启用-less-语法编写-css"><a href="#1-3-2-启用-less-语法编写-css" class="headerlink" title="1.3.2 启用 less 语法编写 css"></a>1.3.2 启用 less 语法编写 css</h5><blockquote><p> 由于 <code>create-react-app</code>脚手架中并没有配置关于 less 文件的解析，所以我们需要自己进行配置。需要安装的插件 <code>less</code>， <code>less-loader</code> </p></blockquote><h5 id="安装：less-、less-loader"><a href="#安装：less-、less-loader" class="headerlink" title="安装：less 、less-loader"></a>安装：less 、less-loader</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i less -S</span><br><span class="line">npm i less-loader -S</span><br></pre></td></tr></table></figure><h5 id="打开web-config-js文件-找到-style-files-regexes-注释位置，仿照其解析-sass-的规则，在下面添加两行代码"><a href="#打开web-config-js文件-找到-style-files-regexes-注释位置，仿照其解析-sass-的规则，在下面添加两行代码" class="headerlink" title="打开web.config.js文件  找到 // style files regexes 注释位置，仿照其解析 sass 的规则，在下面添加两行代码"></a>打开<code>web.config.js</code>文件  找到 <code>// style files regexes</code> 注释位置，仿照其解析 sass 的规则，在下面添加两行代码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 添加 less 解析规则</span><br><span class="line">const lessRegex = /\.less$/;</span><br><span class="line">const lessModuleRegex = /\.module\.less$/;</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less.png" alt="less"></p><h5 id="找到-rules-属性配置，在其中添加-less-解析配置"><a href="#找到-rules-属性配置，在其中添加-less-解析配置" class="headerlink" title="找到 rules 属性配置，在其中添加 less 解析配置"></a>找到 rules 属性配置，在其中添加 less 解析配置</h5><blockquote><blockquote><h6 id="注意：-这里有一个需要注意的地方，下面的这些-less-配置规则放在-sass-的解析规则下面即可，如果放在了-file-loader-的解析规则下面，less-文件解析不会生效。"><a href="#注意：-这里有一个需要注意的地方，下面的这些-less-配置规则放在-sass-的解析规则下面即可，如果放在了-file-loader-的解析规则下面，less-文件解析不会生效。" class="headerlink" title="注意： 这里有一个需要注意的地方，下面的这些 less 配置规则放在 sass 的解析规则下面即可，如果放在了 file-loader 的解析规则下面，less 文件解析不会生效。"></a><strong>注意：</strong> 这里有一个需要注意的地方，下面的这些 <code>less</code> 配置规则放在 <code>sass</code> 的解析规则下面即可，如果放在了 <code>file-loader</code> 的解析规则下面，<code>less</code> 文件解析不会生效。</h6></blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less 解析配置</span></span><br><span class="line">&#123;</span><br><span class="line">    test: lessRegex,</span><br><span class="line">    exclude: lessModuleRegex,</span><br><span class="line">    use: getStyleLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'less-loader'</span></span><br><span class="line">    ),</span><br><span class="line">    sideEffects: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: lessModuleRegex,</span><br><span class="line">    use: getStyleLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">            modules: <span class="literal">true</span>,</span><br><span class="line">            getLocalIdent: getCSSModuleLocalIdent,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'less-loader'</span></span><br><span class="line">    )</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less_module.png" alt="less_module"></p><h5 id="用法-编写-less-文件：App-less"><a href="#用法-编写-less-文件：App-less" class="headerlink" title="用法: 编写 less 文件：App.less"></a>用法: 编写 less 文件：<code>App.less</code></h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.App</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00a4ff</span>;</span><br><span class="line">  <span class="selector-class">.common</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">color</span>: hotpink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在js文件中直接使用：改写App-js"><a href="#在js文件中直接使用：改写App-js" class="headerlink" title="在js文件中直接使用：改写App.js"></a>在js文件中直接使用：改写App.js</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./components/User'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.less'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p className=<span class="string">"common"</span>&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;User /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="注意：刚刚启用的scss、less是没有启动模块化的，在web-config-js中启动模块化"><a href="#注意：刚刚启用的scss、less是没有启动模块化的，在web-config-js中启动模块化" class="headerlink" title="注意：刚刚启用的scss、less是没有启动模块化的，在web.config.js中启动模块化"></a>注意：刚刚启用的scss、less是没有启动模块化的，在<code>web.config.js</code>中启动模块化</h4><h4 id="然后在css中不要启动模块化-确保引入第三方插件时能够正常使用"><a href="#然后在css中不要启动模块化-确保引入第三方插件时能够正常使用" class="headerlink" title="然后在css中不要启动模块化,确保引入第三方插件时能够正常使用"></a>然后在css中不要启动模块化,确保引入第三方插件时能够正常使用</h4></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less 解析配置</span></span><br><span class="line">            &#123;</span><br><span class="line">              test: lessRegex,</span><br><span class="line">              exclude: lessModuleRegex,</span><br><span class="line">              use: getStyleLoaders(</span><br><span class="line">                &#123;</span><br><span class="line">                  importLoaders: <span class="number">2</span>,</span><br><span class="line">                  modules: <span class="literal">true</span>,</span><br><span class="line">                  localIdentName: <span class="string">'[name]__[local]-[hash:base64:5]'</span>,</span><br><span class="line">                  sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'less-loader'</span></span><br><span class="line">              ),</span><br><span class="line">              sideEffects: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%9D%97%E5%8C%96.png" alt="less启动模块化"></p><h4 id="1-4-添加图片、字体图标、文件"><a href="#1-4-添加图片、字体图标、文件" class="headerlink" title="1.4 添加图片、字体图标、文件"></a>1.4 添加图片、字体图标、文件</h4><h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><blockquote><h6 id="在js文件中使用"><a href="#在js文件中使用" class="headerlink" title="在js文件中使用:"></a>在<code>js</code>文件中使用:</h6></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引用</span><br><span class="line">// 例如</span><br><span class="line">import logo from './logo.png'</span><br><span class="line"></span><br><span class="line">// &lt;img src=&#123;logo&#125; alt="Logo" /&gt;</span><br></pre></td></tr></table></figure><blockquote><h6 id="在css文件中使用："><a href="#在css文件中使用：" class="headerlink" title="在css文件中使用："></a>在<code>css</code>文件中使用：</h6></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 例如</span><br><span class="line"><span class="selector-class">.Logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(./logo.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><blockquote><h5 id="在index-js或者App根组件中直接引入iconfont-css"><a href="#在index-js或者App根组件中直接引入iconfont-css" class="headerlink" title="在index.js或者App根组件中直接引入iconfont.css"></a>在<code>index.js或者App根组件</code>中直接引入<code>iconfont.css</code></h5></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 例如</span><br><span class="line">import './style/iconfont.css'</span><br><span class="line"></span><br><span class="line">//引用</span><br><span class="line">&lt;p className="icon-fenxiang"&gt;子组件&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="2-配置代理"><a href="#2-配置代理" class="headerlink" title="2.配置代理"></a>2.配置代理</h2><p><strong>环境变量：</strong></p><blockquote><p>在根目录直接新建文件：<br><code>.env.production</code><br>就是生产环境的变量 </p><p> 变量规则：<br>必须是 <code>REACT_APP_</code>开头的 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REACT_APP_ROOT='/api'</span><br></pre></td></tr></table></figure><blockquote><p> 读取不变还是 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let root = process.env.REACT_APP_ROOT</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置代理</strong></p><p>在src 根目录新建：<code>setupProxy.js</code><br>配置还是一样的</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(proxy(<span class="string">'/api'</span>, &#123;</span><br><span class="line">    target: <span class="string">'http://192.168.152.55:6666'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">"^/api"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>react会自动加载这个文件 *</em></p><h2 id="3-Redux使用"><a href="#3-Redux使用" class="headerlink" title="3. Redux使用"></a>3. <code>Redux</code>使用</h2><h4 id="3-1-Redux介绍"><a href="#3-1-Redux介绍" class="headerlink" title="3.1 Redux介绍"></a>3.1 <code>Redux</code>介绍</h4><p> <code>Redux</code>是一个用来管理管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂，JavaScript需要管理比任何时候都要多的<code>state</code>（状态），Redux就是降低管理难度的 </p><p><img src="../image/create-react-app/redux_flow.png" alt="redux_flow"></p><h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux -S</span><br></pre></td></tr></table></figure><h4 id="项目src下新建TodoList-jsx："><a href="#项目src下新建TodoList-jsx：" class="headerlink" title="项目src下新建TodoList.jsx："></a>项目src下新建<code>TodoList.jsx</code>：</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span>  <span class="comment">// src下的创建的store文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; changeInputAction, addItemAction, deleteItemAction, getList &#125; <span class="keyword">from</span> <span class="string">'./store/actionCreators'</span></span><br><span class="line"><span class="keyword">import</span> TodoListUI <span class="keyword">from</span> <span class="string">'./TodoListUI'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// store.getState() 会拿到store中存储的值</span></span><br><span class="line">    <span class="keyword">this</span>.state = store.getState()</span><br><span class="line">    <span class="keyword">this</span>.changeInputValue = <span class="keyword">this</span>.changeInputValue.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.storeChange = <span class="keyword">this</span>.storeChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.clickBtn = <span class="keyword">this</span>.clickBtn.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.deleteItem = <span class="keyword">this</span>.deleteItem.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 订阅Redux的状态</span></span><br><span class="line">    store.subscribe(<span class="keyword">this</span>.storeChange)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">TodoListUI</span></span></span></span><br><span class="line"><span class="xml">      inputValue=&#123;this.state.inputValue&#125;</span></span><br><span class="line"><span class="xml">      list=&#123;this.state.list&#125;</span></span><br><span class="line"><span class="xml">      changeInputValue=&#123;this.changeInputValue&#125;</span></span><br><span class="line"><span class="xml">      clickBtn=&#123;this.clickBtn&#125;</span></span><br><span class="line"><span class="xml">      deleteItem=&#123;this.deleteItem&#125;</span></span><br><span class="line"><span class="xml">    /&gt;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  componentDidMount() &#123;</span></span><br><span class="line"><span class="xml">    axios.get('http://localhost:3000/List.json')</span></span><br><span class="line"><span class="xml">    .then(res =&gt; &#123;</span></span><br><span class="line"><span class="xml">      // console.log(res.data)</span></span><br><span class="line"><span class="xml">      const action = getList(res.data.data)</span></span><br><span class="line"><span class="xml">      store.dispatch(action)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  changeInputValue(e) &#123;</span></span><br><span class="line"><span class="xml">    const action = changeInputAction(e.target.value)</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  clickBtn() &#123;</span></span><br><span class="line"><span class="xml">    const action = addItemAction()</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  deleteItem(index) &#123;</span></span><br><span class="line"><span class="xml">    const action = deleteItemAction(index)</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 订阅Redux的状态</span></span><br><span class="line"><span class="xml">  storeChange() &#123;</span></span><br><span class="line"><span class="xml">    this.setState(store.getState())</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default TodoList;</span></span><br></pre></td></tr></table></figure><h4 id="项目src下新建TodoListUI-jsx"><a href="#项目src下新建TodoListUI-jsx" class="headerlink" title="项目src下新建TodoListUI.jsx"></a>项目src下新建<code>TodoListUI.jsx</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Input, Button, List &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TodoListUI = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(props)</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Input</span><br><span class="line">        placeholder=&#123;props.inputValue&#125;</span><br><span class="line">        style=&#123;&#123; width: '250px', marginRight: '10px' &#125;&#125;</span><br><span class="line">        onChange=&#123;props.changeInputValue&#125;</span><br><span class="line">        value=&#123;props.inputValue&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        type="primary"</span><br><span class="line">        onClick=&#123;props.clickBtn&#125;&gt;增加&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div style=&#123;&#123; margin: '10px', width: '300px' &#125;&#125;&gt;</span><br><span class="line">      &lt;List</span><br><span class="line">        bordered</span><br><span class="line">        dataSource=&#123;props.list&#125;</span><br><span class="line">        renderItem=&#123;(item, index) =&gt; (&lt;List.Item onClick=&#123;() =&gt; &#123; props.deleteItem(index) &#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default TodoListUI;</span><br></pre></td></tr></table></figure><h4 id="项目src下新建store文件夹，然后创建index-js"><a href="#项目src下新建store文件夹，然后创建index-js" class="headerlink" title="项目src下新建store文件夹，然后创建index.js"></a>项目src下新建store文件夹，然后创建<code>index.js</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入createStore方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据存储仓库</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    reducer,</span><br><span class="line">    <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h4 id="在创建reducer-jsx-reducer配合index-js使用"><a href="#在创建reducer-jsx-reducer配合index-js使用" class="headerlink" title="在创建reducer.jsx(reducer配合index.js使用)"></a>在创建<code>reducer.jsx</code>(reducer配合<code>index.js</code>使用)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;CHANGE_INPUT, ADD_ITEM, DELETE_ITEM, GET_LIST&#125; <span class="keyword">from</span> <span class="string">'./actionType'</span></span><br><span class="line"><span class="comment">// 默认数据</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  inputValue: <span class="string">'Write SomeThing...'</span>,</span><br><span class="line">  list: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reducer里只能接收state，不能改变state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123; <span class="comment">// 就是一个方法函数</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * state: 指的是原始仓库里的状态</span></span><br><span class="line"><span class="comment">   * action: 指的是action新传递的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(action.type === CHANGE_INPUT) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.inputValue = action.value</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === ADD_ITEM) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.list.unshift(newState.inputValue)</span><br><span class="line">    newState.inputValue = <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === DELETE_ITEM) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.list.splice(action.index,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === GET_LIST) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(action)</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state))</span><br><span class="line">    newState.list = action.list.list</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public文件夹下创建List-json"><a href="#public文件夹下创建List-json" class="headerlink" title="public文件夹下创建List.json"></a>public文件夹下创建<code>List.json</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当作axios请求的数据</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"list"</span>: [</span><br><span class="line">      <span class="string">"早上起不来，起床困难族"</span>,</span><br><span class="line">      <span class="string">"中午没精神,没办法,我太难了"</span>,</span><br><span class="line">      <span class="string">"别说了,晚上加班搞工作、学习、学习使我快乐"</span>,</span><br><span class="line">      <span class="string">"我要加班、我要加班、我要加班、重要的事情说三遍!!!"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redux的三个小坑"><a href="#Redux的三个小坑" class="headerlink" title="Redux的三个小坑"></a><code>Redux</code>的三个小坑</h4><blockquote><h5 id="1-store-必须是唯一的，多个store是坚决不被允许的，只能有一个store空间"><a href="#1-store-必须是唯一的，多个store是坚决不被允许的，只能有一个store空间" class="headerlink" title="1. store 必须是唯一的，多个store是坚决不被允许的，只能有一个store空间"></a>1. <code>store</code> 必须是唯一的，多个<code>store</code>是坚决不被允许的，只能有一个<code>store</code>空间</h5><h5 id="2-只有store能改变自己的内容，Reducer不能改变"><a href="#2-只有store能改变自己的内容，Reducer不能改变" class="headerlink" title="2. 只有store能改变自己的内容，Reducer不能改变"></a>2. 只有<code>store</code>能改变自己的内容，<code>Reducer</code>不能改变</h5><h5 id="3-Reducer必须是纯函数"><a href="#3-Reducer必须是纯函数" class="headerlink" title="3. Reducer必须是纯函数"></a>3. <code>Reducer</code>必须是纯函数</h5></blockquote><h5 id="纯函数的定义是："><a href="#纯函数的定义是：" class="headerlink" title="纯函数的定义是："></a>纯函数的定义是：</h5><blockquote><p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-create-react-app-创建及使用&quot;&gt;&lt;a href=&quot;#1-create-react-app-创建及使用&quot; class=&quot;headerlink&quot; title=&quot;1. create-react-app 创建及使用&quot;&gt;&lt;/a&gt;1. &lt;code&gt;crea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React Router4</title>
    <link href="http://yoursite.com/2020/02/03/React%E5%AD%A6%E4%B9%A0%E2%80%94React%20Router4/"/>
    <id>http://yoursite.com/2020/02/03/React%E5%AD%A6%E4%B9%A0%E2%80%94React%20Router4/</id>
    <published>2020-02-03T15:58:29.374Z</published>
    <updated>2020-02-04T06:19:12.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-React-Router-4"><a href="#1-React-Router-4" class="headerlink" title="1. React Router 4"></a>1. React Router 4</h3><ul><li><code>react-router</code> React Router核心</li><li><code>react-router-dom</code> 用于DOM绑定的React Router</li><li><code>react-router-native</code>用于React Native 的 React Router</li><li><code>react-router-redux</code> React Router和 Redux 的集成</li><li><code>react-router-config</code>用于配置静态路由</li></ul><blockquote><p>因此，在实际的 web 项目开发中，<code>react-router</code> 和 <code>react-router-dom</code> 不必同时引用。在 <code>react-router-dom</code> 中包含<code>BrowserRouter</code> 类似  的 DOM 类组件，所以只需要引入 <code>react-router-dom</code>包就可以了</p></blockquote><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Link, Switch&#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br></pre></td></tr></table></figure><h3 id="2-页面中多个模块同时渲染问题"><a href="#2-页面中多个模块同时渲染问题" class="headerlink" title="2. 页面中多个模块同时渲染问题"></a>2. 页面中多个模块同时渲染问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>当访问 <code>path=&quot;/card&quot;</code> 的页面时，<code>path=&quot;/&quot;</code> 的页面也会被渲染出来。匹配 <code>path=&quot;/card&quot;</code> 的路由会匹配 <code>path=&quot;/&quot;</code> 的路由。那么这个问题怎么解决呢？有以下两种方法</p></blockquote><ol><li><p>使用 <code>&lt;Router&gt;</code>的<code>exact</code>关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>使用独立路由：<code>&lt;switch&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route, Switch, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/"</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Switch&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h5 id="首先需要了解下-lt-Router-gt-。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进-lt-Router-gt-组件中，比如："><a href="#首先需要了解下-lt-Router-gt-。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进-lt-Router-gt-组件中，比如：" class="headerlink" title="首先需要了解下&lt;Router&gt;。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进&lt;Router&gt;组件中，比如："></a>首先需要了解下<code>&lt;Router&gt;</code>。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进<code>&lt;Router&gt;</code>组件中，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr/</span>&gt;</span><br><span class="line">        &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Router&gt;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：<Router>下值允许存在一个子元素，如存在多个则会报错。所以上面的代码中，需要使用<code>&lt;div&gt;</code>包裹起来</p></blockquote><h5 id="在实际的项目中，我们一般不会直接使用-lt-Router-gt-而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的-lt-BrowserRouter-gt-以及其他常用的高级路由。"><a href="#在实际的项目中，我们一般不会直接使用-lt-Router-gt-而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的-lt-BrowserRouter-gt-以及其他常用的高级路由。" class="headerlink" title="在实际的项目中，我们一般不会直接使用&lt;Router&gt;,而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的&lt;BrowserRouter&gt;以及其他常用的高级路由。"></a>在实际的项目中，我们一般不会直接使用<code>&lt;Router&gt;</code>,而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的<code>&lt;BrowserRouter&gt;</code>以及其他常用的高级路由。</h5><ol><li><p><code>&lt;BrowserRouter&gt;</code></p><p>使用 HTML5 提供的<code>history API (</code>pushState<code>,</code>replaceState<code>和</code>popstate<code>事件)</code>来保持 UI 和 url 的同步。下面介绍一下该路由组件中的 5 个属性：</p><ul><li><p><code>basename:string</code></p><p>当前位置的基准 <code>url</code> 。如果你的页面部署在服务器的二级（子）目录，你需要将 <code>basename</code> 设置到此子目录。 正确的 <code>url</code> 格式是前面有一个前导斜杠，但不能有尾部斜杠。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter basename=<span class="string">"/calendar"</span>/&gt;</span><br><span class="line">&lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// 渲染为 &lt;a href="/calendar/today"&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>getUserConfirmation: func</code></p><p>当导航需要确认时执行的函数。默认使用 <code>window.confirm</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的确认函数</span></span><br><span class="line"><span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> allowTransition = <span class="built_in">window</span>.confirm(message)</span><br><span class="line">  callback(allowTransition)</span><br><span class="line">&#125;</span><br><span class="line">&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>forceRefresh: bool</code></p><p>当设置为 <code>true</code> 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 <code>true</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> supportsHistory = <span class="string">'pushState'</span> <span class="keyword">in</span> <span class="built_in">window</span>.history</span><br><span class="line">&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>keyLength: number</code></p><p><code>location.key</code> 的长度，默认是 6。点击同一个链接时，每次该路由下的 <code>location.key</code> 都会改变，可以通过 <code>key</code> 的变化来刷新页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter keyLength=&#123;<span class="number">12</span>&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>children: node</code></p><p>渲染单一子组件（元素）。</p></li></ul></li><li><p><code>&lt;HashRouter&gt;</code></p><p>HashRouter 是一种特定的 <code>&lt;Router&gt;</code> ， HashRouter 使用 url 的 <code>hash</code> (例如： window.location.hash ) 来保持 UI 和 url 的同步。由于使用 hash 的方式记录导航历史不支持 <code>location.key</code> 和 <code>location.state</code> ，该技术仅用于支持传统的浏览器。</p></li></ol><h5 id="介绍完-，当然也要说下-，我们使用最频繁的组件，主要职责是当页面的访问地址与-Route-上的-path-匹配时渲染出对应的-UI-界面。"><a href="#介绍完-，当然也要说下-，我们使用最频繁的组件，主要职责是当页面的访问地址与-Route-上的-path-匹配时渲染出对应的-UI-界面。" class="headerlink" title="介绍完 ，当然也要说下 ，我们使用最频繁的组件，主要职责是当页面的访问地址与 Route 上的 path 匹配时渲染出对应的 UI 界面。"></a>介绍完 <code>，当然也要说下</code> ，我们使用最频繁的组件，主要职责是当页面的访问地址与 <code>Route</code> 上的 <code>path</code> 匹配时渲染出对应的 UI 界面。</h5><h5 id="lt-Route-gt-属性值主要有："><a href="#lt-Route-gt-属性值主要有：" class="headerlink" title="&lt;Route&gt; 属性值主要有："></a><code>&lt;Route&gt;</code> 属性值主要有：</h5><ul><li>path: string</li></ul><p>可以被 <code>path-to-regexp</code> 解析的有效 url 路径。如果没有 <code>path</code>，路由将总是被匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/users/:id"</span> component=&#123;User&#125;/&gt;</span><br></pre></td></tr></table></figure><ul><li>exact: bool</li></ul><p>为 <code>true</code> 时，则要求路径与 <code>location.pathname</code> 必须完全匹配。通过下表解释一下：</p><p><img src="https://jdc.jd.com/wp-content/uploads/2018/07/3.png" alt="img"></p><ul><li>strict: bool</li></ul><p>为 <code>true</code> 时，有结尾斜线的路径只能匹配有斜线的 <code>location.pathname</code> 。见下表：</p><p><img src="https://jdc.jd.com/wp-content/uploads/2018/07/4.png" alt="img"></p><p>第二个属性值 <code>exact</code> 就是我们用来解决多个模块同时渲染问题的，默认值为 <code>true</code> 。</p><p>在这里简要提下<code>&lt;Route&gt;</code>渲染的三种方法：</p><ul><li><code>&lt;Route component&gt;</code> 当访问地址和路由匹配时，一个 <code>React component</code> 将会被渲染</li><li><code>&lt;Route render&gt;</code> 此方法适用于内联渲染，而且不会产生重复装载问题</li><li><code>&lt;Route children&gt;</code></li></ul><p>当需要判断访问地址与路由是否匹配时，可以使用此方法。当不匹配时， <code>match</code> 为 null。</p><p>我们上面代码示例中使用的是第一种方法 <code>Route Component</code>，这三种渲染方法都会用到 <code>match</code> 、<code>location</code> 、 <code>history</code> 这些属性值。</p><p>需要注意的是 ：每一种渲染方法都有其适用背景, <code>&lt;Route component&gt;</code>的优先级比 <code>&lt;Route render&gt;</code>高，而他们又都优先于<code>&lt;Route children&gt;</code>，所以在同一个<code>&lt;Route&gt;</code>应该只使用一种方法，我们大多数使用的是 <code>component</code> 方法。</p><h5 id="说完第一种解决方法的原理，来剖析下第二种方法：-Switch-。"><a href="#说完第一种解决方法的原理，来剖析下第二种方法：-Switch-。" class="headerlink" title="说完第一种解决方法的原理，来剖析下第二种方法： Switch 。"></a>说完第一种解决方法的原理，来剖析下第二种方法： <code>Switch</code> 。</h5><p>该组件只渲染第一个与当前访问地址匹配的 <code>Route</code> 或 <code>Redirect</code> 。它和多个堆叠的<code>Route</code>组件之间的区别是： <code>Switch</code> 只渲染一个路由。</p><p>在解决方法 （2）中，当我们访问 <code>/card</code> ， <code>Switch</code> 将会开始寻找与之匹配的路由，查找到<code>&lt;Route path=&quot;/card&quot; /&gt;</code> 匹配后，<code>Switch</code> 将会停止寻找然后开始渲染 <code>/card</code> 。</p><ul><li>children: node</li></ul><p><code>&lt;Switch&gt;</code> 下的子节点只能是 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code> 元素且只有与当前访问地址匹配的第一个子节点才会被渲染。</p></li></ol><h3 id="3-如何定义默认访问页面"><a href="#3-如何定义默认访问页面" class="headerlink" title="3.如何定义默认访问页面"></a>3.如何定义默认访问页面</h3><blockquote><p>有时我们需要定义一个默认页面，重新引导用户的操作</p></blockquote><p>使用 <code>&lt;Redirect&gt;</code> 。比如当用户手动输入 <code>/test</code> 之后，我们需要跳转至首页，则代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">                &lt;Redirect to=<span class="string">"/"</span> /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><blockquote><p>方法解析：<code>&lt;Redirect&gt;</code> 渲染时将会导向一个新的地址，这个新的地址将会覆盖掉 <code>history</code> 堆栈中的当前地址。</p></blockquote><h5 id="lt-Redirect-gt-其常用的属性是："><a href="#lt-Redirect-gt-其常用的属性是：" class="headerlink" title="&lt;Redirect&gt;其常用的属性是："></a><code>&lt;Redirect&gt;</code>其常用的属性是：</h5><ul><li>to: string</li></ul><p>重定向的 url 地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">"/somewhere/else"</span> /&gt;</span><br></pre></td></tr></table></figure><ul><li>to: object</li></ul><p>重定向的 <code>location</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">'/login'</span>,</span><br><span class="line">  search: <span class="string">'?utm=your+face'</span>,</span><br><span class="line">  state: &#123; <span class="attr">referrer</span>: currentLocation &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure><ul><li>push: bool</li></ul><p>取值为 <code>true</code> 时，重定向操作将会把新地址加入到访问的历史记录里面，并不会替换掉当前的地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect push to=<span class="string">"/somewhere/else"</span>/&gt;</span><br></pre></td></tr></table></figure><ul><li>from: string</li></ul><p>需要匹配的将要被重定向的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">'/old-path'</span> to=<span class="string">'/new-path'</span>/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">'/new-path'</span> component=&#123;Place&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：<code>&lt;Route&gt;</code> 元素使用 <code>path</code> 属性进行匹配，<code>Redirect</code> 元素使用 <code>from</code> 属性进行匹配。如果元素中没有对应的 <code>path</code> 或 <code>from</code>，那么它们将匹配任何当前的访问地址。</p></blockquote><h3 id="4-路由激活状态的控制"><a href="#4-路由激活状态的控制" class="headerlink" title="4. 路由激活状态的控制"></a>4. 路由激活状态的控制</h3><blockquote><p>使用<Link>组件或者<NavLink></p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeClassName=<span class="string">"selected"</span></span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><h5 id="lt-NavLink-gt-是-lt-Link-gt-的特殊版本，当遇到匹配的-URL-渲染元素时会添加样式属性，适用于页面导航部分。"><a href="#lt-NavLink-gt-是-lt-Link-gt-的特殊版本，当遇到匹配的-URL-渲染元素时会添加样式属性，适用于页面导航部分。" class="headerlink" title="&lt;NavLink&gt;是&lt;Link&gt; 的特殊版本，当遇到匹配的 URL 渲染元素时会添加样式属性，适用于页面导航部分。"></a><code>&lt;NavLink&gt;</code>是<code>&lt;Link&gt;</code> 的特殊版本，当遇到匹配的 URL 渲染元素时会添加样式属性，适用于页面导航部分。</h5><ul><li>activeClassName: string</li></ul><p>导航选中时的样式名，默认样式名为 <code>active</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeClassName=<span class="string">"selected"</span></span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>activeStyle: object</li></ul><p>导航选中时的样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: <span class="string">'bold'</span>,</span><br><span class="line">    color: <span class="string">'red'</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>exact: bool</li></ul><p>若值为 <code>true</code>，当访问地址严格匹配时激活样式才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  exact</span><br><span class="line">  to=<span class="string">"/profile"</span></span><br><span class="line">&gt;Profile&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>strict: bool</li></ul><p>若值为 <code>true</code>，只有当访问地址后缀斜杠严格匹配（有或无）时激活样式才会生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  strict</span><br><span class="line">  to=<span class="string">"/events/"</span></span><br><span class="line">&gt;Events&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>isActive: func</li></ul><p>用于添加页面激活时的操作逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oddEvent = <span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID)</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/events/123"</span></span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;Event <span class="number">123</span>&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-页面跳转"><a href="#5-页面跳转" class="headerlink" title="5. 页面跳转"></a>5. 页面跳转</h3><ol><li><h5 id="使用-history-控制路由的跳转"><a href="#使用-history-控制路由的跳转" class="headerlink" title="使用 history 控制路由的跳转"></a>使用 history 控制路由的跳转</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.push(<span class="string">'/some/path'</span>);</span><br></pre></td></tr></table></figure><p><code>history</code> 指的是 <code>history</code> 包，是 4.x 中的重要依赖之一。常见的 <code>history</code> 路由方案有三种形式，分别是：</p><ul><li>browser history 在 DOM 上的实现，用于支持 HTML5 history API 的浏览器；</li><li>hash history 在 DOM 上的实现，用于旧版浏览器；</li><li>memory history 在内存上的实现，用于测试或非 DOM 环境（如 <code>React Native</code>）</li></ul><p><code>history</code> 对象包含的属性和方法如下所示：</p><ul><li><code>length</code>: number history 堆栈中的地址数目</li><li><code>action</code>: string 当前的动作 (PUSH , REPLACE , 或者是 POP )</li><li><code>location</code>: object 当前访问地址信息组成的对象</li><li><code>push(path, [state])</code>: func 在 history 堆栈信息里加入一个新路径</li><li><code>replace(path, [state])</code> : func 替换 history 堆栈信息里的当前路径</li><li><code>go(n)</code> : func 将 history 堆栈中的指针向前移动 n</li><li><code>goBack()</code>: func 等同于 go(-1)</li><li><code>goForward()</code>: func 等同于 go(1)</li><li><code>block(prompt)</code> : func 阻止跳转</li></ul><h5 id="需要注意的是：history-对象是可变的，所以不要从-history-location-直接获取，而是需要通过-lt-Route-gt-的prop-来获取-location。"><a href="#需要注意的是：history-对象是可变的，所以不要从-history-location-直接获取，而是需要通过-lt-Route-gt-的prop-来获取-location。" class="headerlink" title="需要注意的是：history 对象是可变的，所以不要从 history.location 直接获取，而是需要通过 &lt;Route&gt; 的prop 来获取 location。"></a>需要注意的是：<code>history</code> 对象是可变的，所以不要从 <code>history.location</code> 直接获取，而是需要通过 <code>&lt;Route&gt;</code> 的<code>prop</code> 来获取 <code>location</code>。</h5></li><li><h5 id="使用-Context，获得-router-对象"><a href="#使用-Context，获得-router-对象" class="headerlink" title="使用 Context，获得 router 对象"></a>使用 <code>Context</code>，获得 <code>router</code> 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">     <span class="keyword">super</span>(props, context);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  myFunction() &#123;</span><br><span class="line">    <span class="keyword">this</span>.context.router.history.push(<span class="string">"/some/Path"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-切换路由后，页面仍然停留在上一个页面的位置"><a href="#6-切换路由后，页面仍然停留在上一个页面的位置" class="headerlink" title="6.切换路由后，页面仍然停留在上一个页面的位置"></a>6.切换路由后，页面仍然停留在上一个页面的位置</h3><h5 id="问题：由-A-页面跳转到-B-页面，B-页面停留在-A-页面的位置，没有返回到顶部。"><a href="#问题：由-A-页面跳转到-B-页面，B-页面停留在-A-页面的位置，没有返回到顶部。" class="headerlink" title="问题：由 A 页面跳转到 B 页面，B 页面停留在 A 页面的位置，没有返回到顶部。"></a>问题：由 A 页面跳转到 B 页面，B 页面停留在 A 页面的位置，没有返回到顶部。</h5><p>用户可以对 window 和独立组件的滚动位置进行管理。可以使用 <code>withRouter</code> 组件： <code>withRouter</code> 可以访问历史对象的属性和最近的 <code>&lt;Route&gt;</code> 匹配项，当路由的属性值 { <code>match</code>, <code>location</code>, <code>history</code> } 改变时，<code>withRouter</code> 都会重新渲染。该组件可以携带组件的路由信息，避免组件之间一层层传递。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">withRouter(MyComponent)</span><br></pre></td></tr></table></figure><p>这样就可以获取到 MyComponent 组件的路由信息了。</p><p>解决方法：使用 <code>withRouter</code> 封装 <code>ScrollToTop</code> 组件。这里就用到了 <code>withRouter</code> 携带路由信息的特性，通过对比<code>props</code> 中 <code>location</code> 的变化，实现页面的滚动</p><ol><li><h5 id="定义-ScrollToTop-组件，代码如下："><a href="#定义-ScrollToTop-组件，代码如下：" class="headerlink" title="定义 ScrollToTop 组件，代码如下："></a>定义 <code>ScrollToTop</code> 组件，代码如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollToTop</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.props.location !== prevProps.location) &#123;</span><br><span class="line">          <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(ScrollToTop);</span><br></pre></td></tr></table></figure></li><li><h5 id="在定义路由处引用该组件，例如："><a href="#在定义路由处引用该组件，例如：" class="headerlink" title="在定义路由处引用该组件，例如："></a>在定义路由处引用该组件，例如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;ScrollToTop&gt;</span><br><span class="line">            &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ScrollToTop&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>这样处理之后，当跳转页面时都会自动回到该页面的顶部位置。</p></li></ol><h3 id="7-页面之间如何传值"><a href="#7-页面之间如何传值" class="headerlink" title="7.页面之间如何传值"></a>7.页面之间如何传值</h3><p>问题背景：当路由发生跳转时我们可能需要携带一些参数</p><p>解决方法：使用 <code>props</code> 属性，介绍以下三种传值方法：</p><ol><li><h5 id="props-params"><a href="#props-params" class="headerlink" title="props.params"></a><code>props.params</code></h5><p>指定一个 path ，然后指定通配符可以携带参数到指定的 <code>path</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/user/:name'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>跳转 UserPage 页面时，可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//link方法</span></span><br><span class="line">&lt;Link to=<span class="string">"/user/sam"</span>&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/push方法</span></span><br><span class="line"><span class="regexp">this.props.history.push("/u</span>ser/sam<span class="string">");</span></span><br></pre></td></tr></table></figure><p>在 UserPage 页面中通过 <code>this.props.params.name</code> 获取值。</p><p>上面的方法可以传递一个或多个值，但是每个值的类型都是字符串，没法传递一个对象。如果要传的话可以将 json 对象转换为字符串，传递过去之后再将 json 字符串转换为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line">data = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line"><span class="keyword">let</span> path = <span class="string">'/user/$&#123;data&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在页面中获取值时</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.props.params.data);</span><br></pre></td></tr></table></figure></li><li><h5 id="query"><a href="#query" class="headerlink" title="query"></a><code>query</code></h5><p><code>query</code> 方式可以传递任意类型的值，但是页面的 <code>url</code> 也是由 <code>query</code> 的值拼接的，<code>url</code> 很长且是明文传输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义路由</span></span><br><span class="line">&lt;Route path=<span class="string">'/user'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据定义</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> path = &#123;</span><br><span class="line">    pathname: <span class="string">'/user'</span>,</span><br><span class="line">    query: data,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面跳转</span></span><br><span class="line">&lt;Link to=&#123;path&#125;&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">this.props.history.push(path);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/页面取值</span></span><br><span class="line"><span class="regexp">let data = this.props.location.query;</span></span><br><span class="line"><span class="regexp">let &#123;id,name,age&#125; = data;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h5><p><code>state</code> 方式类似于 <code>post</code>，依然可以传递任意类型的数据，而且可以不以明文方式传输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义路由</span></span><br><span class="line">&lt;Route path=<span class="string">'/user'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据定义</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> path = &#123;</span><br><span class="line">    pathname: <span class="string">'/user'</span>,</span><br><span class="line">    state: data,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面跳转</span></span><br><span class="line">&lt;Link to=&#123;path&#125;&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">this.props.history.push(path);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/页面取值</span></span><br><span class="line"><span class="regexp">let data = this.props.location.state;</span></span><br><span class="line"><span class="regexp">let &#123;id,name,age&#125; = data;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="8-使用-lt-BrowserRouter-gt-配置路由，上传页面至服务器后页面出现-404"><a href="#8-使用-lt-BrowserRouter-gt-配置路由，上传页面至服务器后页面出现-404" class="headerlink" title="8.使用 &lt;BrowserRouter&gt; 配置路由，上传页面至服务器后页面出现 404"></a>8.使用 <code>&lt;BrowserRouter&gt;</code> 配置路由，上传页面至服务器后页面出现 404</h3><h5 id="问题背景：项目中控制路由跳转使用的是-lt-BrowserRouter-gt-，代码如下："><a href="#问题背景：项目中控制路由跳转使用的是-lt-BrowserRouter-gt-，代码如下：" class="headerlink" title="问题背景：项目中控制路由跳转使用的是 &lt;BrowserRouter&gt;，代码如下："></a>问题背景：项目中控制路由跳转使用的是 <code>&lt;BrowserRouter&gt;</code>，代码如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在开发过程中使用是没有问题的，但是将页面上传至服务器之后，问题就来了：用户访问的资源不存在，页面是空白的。</p><p>问题分析：`` 是使用 React-Router 应用推荐的 <code>history</code> 方案。它使用浏览器中的 History API 用于处理 url，创建一个像 <code>example.com/list/123</code> 这样真实的 url。当通过真实 url 访问网站的时候，由于路径是指向服务器的真实路径，但该路径下并没有相关资源，所以用户访问的资源不存在。</p><p>解决方法：</p><h5 id="1-使用-lt-HashRouter-gt-。"><a href="#1-使用-lt-HashRouter-gt-。" class="headerlink" title="1. 使用 &lt;HashRouter&gt;。"></a>1. 使用 <code>&lt;HashRouter&gt;</code>。</h5><p>它使用 url 中的 hash（#）部分去创建路由，举例来说，用户访问 <code>http://www.example.com/</code> ，实际会看到的是 <code>http://www.example.com/#/</code> 。<br>为什么本地开发时没有问题呢？那是因为我们的 <code>React</code> 脚手架中使用 <code>webpack-dev-server</code> 做了配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webpackConfig.devServer = &#123;</span><br><span class="line">    disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    contentBase: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">//gzip压缩</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-如果要使用-lt-BrowserRouter-gt-的话，服务器需要进行相关路由配置"><a href="#2-如果要使用-lt-BrowserRouter-gt-的话，服务器需要进行相关路由配置" class="headerlink" title="2.如果要使用 &lt;BrowserRouter&gt; 的话，服务器需要进行相关路由配置"></a>2.如果要使用 <code>&lt;BrowserRouter&gt;</code> 的话，服务器需要进行相关路由配置</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-React-Router-4&quot;&gt;&lt;a href=&quot;#1-React-Router-4&quot; class=&quot;headerlink&quot; title=&quot;1. React Router 4&quot;&gt;&lt;/a&gt;1. React Router 4&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Node学习—app.use中间件</title>
    <link href="http://yoursite.com/2020/01/13/Node%E5%AD%A6%E4%B9%A0%E2%80%94app.use%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/01/13/Node%E5%AD%A6%E4%B9%A0%E2%80%94app.use%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2020-01-13T08:00:19.963Z</published>
    <updated>2019-10-19T06:42:42.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Express中路由和中间件"><a href="#1-Express中路由和中间件" class="headerlink" title="1. Express中路由和中间件"></a>1. Express中路由和中间件</h3><h6 id="路由：就是如何处理HTTP请求中的路径部分"><a href="#路由：就是如何处理HTTP请求中的路径部分" class="headerlink" title="路由：就是如何处理HTTP请求中的路径部分"></a>路由：就是如何处理HTTP请求中的路径部分</h6><h6 id="中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数"><a href="#中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数" class="headerlink" title="中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数"></a>中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数</h6><h5 id="1-1-应用及中间件"><a href="#1-1-应用及中间件" class="headerlink" title="1.1 应用及中间件"></a>1.1 应用及中间件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next方法的作用就是将请求传递到下一个中间件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  当请求进来，会从第一个中间件开始进行匹配</span></span><br><span class="line"><span class="comment">     如果匹配，则进来</span></span><br><span class="line"><span class="comment">     如果请求进入中间件之后，没有调用 next 则代码会停在当前中间件</span></span><br><span class="line"><span class="comment">     如果调用了 next 则继续向后找到第一个匹配的中间件</span></span><br><span class="line"><span class="comment">     如果不匹配，则继续判断匹配下一个中间件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不关心请求路径的请求</span></span><br><span class="line"><span class="comment">// 不管以什么路径请求只要有next()传递</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>) <span class="comment">// 1</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)  <span class="comment">// 2</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">req,res.next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)  <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关心请求路径的请求</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/b'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 /a 开头的路径中间件</span></span><br><span class="line">app.use(<span class="string">'/a'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当在浏览器中以 /a 开头的请求时，会输出 1 a 2</span></span><br><span class="line"><span class="comment">// 当在浏览器中以 /b 开头的请求时，会输出 1 b,这里不会输出 2 因为当请求/b开头的请求后没有next()方法传递就会停留在那个请求中</span></span><br></pre></td></tr></table></figure><h5 id="1-2-错误处理中间件"><a href="#1-2-错误处理中间件" class="headerlink" title="1.2 错误处理中间件"></a>1.2 错误处理中间件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/user'</span>,(req,res,next) =&gt; &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(has error)</span><br><span class="line">       next()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">       next(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 全局错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack)</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'error message'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/a'</span>,(req,res,next) =&gt; &#123;</span><br><span class="line">  fs.readFile(path.join(__dirname,<span class="string">'./datas.txt'</span>),<span class="string">'utf8'</span>,(err,data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/a'</span>, (req,res,next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'/a'</span>)</span><br><span class="line">  res.send(<span class="string">'/a'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不匹配任何请求路径时 会进去此错误处理</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'404 not Found'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="1-3-express中的router"><a href="#1-3-express中的router" class="headerlink" title="1.3 express中的router"></a>1.3 express中的router</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> public = <span class="built_in">require</span>(<span class="string">'./router/public'</span>)</span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'./router/user'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/public'</span>, public) <span class="comment">// 当请求以/public开头的路径时才会进来</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/user'</span>, user) <span class="comment">// 当请求以/uer开头的路径时才会进来</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,() =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// router</span></span><br><span class="line"><span class="comment">// 1.user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/a'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello node'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.public.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/b'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><ul><li><strong>app.router() 要挂载在所有第三方中间件的后面，因为前面配置的中间件是app.router()中请求处理函数的依赖</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Express中路由和中间件&quot;&gt;&lt;a href=&quot;#1-Express中路由和中间件&quot; class=&quot;headerlink&quot; title=&quot;1. Express中路由和中间件&quot;&gt;&lt;/a&gt;1. Express中路由和中间件&lt;/h3&gt;&lt;h6 id=&quot;路由：就是如何
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Node学习—express中cookie和session</title>
    <link href="http://yoursite.com/2020/01/13/Node%E5%AD%A6%E4%B9%A0%E2%80%94express%E4%B8%ADcookie%E5%92%8Csession/"/>
    <id>http://yoursite.com/2020/01/13/Node%E5%AD%A6%E4%B9%A0%E2%80%94express%E4%B8%ADcookie%E5%92%8Csession/</id>
    <published>2020-01-13T08:00:19.952Z</published>
    <updated>2020-01-13T11:20:34.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Cookie-和-Session"><a href="#1-Cookie-和-Session" class="headerlink" title="1.Cookie 和 Session"></a>1.Cookie 和 Session</h3><p>​       会话管理：客户端和服务端通信过程中的数据是如何管理的</p><p>​       会话管理的技术：数据存在客户端  Cookie</p><p>​                                      数据存在服务端 Session</p><p>​       <strong>Cookie</strong>: http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据</p><p>​     <strong>Session</strong>: session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源</p><h5 id="1-1-express中使用cookie-parser中间件"><a href="#1-1-express中使用cookie-parser中间件" class="headerlink" title="1.1 express中使用cookie-parser中间件"></a>1.1 express中使用cookie-parser中间件</h5><p><img src="../image/cookie/%E5%9B%BE%E7%89%871.png" alt="cookie"></p><h6 id="1-1-1-安装：npm-install-cookie-parser-S"><a href="#1-1-1-安装：npm-install-cookie-parser-S" class="headerlink" title="1.1.1 安装：npm install cookie-parser -S"></a>1.1.1 安装：npm install cookie-parser -S</h6><h6 id="1-1-2-引包：const-cookieParser-require-‘cookie-parser’"><a href="#1-1-2-引包：const-cookieParser-require-‘cookie-parser’" class="headerlink" title="1.1.2 引包：const cookieParser = require(‘cookie-parser’)"></a>1.1.2 引包：const cookieParser = require(‘cookie-parser’)</h6><h6 id="1-1-3-配置cookie-parser中间件"><a href="#1-1-3-配置cookie-parser中间件" class="headerlink" title="1.1.3 配置cookie-parser中间件"></a>1.1.3 配置cookie-parser中间件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>))</span><br></pre></td></tr></table></figure><h6 id="1-1-4在服务器通过res-cookie-方法创建一个cookie"><a href="#1-1-4在服务器通过res-cookie-方法创建一个cookie" class="headerlink" title="1.1.4在服务器通过res.cookie()方法创建一个cookie"></a>1.1.4在服务器通过res.cookie()方法创建一个cookie</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie的配置参数：</span><br><span class="line">maxAge  : 是cookie最大的有效时间 单位为毫秒</span><br><span class="line">expires ：是cookie的过期时间  是一个date对象</span><br><span class="line">httpOnly ： 当前cookie是否只能被web服务器获取</span><br><span class="line">singed:  是否对cookie进行签名(防止cookie被用户在浏览器修改)</span><br><span class="line">path：   是cookie的有效访问路径(如果没有设置，则默认为根路径)</span><br><span class="line">        比如我们设置了path:&quot;&#x2F;&quot; ，即意味着访问当前网站的任何接口都会携带cookie</span><br><span class="line">        比如我们设置了path:&quot;&#x2F;user&quot;，即意味着只有访问有&#x2F;user开头的接口才会在请求中携带cookie</span><br></pre></td></tr></table></figure><h6 id="1-1-5设置cookie的请求"><a href="#1-1-5设置cookie的请求" class="headerlink" title="1.1.5设置cookie的请求"></a>1.1.5设置cookie的请求</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/setCookie"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.cookie(<span class="string">"name"</span>,<span class="string">"cookiename"</span>,      &#123;<span class="attr">path</span>:<span class="string">"/user"</span>,<span class="attr">maxAge</span>:<span class="number">600000</span>,<span class="attr">httpOnly</span>:<span class="literal">true</span>,<span class="string">'signed'</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">    res.send(<span class="string">'setcookie'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="1-1-6-浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器-服务器此时可以通过req-cookies来查看当前的cookie"><a href="#1-1-6-浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器-服务器此时可以通过req-cookies来查看当前的cookie" class="headerlink" title="1.1.6 浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器,服务器此时可以通过req.cookies来查看当前的cookie"></a>1.1.6 浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器,服务器此时可以通过req.cookies来查看当前的cookie</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/getCookie"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//如果没有对cookie进行签名，则通过req.cookies来获取cookie</span></span><br><span class="line">    <span class="comment">//如果对cookie进行了签名，则通过req.signedCookies来获取cookie</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies,req.signedCookies)  <span class="comment">// &#123;&#125; &#123;&#125;</span></span><br><span class="line">    res.send(<span class="string">'getcookie'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/user"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies,req.signedCookies) <span class="comment">// &#123;&#125; &#123;name: 'cookiename'&#125;</span></span><br><span class="line">    res.send(<span class="string">'getcookie'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="1-1-7-Cookie记住用户名"><a href="#1-1-7-Cookie记住用户名" class="headerlink" title="1.1.7 Cookie记住用户名"></a>1.1.7 Cookie记住用户名</h6><p><img src="../image/cookie/%E5%9B%BE%E7%89%872.png" alt="cookie"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line"></span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;)</span><br><span class="line"></span><br><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;)</span><br><span class="line"></span><br><span class="line">const app &#x3D; express()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: false &#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.engine(&#39;html&#39;, require(&#39;express-art-template&#39;))</span><br><span class="line">app.set(&#39;views&#39;, __dirname + &#39;&#x2F;views&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(cookieParser(&#39;xiaoxiong&#39;))</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;login&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.signedCookies.name) &#123;</span><br><span class="line">    res.render(&#39;login.html&#39;,&#123;</span><br><span class="line">      name: req.signedCookies.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.render(&#39;login.html&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;usercenter&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.signedCookies.name) &#123;</span><br><span class="line">    res.render(&#39;usercenter.html&#39;,&#123;</span><br><span class="line">      name: req.signedCookies.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.render(&#39;usercenter.html&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&#39;&#x2F;login&#39;,(req,res) &#x3D;&gt; &#123;</span><br><span class="line">  let name &#x3D; req.body.name</span><br><span class="line">  let pwd &#x3D; req.body.pwd</span><br><span class="line">  let rmbname &#x3D; req.body.rmbname</span><br><span class="line">  &#x2F;&#x2F; console.log(name+&#39;---&#39;+pwd+&#39;---&#39;+&#39;---&#39;+rmbname)</span><br><span class="line">  if(rmbname &#x3D;&#x3D; &#39;on&#39;) &#123;</span><br><span class="line">    if(name &#x3D;&#x3D; &#39;朱艳&#39; &amp;&amp; pwd &#x3D;&#x3D; &#39;zhuyan&#39;) &#123;</span><br><span class="line">      res.cookie(&#39;name&#39;,name,&#123;</span><br><span class="line">        maxAge: 60000,</span><br><span class="line">        httpOnly: true,</span><br><span class="line">        &#39;signed&#39;: true</span><br><span class="line">      &#125;)</span><br><span class="line">      res.redirect(&#39;&#x2F;usercenter&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.send(&#39;账号或者密码有误&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if(name &#x3D;&#x3D; &#39;朱艳&#39; &amp;&amp; pwd &#x3D;&#x3D; &#39;zhuyan&#39;) &#123;</span><br><span class="line">      res.redirect(&#39;&#x2F;usercenter&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.send(&#39;账号或者密码错误&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;running..&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="2-1express中express-session中间件"><a href="#2-1express中express-session中间件" class="headerlink" title="2.1express中express-session中间件"></a>2.1express中express-session中间件</h5><p><img src="../image/cookie/%E5%9B%BE%E7%89%873.png" alt="session"></p><h6 id="2-1-1-安装：npm-install-express-session-S"><a href="#2-1-1-安装：npm-install-express-session-S" class="headerlink" title="2.1.1 安装：npm install express-session -S"></a>2.1.1 安装：npm install express-session -S</h6><h6 id="2-1-2-引包：const-expressSession-require-‘express-session’"><a href="#2-1-2-引包：const-expressSession-require-‘express-session’" class="headerlink" title="2.1.2 引包：const expressSession = require(‘express-session’)"></a>2.1.2 引包：<em>const</em> expressSession = require(‘express-session’)</h6><h6 id="2-1-3-配置中间件"><a href="#2-1-3-配置中间件" class="headerlink" title="2.1.3 配置中间件"></a>2.1.3 配置中间件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(expressSession(&#123;</span><br><span class="line">  name : <span class="string">"cookieid"</span>,  <span class="comment">//指定所创建的session对应的cookie的名字</span></span><br><span class="line">  secret : <span class="string">'secret'</span>,  <span class="comment">//指定是否要签名这个cookie</span></span><br><span class="line">  <span class="comment">//resave: 强制保存 session 即使它并没有变化,。默认为 true。建议设置成 false。但是这个并不一定是必须的，如果客户端有两个并行的请求到你的服务端，</span></span><br><span class="line">  <span class="comment">// 一个请求对session的修改可能被另外一个请求覆盖掉，即使第二个请求并没有修改session</span></span><br><span class="line">  resave : <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// rolling:强制在每一个response中都发送session标识符的cookie。roling默认是false。如果把这个值设置为true但是  saveUnitialized设置为false,</span></span><br><span class="line">  <span class="comment">// 没有初始化的session的cookie不会被包含在响应中。主要作用：每次请求都重置cookie过期时间</span></span><br><span class="line">  rolling: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 强制没有“初始化”的session保存到storage(store:保存session的地方)中，</span></span><br><span class="line">  <span class="comment">// 没有初始化的session指的是刚被创建没有被修改。默认是true,但是不建议使用默认值</span></span><br><span class="line">  saveUninitialized: <span class="literal">false</span>, </span><br><span class="line">  cookie : &#123;</span><br><span class="line">      maxAge : <span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>,   <span class="comment">//指定session对应的cookie的有效时间</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h6 id="2-1-4设置session"><a href="#2-1-4设置session" class="headerlink" title="2.1.4设置session"></a>2.1.4设置session</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;setsession&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  req.session.userinfo &#x3D; &#39;xiaoyang&#39;</span><br><span class="line">  res.send(&#39;setsession&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="2-1-5-得到session"><a href="#2-1-5-得到session" class="headerlink" title="2.1.5 得到session"></a>2.1.5 得到session</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/getsession'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.session)</span><br><span class="line">  res.send(req.session.userinfo)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="2-1-6-session登录案例"><a href="#2-1-6-session登录案例" class="headerlink" title="2.1.6 session登录案例"></a>2.1.6 session登录案例</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> expressSession = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'html'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>))</span><br><span class="line">app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>)</span><br><span class="line"></span><br><span class="line">app.use(expressSession(&#123;</span><br><span class="line">  name: <span class="string">"cookieid"</span>,  <span class="comment">//指定所创建的session对应的cookie的名字</span></span><br><span class="line">  secret: <span class="string">'secret'</span>,  <span class="comment">//指定是否要签名这个cookie</span></span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  rolling: <span class="literal">true</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">false</span>,</span><br><span class="line">  cookie: &#123;</span><br><span class="line">    maxAge: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>,   <span class="comment">//指定session对应的cookie的有效时间</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/login'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="built_in">console</span>.log(user)</span><br><span class="line">  res.render(<span class="string">'login.html'</span>,user)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取请求参数信息</span></span><br><span class="line">  <span class="keyword">let</span> name = req.body.name</span><br><span class="line">  <span class="keyword">let</span> pwd = req.body.pwd</span><br><span class="line">  <span class="comment">// 如果用户登录成功 则把用户的信息存储到session中</span></span><br><span class="line">  <span class="keyword">if</span> (name == <span class="string">'sessionName'</span> &amp;&amp; pwd == <span class="string">'123'</span>) &#123;</span><br><span class="line">    <span class="comment">// 存储会话数据</span></span><br><span class="line">    req.session.user = req.body</span><br><span class="line">    <span class="comment">// 跳转到用户中心页面</span></span><br><span class="line">    res.redirect(<span class="string">'/usercenter'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">'账号或者密码错误'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/usercenter'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从session中获取之前保存的数据</span></span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="built_in">console</span>.log(user)</span><br><span class="line">  <span class="keyword">if</span> (user &amp;&amp; user.name) &#123;</span><br><span class="line">    res.render(<span class="string">'usercenter.html'</span>, &#123;</span><br><span class="line">      name: user.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.render(<span class="string">'usercenter.html'</span>, &#123;</span><br><span class="line">      name: <span class="string">'default'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出的登录</span></span><br><span class="line">app.get(<span class="string">'/layout'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 清空session</span></span><br><span class="line">  req.session.destroy()</span><br><span class="line">  res.redirect(<span class="string">'/home'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/home'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="keyword">if</span> (user &amp;&amp; user.name) &#123;</span><br><span class="line">    res.render(<span class="string">"home.html"</span>, &#123; <span class="attr">name</span>: user.name &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    res.render(<span class="string">"home.html"</span>, &#123; <span class="attr">name</span>: <span class="string">"default"</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Cookie-和-Session&quot;&gt;&lt;a href=&quot;#1-Cookie-和-Session&quot; class=&quot;headerlink&quot; title=&quot;1.Cookie 和 Session&quot;&gt;&lt;/a&gt;1.Cookie 和 Session&lt;/h3&gt;&lt;p&gt;​     
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
