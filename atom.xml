<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wait1997</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-05T11:15:41.819Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaoxiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript—数组方法及数组去重</title>
    <link href="http://yoursite.com/2020/02/05/JavaScript%E2%80%94%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%8A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>http://yoursite.com/2020/02/05/JavaScript%E2%80%94%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%8A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
    <published>2020-02-05T10:25:49.344Z</published>
    <updated>2020-02-05T11:15:41.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数组的遍历方法"><a href="#1-数组的遍历方法" class="headerlink" title="1. 数组的遍历方法"></a>1. 数组的遍历方法</h3><ol><li><p><code>Array.forEach()</code></p><blockquote><p>遍历数组，和普通的for循环使用类似</p></blockquote></li><li><p><code>Array.entries()</code></p><blockquote><p>返回一个Array Iterator对象，该对象包含数组中每一个索引的键值对</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> eArr = arr.entries();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [2, "c"]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.every()</code></p><blockquote><p>every()是对数组中每一项运行给定函数，如果该函数对<strong>每一项</strong>返回true,则返回true</p></blockquote></li><li><p><code>Array.some()</code></p><blockquote><p>some()是对数组中每一项运行给定函数，如果该函数对<strong>任一项</strong>返回true,则返回true</p></blockquote></li><li><p><code>Array.filter</code></p><blockquote><p>filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组</p></blockquote></li><li><p><code>Array.map()</code></p><blockquote><p>遍历数组每一项，并且返回一个新数组</p></blockquote></li><li><p><code>Array.find()</code></p><blockquote><p>find()方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">//4</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.findIndex()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.reduce((prev,cur,index,array){},init)</code></p><blockquote><p>该方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值</p><p> <strong>array</strong> 表示原数组；<br> <strong>prev</strong> 表示上一次调用回调时的返回值，或者初始值 init;<br> <strong>cur</strong> 表示当前正在处理的数组元素；<br> <strong>index</strong> 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；<br> <strong>init</strong> 表示初始值</p></blockquote></li></ol><h3 id="2-数组去重的几种方法"><a href="#2-数组去重的几种方法" class="headerlink" title="2. 数组去重的几种方法"></a>2. 数组去重的几种方法</h3><ol><li><p>定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> repeat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArr.length; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i] === newArr[j]) &#123;</span><br><span class="line">            repeat = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!repeat) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> formArr = arr.sort();</span><br><span class="line">      <span class="keyword">var</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; formArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(formArr[i] !== formArr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">          newArr.push(formArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique2([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用对象属性存在的特性，如果没有该属性则存入新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> newArr = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">          obj[arr[i]] = <span class="number">1</span></span><br><span class="line">          newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// console.log(obj);</span></span><br><span class="line">      <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique3([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组的<code>indexOf</code>下标属性来查询。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique4</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newArr.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique4([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique5 = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(arr[i])) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique5([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的 filter 和 includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique6</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      newArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newArr.includes(item) ? <span class="string">''</span> : newArr.push(item)</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique6([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的 forEach 和 includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique7</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(item)) &#123;</span><br><span class="line">          newArr.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique7([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的reduce和include方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique8 = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> newArr = arr.reduce(<span class="function">(<span class="params">all, item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!all.includes(item)) &#123;</span><br><span class="line">          all.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all;</span><br><span class="line">      &#125;, [])</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(unique8([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>ES6 set方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique9</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique9([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">unique10</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique10([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-数组的遍历方法&quot;&gt;&lt;a href=&quot;#1-数组的遍历方法&quot; class=&quot;headerlink&quot; title=&quot;1. 数组的遍历方法&quot;&gt;&lt;/a&gt;1. 数组的遍历方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Array.forEach()&lt;/code&gt;&lt;/p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—开发技巧</title>
    <link href="http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</id>
    <published>2020-02-05T05:44:40.330Z</published>
    <updated>2020-02-05T05:44:40.330Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—性能优化1</title>
    <link href="http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%961/"/>
    <id>http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%961/</id>
    <published>2020-02-05T05:01:51.113Z</published>
    <updated>2020-02-05T07:17:50.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React性能优化1"><a href="#React性能优化1" class="headerlink" title="React性能优化1"></a>React性能优化1</h3><blockquote><h4 id="react凭借virtual-DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。"><a href="#react凭借virtual-DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。" class="headerlink" title="react凭借virtual DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。"></a>react凭借virtual DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。</h4></blockquote><h4 id="1-使用React-Memo-来缓存组件"><a href="#1-使用React-Memo-来缓存组件" class="headerlink" title="1. 使用React.Memo()来缓存组件"></a>1. 使用<code>React.Memo()</code>来缓存组件</h4><blockquote><p>父组件的每次状态更新，都会导致子组件重新渲染，即使传入子组件的状态没有变化，当类组件的输入属性相同时可以使用<code>pureComponent</code>或<code>shouldComponentUdate</code>来避免组件的渲染，函数组件中我们可以使用<code>React.memo</code>来缓存组件，这样只有当传入组件的状态值发生变化时才会重新渲染。如果传入相同的值，则返回缓存的组件。示例如下:</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(props) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;&#123;props.value&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="React-memo（浅比较）"><a href="#React-memo（浅比较）" class="headerlink" title="React.memo（浅比较）"></a><code>React.memo（浅比较）</code></h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> AreEqual <span class="keyword">from</span> <span class="string">'./component/AreEqual'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      val: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      val: <span class="keyword">this</span>.state.val</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;AreEqual &#123;...this.state&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果把nextProps传入render方法的返回结果与将</span></span><br><span class="line"><span class="comment">   * preProps传入render方法的返回结果一致则返回true</span></span><br><span class="line"><span class="comment">   * 否则返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (prevProps.val === nextProps.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AreEqual</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"渲染了"</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; val &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;val&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React.memo()两个参数 第一个是纯函数，第二个是比较函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(AreEqual, areEqual);</span><br></pre></td></tr></table></figure><h4 id="2-React-PureComponent"><a href="#2-React-PureComponent" class="headerlink" title="2. React.PureComponent"></a>2. <code>React.PureComponent</code></h4><blockquote><p>作用：</p><ol><li><code>React.PureComponent</code>和<code>React.Component</code>类似，都是定义一个组件类。</li><li>不同的是<code>React.Component</code>没有实现<code>shouldComponentUpdate()</code>，而<code>React.PureComponent</code>通过props和state的浅比较实现了。</li><li><code>React.PureComponent</code>是作用在类中，<code>React.memo</code>是作用在函数中</li></ol></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Children name=&#123;'这是React.pureComponent的使用方法'&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-使用useMemo缓存大量的计算"><a href="#3-使用useMemo缓存大量的计算" class="headerlink" title="3. 使用useMemo缓存大量的计算"></a>3. 使用<code>useMemo</code>缓存大量的计算</h4><blockquote><p>有时渲染是不可避免的，但如果您的组件是一个功能组件，重新渲染会导致每次都调用大型计算函数，这是非常消耗性能的，我们可以使用新的<code>useMemo</code>钩子来“记忆”这个计算函数的计算结果。这样只有传入的参数发生变化后，该计算函数才会重新调用计算新的结果。<br>通过这种方式，您可以使用从先前渲染计算的结果来挽救昂贵的计算耗时。总体目标是减少JavaScript在呈现组件期间必须执行的工作量，以便主线程被阻塞的时间更短。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免这样做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> someProp = heavyCalculation(props.item);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AnotherComponent</span> <span class="attr">someProp</span>=<span class="string">&#123;someProp&#125;</span> /&gt;</span> </span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">  </span></span><br><span class="line"><span class="xml">// 只有 `props.item` 改变时someProp的值才会被重新计算</span></span><br><span class="line"><span class="xml">function Component(props) &#123;</span></span><br><span class="line"><span class="xml">  const someProp = useMemo(() =&gt; heavyCalculation(props.item), [props.item]);</span></span><br><span class="line">  return &lt;AnotherComponent someProp=&#123;someProp&#125; /&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-使用React-PureComponent-shouldComponentUpdate"><a href="#4-使用React-PureComponent-shouldComponentUpdate" class="headerlink" title="4.使用React.PureComponent, shouldComponentUpdate"></a>4.使用<code>React.PureComponent</code>, <code>shouldComponentUpdate</code></h4><blockquote><p>父组件状态的每次更新，都会导致子组件的重新渲染，即使是传入相同props。但是这里的重新渲染不是说会更新DOM,而是每次都会调用diif算法来判断是否需要更新DOM。这对于大型组件例如组件树来说是非常消耗性能的。<br>在这里我们就可以使用<code>React.PureComponent</code> ,<code>shouldComponentUpdate</code>生命周期来确保只有当组件props状态改变时才会重新渲染。如下例子:</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ParentComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SomeComponent someProp=&#123;props.somePropValue&#125; /&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;AnotherComponent someOtherProp=&#123;props.someOtherPropValue&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>div&gt;</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">SomeComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;props.someProp&#125;&lt;<span class="regexp">/div&gt;  </span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 只要props.somePropValue 发生变化，不论props.someOtherPropValue是否发生变化该组件都会发生变化</span></span><br><span class="line"><span class="regexp">export default function AnotherComponent(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&#123;props.someOtherProp&#125;&lt;/</span>div&gt;  </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>React.PureComponent</code>、<code>shouldComponentUpdate</code>性能优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.someOtherProp&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props !== nextProps</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.someOtherProp&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>PureComponent</code>会进行浅比较来判断组件是否应该重新渲染，对于传入的基本类型props，只要值相同，浅比较就会认为相同，对于传入的引用类型props，浅比较只会认为传入的props是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是不同的props。<br>需要注意的是在对于那些可以忽略渲染时间的组件或者是状态一直变化的组件则要谨慎使用<code>PureComponent</code>，因为进行浅比较也会花费时间，这种优化更适用于大型的展示组件上。大型组件也可以拆分成多个小组件，并使用memo来包裹小组件，也可以提升性能。</p></blockquote><h5 id="补充：PureComponent浅比较部分核心源码"><a href="#补充：PureComponent浅比较部分核心源码" class="headerlink" title="补充：PureComponent浅比较部分核心源码"></a>补充：<code>PureComponent</code>浅比较部分核心源码</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span> (<span class="params">objA: mixed, objB: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的 is 相当于 === 的功能，只是对 + 0 和 - 0，以及 NaN 和 NaN 的情况进行了特殊处理</span></span><br><span class="line">  <span class="comment">// 第一关：基础数据类型直接比较出结果</span></span><br><span class="line">  <span class="keyword">if</span> (is (objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二关：只要有一个不是对象数据类型就返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">'object'</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三关：在这里已经可以保证两个都是对象数据类型，比较两者的属性数量</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys (objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys (objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第四关：比较两者的属性是否相等，值是否相等</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.call (objB, keysA [i]) ||</span><br><span class="line">      !is (objA [keysA [i]], objB [keysA [i]])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意：比较终究是浅比较，当出现嵌套情况就会失灵"><a href="#注意：比较终究是浅比较，当出现嵌套情况就会失灵" class="headerlink" title="注意：比较终究是浅比较，当出现嵌套情况就会失灵"></a>注意：比较终究是浅比较，当出现嵌套情况就会失灵</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state: &#123;<span class="attr">a</span> : [<span class="string">"1"</span>]&#125; -&gt; state: &#123;<span class="attr">a</span>: [<span class="string">"1"</span>, <span class="string">"2"</span>]&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式最大的弊端是由于 <code>JS</code> 引用赋值的原因，这种方式仅仅适用于无状态组件或者状态数据非常简单的组件，对于大量的应用组件无能为力</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React性能优化1&quot;&gt;&lt;a href=&quot;#React性能优化1&quot; class=&quot;headerlink&quot; title=&quot;React性能优化1&quot;&gt;&lt;/a&gt;React性能优化1&lt;/h3&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;react凭借virtual-DOM和d
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React与Vue比较2</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%832/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%832/</id>
    <published>2020-02-04T08:57:36.458Z</published>
    <updated>2020-02-05T04:56:17.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React与Vue的对比中"><a href="#React与Vue的对比中" class="headerlink" title="React与Vue的对比中"></a>React与Vue的对比中</h2><h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1.核心思想"></a>1.核心思想</h4><blockquote><h5 id="vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。"><a href="#vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。" class="headerlink" title="vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。"></a>vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。</h5></blockquote><ol><li><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><h5 id="vue的整体思想仍然式拥抱html-结构-css-表现-js-行为-的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用-v-if、v-show、v-for等指令-，在组件数据上，vue2-0通过Object-defineProperty对数据做到了更细致的监听，精准实现组件级别的更新"><a href="#vue的整体思想仍然式拥抱html-结构-css-表现-js-行为-的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用-v-if、v-show、v-for等指令-，在组件数据上，vue2-0通过Object-defineProperty对数据做到了更细致的监听，精准实现组件级别的更新" class="headerlink" title="vue的整体思想仍然式拥抱html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等指令)，在组件数据上，vue2.0通过Object.defineProperty对数据做到了更细致的监听，精准实现组件级别的更新"></a>vue的整体思想仍然式拥抱html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等指令)，在组件数据上，vue2.0通过<code>Object.defineProperty</code>对数据做到了更细致的监听，精准实现组件级别的更新</h5></li><li><h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><h5 id="react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染"><a href="#react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染" class="headerlink" title="react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染"></a>react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过<code>shouldComponentUpdate</code>或者<code>PureComponent</code>避免不必要的重新渲染</h5></li></ol><h4 id="2-组件形式"><a href="#2-组件形式" class="headerlink" title="2. 组件形式"></a>2. 组件形式</h4><blockquote><p>vue组件定义使用xx.vue文件来表示，vue组件将html、css、js组合到一起，模板部分使用<code>双括号</code>渲染数据，形式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模板(html)</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据管理(js)</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;NewComponent&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;xx&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 样式(css)</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>react推荐使用jsx或者js文件来表示组件，react支持class组件和function组件两种形式，react使用<code>{}</code>包裹变量</p></blockquote><ol><li><h5 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'xx'</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.state.name&#125;    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li><li><p>函数组件</p><p>hooks的出现赋予了function组件管理state的能力</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;name&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-数据管理（props、data、state）"><a href="#3-数据管理（props、data、state）" class="headerlink" title="3.数据管理（props、data、state）"></a>3.数据管理（props、data、state）</h4><blockquote><p>组件数据来自父组件的数据props与自身的数据</p><p>vue与react中的props都是单向数据流的，父级props的更新会向下流动到子组件中，props用来接收父组件的数据</p></blockquote><h5 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h5><ol><li><h6 id="props"><a href="#props" class="headerlink" title="props"></a>props</h6><blockquote><p>vue中的props支持传递静态、动态props</p></blockquote><h5 id="静态："><a href="#静态：" class="headerlink" title="静态："></a>静态：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">new</span>-component title=<span class="string">"study vue"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">new-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="动态："><a href="#动态：" class="headerlink" title="动态："></a>动态：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">new</span>-component :title=<span class="string">"title"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">new-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><h6 id="data"><a href="#data" class="headerlink" title="data"></a>data</h6><blockquote><p>vue中使用data来管理组件的数据，vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)。一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p></blockquote><p>注意：当一个组件被定义，data必须声明为返回一个初始数据对象的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'NewComponent'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'xxx'</span>,</span><br><span class="line">      age: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要在组件内部修改数据时，可以直接通过vue实例修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'new Name'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="react-1"><a href="#react-1" class="headerlink" title="react"></a>react</h5><ol><li><h6 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h6><blockquote><p>react中的props也与vue一样可以传递静态或动态props，静态props一般传递字符串。</p><p>函数组件和class组件都可以使用props，函数组件使用props参数获取父组件传下来的props。</p><p>函数组件获取props：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;</span><br></pre></td></tr></table></figure><p>class组件使用<code>this.props</code>获取组件<code>props</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name &#125; &#x3D; this.props;</span><br><span class="line">    return &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>动态props：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Welcome name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h6 id="state"><a href="#state" class="headerlink" title="state"></a>state</h6><blockquote><p>react中使用state来管理组件内的数据，hooks的出现使得函数组件也具备管理state的能力</p></blockquote><h5 id="class组件state"><a href="#class组件state" class="headerlink" title="class组件state"></a>class组件state</h5><p>class组件在构造函数（constructor）中定义组件内数据（state），修改数据必须通过setState修改，不能直接修改state，这点非常重要。</p><p>class组件使用state：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'xx'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.changeName = <span class="keyword">this</span>.changeName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="string">'new name'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">this</span>.state.name &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于class组建的setState有以下两点说明：</p><ul><li>1.setState更新是异步的，但是<strong>在setTimeout和原生事件中是同步的</strong>。</li><li>2.setState更新的是组件的部分数据，react会自动将数据合并。</li></ul><p>当需要使用上一个state值时，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h5 id="函数组件useState"><a href="#函数组件useState" class="headerlink" title="函数组件useState"></a>函数组件useState</h5><p>react 16.8之前函数组件只是纯的渲染组件，hooks的出现赋予了函数组件管理state的能力。</p><p>useState返回一个state，以及更新state的函数。如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于setState有以下三点说明：</p><ul><li>1.与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。</li><li>2.只能在函数最顶层调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>3.只能在 React 的函数组件或自定义hook中调用 Hook。不要在其他 JavaScript 函数中调用。</li></ul></blockquote></li></ol><h4 id="4-组件数据交互"><a href="#4-组件数据交互" class="headerlink" title="4.组件数据交互"></a>4.组件数据交互</h4><blockquote><p>组件数据交互是指父子组件、兄弟组件、跨层组件之间传递数据。 兄弟组件之间可以通过事件总线或者通过父组件传递数据</p></blockquote><h5 id="4-1-父子组件数据交互-props-自定义事件-vs-props-回调"><a href="#4-1-父子组件数据交互-props-自定义事件-vs-props-回调" class="headerlink" title="4.1 父子组件数据交互(props+自定义事件 vs props+回调)"></a>4.1 父子组件数据交互(props+自定义事件 vs props+回调)</h5><p>对于父子组件数据交互，vue中使用prop+自定义事件实现，react通过props+回调</p><h5 id="vue-2"><a href="#vue-2" class="headerlink" title="vue"></a>vue</h5><p>vue中父组件通过props传递数据给子组件，子组件使用<code>$emit</code>触发自定义事件，父组件中监听子组件的自定义事件获取子组件传递来的数据。</p><p>子组件使用<code>$emit</code>传递自定义事件<code>myEvent</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;changeName&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;NewComponent&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;xxx&#39;,</span><br><span class="line">      age: 12</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeName() &#123;</span><br><span class="line">      this.name &#x3D; &#39;new Name&#39;;</span><br><span class="line">      this.$emit(&#39;myEvent&#39;, this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>父组件使用<code>@myEvent</code>监听自定义事件，回调函数参数是子组件传回的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;new-component @myEvent&#x3D;&quot;getName&quot;&gt;&lt;&#x2F;new-component&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import NewComponent from &#39;.&#x2F;NewComponent&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    NewComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getName(name) &#123;</span><br><span class="line">      console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="react-2"><a href="#react-2" class="headerlink" title="react"></a>react</h4><p>react中父组件使用props传递数据和回调函数给子组件，子组件通过props传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据。</p><p>子组件通过props接收父组件传下来的回调事件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; myEvent &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setName(<span class="string">'new name'</span>);</span><br><span class="line">    myEvent(<span class="string">'new name'</span>);<span class="comment">//回调</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件通过回调事件获取子组件传递的参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">myEvent</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2跨组件数据交互-provide-inject-vs-Context"><a href="#4-2跨组件数据交互-provide-inject-vs-Context" class="headerlink" title="4.2跨组件数据交互(provide/inject vs Context)"></a>4.2跨组件数据交互(provide/inject vs Context)</h5><blockquote><p>vue和react都支持跨组件传递数据，vue中主要通过<code>provide / inject</code>实现，react中主要通过<code>Context</code>实现。</p></blockquote><h5 id="vue-3"><a href="#vue-3" class="headerlink" title="vue"></a>vue</h5><p>vue中通过<code>provide / inject</code>在祖先组件向所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p><p>祖先组件中定义provide选项，provide选项应该是一个对象或返回一个对象的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;new-component @myEvent&#x3D;&quot;getName&quot;&gt;&lt;&#x2F;new-component&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import NewComponent from &#39;.&#x2F;NewComponent&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123; &#x2F;&#x2F; 定义provide选项</span><br><span class="line">    message: &#39;This is a big news&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    NewComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getName(name) &#123;</span><br><span class="line">      console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件通过inject选项获取祖先组件的provide选项值，inject选项应该是一个字符串数组或者对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Children&#39;,</span><br><span class="line">  inject: [&#39;message&#39;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote><h5 id="react-3"><a href="#react-3" class="headerlink" title="react"></a>react</h5><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><p>在父组件创建一个Context对象，通过<code>Context.provider</code>的value属性向消费组件传值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Context对象</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext(&#123; <span class="attr">theme</span>: <span class="string">'black'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Context.provider向消费组件传值</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">theme:</span> '<span class="attr">white</span>' &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Children</span> <span class="attr">myEvent</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费组件获取Context有2种方式：</p><p>（1）class组件通过contextType获取最近Context上的那个值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepChildren1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextType = MyContext;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.theme&#125;123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）函数式组件通过<code>Context.Consumer</code>订阅到Context的变更。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepChildren</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;</span></span><br><span class="line"><span class="xml">      (value) =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value.theme&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">MyContext.Consumer</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Context需要注意：</p><blockquote><p>当Provider的父组件进行重渲染时，consumers组件会重新渲染，并且没有办法避免，应该尽量避免使用Context。</p></blockquote><h4 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h4><blockquote><p>组件的生命周期一般包括：初始化、挂载、更新、卸载四大阶段，接下来分别看下vue和react的生命周期</p></blockquote><h5 id="vue-4"><a href="#vue-4" class="headerlink" title="vue"></a>vue</h5><p>vue生命周期图示:</p><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Cvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue生命周期"></p><p>vue生命周期包含:</p><ul><li>beforeCreate<br> 实例组件刚创建，元素DOM和数据都还没有初始化，暂时不能在这个周期里面进行任何操作。</li><li>created<br> 数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。调用后台接口获取数据可以在这个阶段完成。</li><li>beforeMount<br> DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示<code>双括号</code>，虚拟DOM结构已经生成。</li><li>mounted<br> 数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。这个周期适合执行初始化需要操作DOM的方法。</li><li>beforeUpdate<br> 页面数据改变了都会触发，在更新前触发，此时的数据还是未更新前的数据，没有数据改变则不执行。</li><li>updated<br> 页面数据改变都会触发，在更新完成之后触发，此时的数据是更新后的数据。</li></ul><blockquote><p>注意：在这里操作数据很容易引起卡死。</p></blockquote><ul><li>beforeDestroy<br> 组件销毁之前执行，在这个周期里仍然可以访问data和method，多组件间通信需要发布信息时可以在该阶段完成。</li><li>destroyed<br> 当离开组件对应页面时组件销毁时触发，主要用于取消一些副作用（取消事件监听、取消定时器、取消不必要的请求等）</li></ul><h5 id="react-4"><a href="#react-4" class="headerlink" title="react"></a>react</h5><h5 id="16-3以前的生命周期"><a href="#16-3以前的生命周期" class="headerlink" title="16.3以前的生命周期"></a>16.3以前的生命周期</h5><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Creact%E8%80%81%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react老版生命周期"></p><p>（1）初始化</p><ul><li>constructor<br> 是class组件的默认方法，常用来初始化state或者设置属性等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props); <span class="comment">// 声明constructor时必须调用super方法</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          count: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）挂载阶段</p><ul><li>componentWillMount()<br>组件挂载之前调用，并且只会调用一次。</li><li>render<br>render是一个React组件必须定义的生命周期函数，用来渲染DOM。 并必须 return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。</li></ul><blockquote><p>不要在render里面修改state,会引起死循环导致卡死。</p></blockquote><ul><li>componentDidMount()<br>组件挂在完成之后调用，在这个阶段可以获取真实dom元素，常用来发起异步请求获取数据。</li></ul><p>（3）更新阶段</p><p>当通过setState修改state或父组件重新render引起props更新，都会引起子组件的重新render。</p><ul><li>componentWillReceiveProps(nextProps)<br>props发生变化以及父组件重新渲染时都会触发该生命周期函数。在该阶段可以通过参数nextProps获取变化后的props参数， 通过this.props访问之前的props。该生命周期内可以进行setState。</li><li>shouldComponentUpdate(nextProps,nextState)<br>组件每次setState或者父组件重新render都会引起子组件render，可以使用该钩子比较nextProps，nextState及当前组件的this.props，this.state的状态用来判断是否需要重新渲染。默认返回true，需要重新render，返回false则不触发渲染。</li></ul><blockquote><p>一般我们通过该钩子来优化性能，避免子组件不必要的渲染。</p></blockquote><ul><li>componentWillUpdate(nextProps, nextState)<br>当组件收到新的 props 或 state 时，会在渲染之前调用。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</li></ul><blockquote><p>注意：不能在此方法中调用<code>this.setState</code></p></blockquote><ul><li>componentDidUpdate(prevProps, prevState) 此方法在组件更新后被调用。首次渲染不会执行此方法。当组件更新后，可以在此处对DOM进行操作。</li></ul><blockquote><p>注意：可以在<code>componentDidUpdate()</code>中直接调用<code>setState()</code>，但是它必需被包裹在一个条件语句里，否则会导致死循环。</p></blockquote><p>（4）卸载阶段</p><ul><li>componentWillUnmount()<br>会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在<code>componentDidMount()</code> 中创建的订阅等。</li></ul><blockquote><p>注意：componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。</p></blockquote><h5 id="16-4之后"><a href="#16-4之后" class="headerlink" title="16.4之后"></a>16.4之后</h5><p>react 16.0之后移除的生命周期函数：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul><p>但是为了向下兼容，react并未删除这三个生命周期，新增以 <code>UNSAFE_</code> 前缀为别名的三个函数 <code>UNSAFE_componentWillMount()</code>、<code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code>。</p><p>新增的生命周期函数：</p><ul><li>static getDerivedStateFromProps(nextProps, prevState)</li><li>getSnapshotBeforeUpdate(prevProps, prevState)</li></ul><p>生命周期如下：</p><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Creact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react生命周期"></p><blockquote><p>总结：<br>初始化阶段保持不变 </p><p>挂载阶段: getDerivedStateFromProps =&gt; render =&gt; componentDidMount </p><p>更新阶段: getDerivedStateFromProps =&gt; shoudeComponentUpdate =&gt; render =&gt; getSnapshotBeforeUpdate  =&gt; componentDidUpdate </p><p>卸载阶段保持不变</p></blockquote><h5 id="getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。"><a href="#getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。" class="headerlink" title="getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。"></a>getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。</h5><p>（1）static getDerivedStateFromProps(props, state)</p><p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p><blockquote><p>当state的值在任何时候都取决于props的时候适用该方法。</p></blockquote><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.type !== prevState.type) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            type: nextProps.type,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>（2）getSnapshotBeforeUpdate(prevProps, prevState)</p><p>getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。应返回 snapshot 的值（或 null）。</p><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// 我们是否在 list 中添加新的 items ？</span></span><br><span class="line">    <span class="comment">// 捕获滚动位置以便我们稍后调整滚动位置。</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span></span><br><span class="line">    <span class="comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span></span><br><span class="line">    <span class="comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React与Vue的对比中&quot;&gt;&lt;a href=&quot;#React与Vue的对比中&quot; class=&quot;headerlink&quot; title=&quot;React与Vue的对比中&quot;&gt;&lt;/a&gt;React与Vue的对比中&lt;/h2&gt;&lt;h4 id=&quot;1-核心思想&quot;&gt;&lt;a href=&quot;#1-核
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—setState</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94setState/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94setState/</id>
    <published>2020-02-04T07:11:17.734Z</published>
    <updated>2020-02-04T08:36:34.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React中的state"><a href="#React中的state" class="headerlink" title="React中的state"></a>React中的state</h3><h4 id="1-不能直接修改-state"><a href="#1-不能直接修改-state" class="headerlink" title="1. 不能直接修改 state"></a>1. 不能直接修改 <code>state</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-state中数据的修改"><a href="#2-state中数据的修改" class="headerlink" title="2.state中数据的修改"></a>2.<code>state</code>中数据的修改</h4><ul><li>通过<code>setState</code>修改<code>state</code>中的数据</li></ul><blockquote><h6 id="setState中的关键点"><a href="#setState中的关键点" class="headerlink" title="setState中的关键点"></a><code>setState</code>中的关键点</h6></blockquote><ol><li><p><code>setState</code>不会立刻改变<code>React</code>组件中<code>state</code>的值 </p></li><li><p><code>setState</code>通过引发一次组件的更新过程来引发重新绘制</p><p>重绘指的就是引起<code>React</code>的更新生命周期函数4个函数：</p><ul><li><code>shouldComponentUpdate</code>（被调用时<code>this.state</code>没有更新；如果返回了<code>false</code>，生命周期被中断，虽然不调用之后的函数了，但是<code>state</code>仍然会被更新）</li><li><code>componentWillUpdate</code>（被调用时<code>this.state</code>没有更新）</li><li><code>render</code>（被调用时<code>this.state</code>得到更新）</li><li><code>componentDidUpdate</code></li></ul></li><li><p>多次<code>setState</code>函数调用产生的效果会合并。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'Pororo'</span>&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">age</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'Pororo'</span>，age: <span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面两块代码的效果是一样的。<strong>如果每次调用都引发一次生命周期更新，那性能就会消耗很大了。</strong>所以，<code>React</code>会将多个<code>this.setState</code>产生的修改<strong>放进一个队列里，</strong>等差不多的时候就会引发一次生命周期更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Eg</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">      index: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// react生命周期</span></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第一次输出</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第二次输出</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第三次输出</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第四次输出</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">     <span class="comment">// 通过 addEventListener 监听的会同步执行setState()</span></span><br><span class="line">    <span class="keyword">this</span>.refs.button.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index) <span class="comment">// 同步时输出 1 异步时（通过react事件机制定义的事件处理函数）输出 0</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index) <span class="comment">// 同步时输出 2 异步时（通过react事件机制定义的事件处理函数）输出 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>value: &#123;this.state.value&#125; index: &#123;this.state.index&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        &lt;button ref=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><h5 id="前两次setState："><a href="#前两次setState：" class="headerlink" title="前两次setState："></a>前两次<code>setState</code>：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步</span></span><br><span class="line"> <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">// 第一次输出0</span></span><br><span class="line">         <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">// 第二次输出0</span></span><br></pre></td></tr></table></figure><p>由于<code>setState</code>不会立即改变React组件中<code>state</code>的值，所以两次<code>setState</code>中<code>this.state.value</code>都是同一个值0，故而，这两次输出都是0。因而value只被加1。</p><p>既然这样，那么是不是可以直接操作<code>this.state</code>呢？比如：<code>this.state.value=this.state.value+1;</code>这样的确可以修改<code>this.state.value</code>的状态但是却不可以引发重复渲染。所以，就必须通过React设定的<code>setState</code>函数去改变<code>this.state</code>，从而引发重新渲染。</p><h5 id="setTimeout里面的两次setState"><a href="#setTimeout里面的两次setState" class="headerlink" title="setTimeout里面的两次setState:"></a><code>setTimeout</code>里面的两次<code>setState</code>:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第三次输出2</span></span><br><span class="line">           <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第四次输出3</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在<code>React</code>中，<strong>如果是由React引发的事件处理（比如：<code>onClick</code>引发的事件处理），调用<code>setState</code>不会同步更新<code>this.state</code>，除此之外的<code>setState</code>调用会同步执行t<code>his.setState</code>。</strong> “除此之外”指的是：绕过React通过<code>addEventListener</code>直接添加的事件处理函数和<code>setTimeout/setInterval</code>产生的异步调用。</p><p><img src="..%5Cimage%5CsetState%5CsetState.png" alt="setState"></p><blockquote><p>每次setState产生新的state会依次被存入一个队列，然后会根据<strong>isBathingUpdates</strong>变量判断是直接更新this.state还是放进dirtyComponent里回头再说。isBatchingUpdates默认是false，也就表示setState会同步更新this.state。但是，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，造成的后果就是由React控制的事件处理过程setState不会同步更新this.state。</p></blockquote></li></ol><h4 id="3-同步更新state的办法—函数式setState"><a href="#3-同步更新state的办法—函数式setState" class="headerlink" title="3.同步更新state的办法—函数式setState"></a>3.同步更新state的办法—函数式setState</h4><p>如果this.setState的参数不是一个对象而是一个函数时，这个函数会接收到两个参数，第一个是当前的state值，第二个是当前的props，这个函数应该返回一个对象，这个对象代表想要对this.state的更改，换句话说，之前你想给this.setState传递什么对象参数，在这种函数里就返回什么对象。不过，计算这个对象的方法有些改变，不再依赖于this.state，而是依赖于输入参数state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementMultiple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如当前this.state.count的值是0，第一次调用this.setState(increment)，传给increment的state参数是0，第二次调用时，state参数是1，第三次调用时参数是2，最终incrementMultiple让this.state.count变成了3。</p><p>对于多次调用函数式setState的情况，React会保证调用每次increment时，state都已经合并了之前的状态修改结果。</p><h4 id="4-把两种setState的用法混用"><a href="#4-把两种setState的用法混用" class="headerlink" title="4.把两种setState的用法混用"></a>4.把两种setState的用法混用</h4><h5 id="把incrementMultiple改成这样"><a href="#把incrementMultiple改成这样" class="headerlink" title="把incrementMultiple改成这样"></a>把incrementMultiple改成这样</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementMultiple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在几个函数式setState调用中插入一个传统式setState调用，最后得到的结果是让this.state.count增加了2，而不是增加4。</p><p>这是因为React会依次合并所有setState产生的效果，虽然前两个函数式setState调用产生的效果是count加2，但是中间出现一个传统式setState调用，一下子强行把积攒的效果清空，用count加1取代。</p><p>所以，传统式setState与函数式setState一定不要混用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React中的state&quot;&gt;&lt;a href=&quot;#React中的state&quot; class=&quot;headerlink&quot; title=&quot;React中的state&quot;&gt;&lt;/a&gt;React中的state&lt;/h3&gt;&lt;h4 id=&quot;1-不能直接修改-state&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React与Vue比较1</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%831/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%831/</id>
    <published>2020-02-04T06:58:44.103Z</published>
    <updated>2020-02-04T07:05:31.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React与Vue的对比上"><a href="#React与Vue的对比上" class="headerlink" title="React与Vue的对比上"></a>React与Vue的对比上</h2><h5 id="1、监听数据变化的实现原理不同"><a href="#1、监听数据变化的实现原理不同" class="headerlink" title="1、监听数据变化的实现原理不同"></a><strong>1、监听数据变化的实现原理不同</strong></h5><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用地址的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染</li></ul><p>为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。所以应该说没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。</p><p>因为一般都会用一个数据层的框架比如 Vuex 和 Redux，所以这部分不作过多解释，在最后的 vuex 和 redux的区别 中也会讲到。</p><h5 id="2、数据流的不同"><a href="#2、数据流的不同" class="headerlink" title="2、数据流的不同"></a><strong>2、数据流的不同</strong></h5><p>大家都知道Vue中默认是支持双向绑定的。在Vue1.0中我们可以实现两种双向绑定：</p><ol><li>父子组件之间，props 可以双向绑定</li><li>组件与DOM之间可以通过 v-model 双向绑定</li></ol><p>在 Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且 Vue2.x 已经不鼓励组件对自己的 props 进行任何修改了。所以现在我们只有 组件 &lt;––&gt; DOM 之间的双向绑定这一种。</p><p>然而 React 从诞生之初就不支持双向绑定，React一直提倡的是单向数据流，他称之为 onChange/setState()模式。</p><p>不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。</p><h5 id="3、模板渲染方式的不同"><a href="#3、模板渲染方式的不同" class="headerlink" title="3、模板渲染方式的不同"></a><strong>3、模板渲染方式的不同</strong></h5><p>在表层上， 模板的语法不同</p><ul><li>React 是通过JSX渲染模板</li><li>而Vue是通过一种拓展的HTML语法进行渲染</li></ul><p>但其实这只是表面现象，毕竟React并不必须依赖JSX。</p><p>在深层上，模板的原理不同，这才是他们的本质区别：</p><ul><li>React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的</li><li>Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现</li></ul><h5 id="4、Vuex-和-Redux-的区别"><a href="#4、Vuex-和-Redux-的区别" class="headerlink" title="4、Vuex 和 Redux 的区别"></a><strong>4、Vuex 和 Redux 的区别</strong></h5><p>从表面上来说，store 注入和使用方式有一些区别。</p><p>在 Vuex 中，$store 被直接注入到了组件实例中，因此可以比较灵活的使用：</p><ul><li>使用 dispatch 和 commit 提交更新</li><li>通过 mapState 或者直接通过 this.$store 来读取数据</li></ul><p>在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。</p><p>另外 Vuex 更加灵活一些，组件中既可以 dispatch action 也可以 commit updates，而 Redux 中只能进行 dispatch，并不能直接调用 reducer 进行修改。</p><p>从实现原理上来说，最大的区别是两点：</p><ul><li>Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改</li><li>Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React与Vue的对比上&quot;&gt;&lt;a href=&quot;#React与Vue的对比上&quot; class=&quot;headerlink&quot; title=&quot;React与Vue的对比上&quot;&gt;&lt;/a&gt;React与Vue的对比上&lt;/h2&gt;&lt;h5 id=&quot;1、监听数据变化的实现原理不同&quot;&gt;&lt;a h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—Create-React-App</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94Create-React-App/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94Create-React-App/</id>
    <published>2020-02-04T06:37:18.660Z</published>
    <updated>2020-02-04T06:43:01.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-create-react-app-创建及使用"><a href="#1-create-react-app-创建及使用" class="headerlink" title="1. create-react-app 创建及使用"></a>1. <code>create-react-app</code> 创建及使用</h2><blockquote><h5 id="Create-React-App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用"><a href="#Create-React-App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用" class="headerlink" title="Create React App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用"></a><code>Create React App</code>是<strong>FaceBook</strong>的React团队官方出的一个构建<code>React</code>单页面应用的脚手架工具。它本身集成了<code>Webpack</code>，并配置了一系列内置的<code>loader</code>和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用</h5></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全局安装</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建一个my-app的项目(my-app 是你的项目的名称)</span></span><br><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动编译当前的React项目，并自动打开 http://localhost:3000/</span></span><br><span class="line">npm start</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">yard start</span><br></pre></td></tr></table></figure><h5 id="注意：如果你不能确保最新版本，可以尝试卸载：npm-uninstall-g-create-react-app然后全局安装"><a href="#注意：如果你不能确保最新版本，可以尝试卸载：npm-uninstall-g-create-react-app然后全局安装" class="headerlink" title="注意：如果你不能确保最新版本，可以尝试卸载：npm uninstall -g create-react-app然后全局安装"></a>注意：如果你不能确保最新版本，可以尝试卸载：<code>npm uninstall -g create-react-app</code>然后全局安装</h5><h4 id="1-1-项目目录（默认）："><a href="#1-1-项目目录（默认）：" class="headerlink" title="1.1 项目目录（默认）："></a>1.1 项目目录（默认）：</h4><p><img src="../image%5Ccreate-react-app%5Creact%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%AE%E5%BD%95.png" alt="react初始化目录"></p><h5 id="对于要创建的项目，这些文件必须以明确的文件名存在："><a href="#对于要创建的项目，这些文件必须以明确的文件名存在：" class="headerlink" title="对于要创建的项目，这些文件必须以明确的文件名存在："></a>对于要创建的项目，这些文件必须以明确的文件名存在：</h5><ul><li><code>public/index.html</code> 是页面模板;</li><li><code>src/index.js</code> 是 JavaScript 入口点。</li><li>在 <code>src</code> 中创建子目录。 为了加快重新构建的速度，<code>Webpack</code>只处理 <code>src</code> 中的文件。 你需要<strong>将任何 JS 和 CSS 文件放在 <code>src</code> 中</strong>，否则 <code>Webpack</code>将发现不了它们 </li></ul><blockquote><h5 id="在package-json中：-只有三个依赖，分别是react，react-dom-react-scripts-依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令-都是通过调用react-scripts这个依赖下面的命令进行启动的-creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来，-如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件"><a href="#在package-json中：-只有三个依赖，分别是react，react-dom-react-scripts-依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令-都是通过调用react-scripts这个依赖下面的命令进行启动的-creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来，-如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件" class="headerlink" title="在package.json中： 只有三个依赖，分别是react，react-dom,react-scripts,依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令 都是通过调用react-scripts这个依赖下面的命令进行启动的, creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来， 如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件"></a>在<code>package.json</code>中： 只有三个依赖，分别是<code>react，react-dom,react-scripts</code>,依赖为什么这么少，是因为像<code>webpack，babel</code>等等都是被<code>creat-react-app</code>封装到了react-scripts这个项目当中，包括基本启动命令 都是通过调用<code>react-scripts</code>这个依赖下面的命令进行启动的, <code>creat-react-app</code>搭建出来的项目默认支持这4种命令，<code>start</code>以开发模式启动项目，<code>build</code>将整个项目进行构建，<code>test</code>进行测试，<code>eject</code>会将原本<code>creat-react-app</code>对webpack，babel等相关配置的封装弹射出来， 如果我们要将<code>creat-react-app</code>配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过<code>eject</code>命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件</h5></blockquote><h5 id="1-1-1-可用的Scripts"><a href="#1-1-1-可用的Scripts" class="headerlink" title="1.1.1 可用的Scripts"></a>1.1.1 可用的Scripts</h5><ul><li><p><code>npm start</code></p><p>在开发模式下运行应用程序 </p></li><li><p><code>npm test</code></p><p>以交互式监视模式启动测试运行器 </p></li><li><p><code>npm run build</code></p><p>将生产应用程序构建到 <code>build</code> 文件夹 </p></li><li><p><code>npm run eject</code></p></li></ul><h4 id="1-2在create-react-app中使用css-module两种方式"><a href="#1-2在create-react-app中使用css-module两种方式" class="headerlink" title="1.2在create-react-app中使用css module两种方式"></a>1.2在<code>create-react-app</code>中使用<code>css module</code>两种方式</h4><h5 id="1-2-1-使用-css-module-的第一种方式"><a href="#1-2-1-使用-css-module-的第一种方式" class="headerlink" title="1.2.1 使用 css module 的第一种方式"></a>1.2.1 使用 <code>css module</code> 的第一种方式</h5><blockquote><h6 id="create-react-app-中内置了使用-CSS-Modules-的配置，当前方式就是使用-create-react-app内置的用法"><a href="#create-react-app-中内置了使用-CSS-Modules-的配置，当前方式就是使用-create-react-app内置的用法" class="headerlink" title="create-react-app 中内置了使用 CSS Modules 的配置，当前方式就是使用 create-react-app内置的用法"></a><code>create-react-app</code> 中内置了使用 <code>CSS Modules</code> 的配置，当前方式就是使用 <code>create-react-app</code>内置的用法</h6></blockquote><h5 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h5><blockquote><h6 id="将所有的-css-scss等样式文件都修改成-module-css-module-scss-等。即可使用-CSS-Modules的方式进行引入使用了"><a href="#将所有的-css-scss等样式文件都修改成-module-css-module-scss-等。即可使用-CSS-Modules的方式进行引入使用了" class="headerlink" title="将所有的 .css/.scss等样式文件都修改成 .module.css/.module.scss 等。即可使用 CSS Modules的方式进行引入使用了"></a>将所有的 <code>.css/.scss</code>等样式文件都修改成 <code>.module.css/.module.scss</code> 等。即可使用 <code>CSS Modules</code>的方式进行引入使用了</h6></blockquote><h5 id="用法：编写一个css文件：union-module-css"><a href="#用法：编写一个css文件：union-module-css" class="headerlink" title="用法：编写一个css文件：union.module.css"></a>用法：编写一个css文件：<code>union.module.css</code></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在编写一个普通的-css-文件：common-css"><a href="#在编写一个普通的-css-文件：common-css" class="headerlink" title="在编写一个普通的 css 文件：common.css"></a>在编写一个普通的 css 文件：<code>common.css</code></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在App-jsx-文件中使用-CSS-Modules的方式进行引用：union-module-css"><a href="#在App-jsx-文件中使用-CSS-Modules的方式进行引用：union-module-css" class="headerlink" title="在App. jsx 文件中使用 CSS Modules的方式进行引用：union.module.css"></a>在<code>App. jsx</code> 文件中使用 <code>CSS Modules</code>的方式进行引用：<code>union.module.css</code></h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> union <span class="keyword">from</span> <span class="string">'./css/union.module.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./css/common.css'</span></span><br><span class="line"><span class="built_in">console</span>.log(union)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p className=&#123;union.error&#125;&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="在浏览器中查看效果"><a href="#在浏览器中查看效果" class="headerlink" title="在浏览器中查看效果:"></a>在浏览器中查看效果:</h4><blockquote><p>此时 App组件的背景颜色是红色，但是字体颜色却不是红色，因为使用了 <code>Css Modules</code> 之后，普通的 css 样式就不起效果了，需要用全局的方式编写才可以(:global)。 最后添加到元素上的样式结果为：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"union_error_3UaRT"</span>&gt;</span>悲催的一天开始了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用scss的效果和css效果一样-但是使用scsss时需要安装："><a href="#使用scss的效果和css效果一样-但是使用scsss时需要安装：" class="headerlink" title="使用scss的效果和css效果一样,但是使用scsss时需要安装："></a>使用<code>scss</code>的效果和<code>css</code>效果一样,但是使用<code>scsss</code>时需要安装：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i node-sass -D // 因为create-react-app中没有内置</span><br></pre></td></tr></table></figure><h5 id="然后就可以使用-scss的文件编译了"><a href="#然后就可以使用-scss的文件编译了" class="headerlink" title="然后就可以使用.scss的文件编译了"></a>然后就可以使用<code>.scss</code>的文件编译了</h5><h5 id="1-2-2-使用-css-Module的第二种方式"><a href="#1-2-2-使用-css-Module的第二种方式" class="headerlink" title="1.2.2 使用 css Module的第二种方式"></a>1.2.2 使用 <code>css Module</code>的第二种方式</h5><h5 id="方式：-1"><a href="#方式：-1" class="headerlink" title="方式："></a>方式：</h5><blockquote><h6 id="在命令行运行-npm-run-eject-命令-此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆"><a href="#在命令行运行-npm-run-eject-命令-此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆" class="headerlink" title="在命令行运行 npm run eject 命令,  此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆"></a>在命令行运行 <code>npm run eject</code> 命令,  此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆</h6></blockquote><blockquote><h6 id="运行完成之后，打开-config-目录下的webpack-config-js-文件，找到-test-cssRegex-这一行"><a href="#运行完成之后，打开-config-目录下的webpack-config-js-文件，找到-test-cssRegex-这一行" class="headerlink" title="运行完成之后，打开 config 目录下的webpack.config.js 文件，找到 test: cssRegex 这一行"></a>运行完成之后，打开 config 目录下的<code>webpack.config.js</code> 文件，找到 <code>test: cssRegex</code> 这一行</h6></blockquote><blockquote><h6 id="在-use-属性执行的方法中添加-modules-true，如下图："><a href="#在-use-属性执行的方法中添加-modules-true，如下图：" class="headerlink" title="在 use 属性执行的方法中添加 modules: true，如下图："></a>在 use 属性执行的方法中添加 <code>modules: true</code>，如下图：</h6></blockquote><p><img src="../image%5Ccreate-react-app%5Ccss_modules.png" alt="css_modules"></p><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><blockquote><h6 id="和第一种方式的用法一致，只是不需要在-css-文件后面加-module-后缀了"><a href="#和第一种方式的用法一致，只是不需要在-css-文件后面加-module-后缀了" class="headerlink" title="和第一种方式的用法一致，只是不需要在 css 文件后面加 .module 后缀了"></a>和第一种方式的用法一致，只是不需要在 css 文件后面加 .module 后缀了</h6></blockquote><h5 id="在浏览器中查看效果-1"><a href="#在浏览器中查看效果-1" class="headerlink" title="在浏览器中查看效果:"></a>在浏览器中查看效果:</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class="_2elxDxwd6P93-x9qDZkogR"&gt;悲催的一天开始了&lt;/p&gt;</span><br></pre></td></tr></table></figure><hr><blockquote><h6 id="如想使用第二种方式对-sass-和-less-也使用-CSS-Modules-的方式进行引用，则类似的在-sass-和-less-解析配置上也添加modules-true-即可。"><a href="#如想使用第二种方式对-sass-和-less-也使用-CSS-Modules-的方式进行引用，则类似的在-sass-和-less-解析配置上也添加modules-true-即可。" class="headerlink" title="如想使用第二种方式对 sass 和 less 也使用 CSS Modules 的方式进行引用，则类似的在 sass 和 less 解析配置上也添加modules: true 即可。"></a><strong>如想使用第二种方式对 sass 和 less 也使用 CSS Modules 的方式进行引用，则类似的在 sass 和 less 解析配置上也添加<code>modules: true</code> 即可。</strong></h6></blockquote><hr><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><h6 id="默认-create-react-app-脚手架不能直接使用-sass-和-less-直接编写-css，需要先进行相应配置"><a href="#默认-create-react-app-脚手架不能直接使用-sass-和-less-直接编写-css，需要先进行相应配置" class="headerlink" title="默认 create-react-app 脚手架不能直接使用 sass 和 less 直接编写 css，需要先进行相应配置"></a>默认 <code>create-react-app</code> 脚手架不能直接使用 sass 和 less 直接编写 css，需要先进行相应配置</h6></blockquote><h4 id="1-3-在-Create-React-App-中启用-Sass-和-Less"><a href="#1-3-在-Create-React-App-中启用-Sass-和-Less" class="headerlink" title="1.3 在 Create-React-App 中启用 Sass 和 Less"></a>1.3 在 <code>Create-React-App</code> 中启用 Sass 和 Less</h4><h5 id="1-3-1-启用-sass-语法编写-css"><a href="#1-3-1-启用-sass-语法编写-css" class="headerlink" title="1.3.1 启用 sass 语法编写 css"></a>1.3.1 启用 sass 语法编写 css</h5><blockquote><p> <code>create-react-app</code>脚手架中已经添加了 sass-loader 的支持，所以只需要安装 <code>node-sass</code>插件即可 </p></blockquote><h5 id="安装：node-sass插件"><a href="#安装：node-sass插件" class="headerlink" title="安装：node-sass插件"></a>安装：node-sass插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install node-sass --save</span><br><span class="line"><span class="meta">#</span><span class="bash">or</span></span><br><span class="line">yarn add node-sass</span><br></pre></td></tr></table></figure><h5 id="用法：编写-sass文件：-App-scss"><a href="#用法：编写-sass文件：-App-scss" class="headerlink" title="用法：编写 sass文件： App.scss"></a>用法：编写 sass文件： App.scss</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.App</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: hotpink;</span><br><span class="line">  <span class="selector-class">.common</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在js文件中直接使用："><a href="#在js文件中直接使用：" class="headerlink" title="在js文件中直接使用："></a>在js文件中直接使用：</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./components/User'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p className=<span class="string">"common"</span>&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;User /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">因为此时scss中没有开启模块化 所以在全局中引用该样式属性都会被使用该类的样式</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h5 id="1-3-2-启用-less-语法编写-css"><a href="#1-3-2-启用-less-语法编写-css" class="headerlink" title="1.3.2 启用 less 语法编写 css"></a>1.3.2 启用 less 语法编写 css</h5><blockquote><p> 由于 <code>create-react-app</code>脚手架中并没有配置关于 less 文件的解析，所以我们需要自己进行配置。需要安装的插件 <code>less</code>， <code>less-loader</code> </p></blockquote><h5 id="安装：less-、less-loader"><a href="#安装：less-、less-loader" class="headerlink" title="安装：less 、less-loader"></a>安装：less 、less-loader</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i less -S</span><br><span class="line">npm i less-loader -S</span><br></pre></td></tr></table></figure><h5 id="打开web-config-js文件-找到-style-files-regexes-注释位置，仿照其解析-sass-的规则，在下面添加两行代码"><a href="#打开web-config-js文件-找到-style-files-regexes-注释位置，仿照其解析-sass-的规则，在下面添加两行代码" class="headerlink" title="打开web.config.js文件  找到 // style files regexes 注释位置，仿照其解析 sass 的规则，在下面添加两行代码"></a>打开<code>web.config.js</code>文件  找到 <code>// style files regexes</code> 注释位置，仿照其解析 sass 的规则，在下面添加两行代码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 添加 less 解析规则</span><br><span class="line">const lessRegex = /\.less$/;</span><br><span class="line">const lessModuleRegex = /\.module\.less$/;</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less.png" alt="less"></p><h5 id="找到-rules-属性配置，在其中添加-less-解析配置"><a href="#找到-rules-属性配置，在其中添加-less-解析配置" class="headerlink" title="找到 rules 属性配置，在其中添加 less 解析配置"></a>找到 rules 属性配置，在其中添加 less 解析配置</h5><blockquote><blockquote><h6 id="注意：-这里有一个需要注意的地方，下面的这些-less-配置规则放在-sass-的解析规则下面即可，如果放在了-file-loader-的解析规则下面，less-文件解析不会生效。"><a href="#注意：-这里有一个需要注意的地方，下面的这些-less-配置规则放在-sass-的解析规则下面即可，如果放在了-file-loader-的解析规则下面，less-文件解析不会生效。" class="headerlink" title="注意： 这里有一个需要注意的地方，下面的这些 less 配置规则放在 sass 的解析规则下面即可，如果放在了 file-loader 的解析规则下面，less 文件解析不会生效。"></a><strong>注意：</strong> 这里有一个需要注意的地方，下面的这些 <code>less</code> 配置规则放在 <code>sass</code> 的解析规则下面即可，如果放在了 <code>file-loader</code> 的解析规则下面，<code>less</code> 文件解析不会生效。</h6></blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less 解析配置</span></span><br><span class="line">&#123;</span><br><span class="line">    test: lessRegex,</span><br><span class="line">    exclude: lessModuleRegex,</span><br><span class="line">    use: getStyleLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'less-loader'</span></span><br><span class="line">    ),</span><br><span class="line">    sideEffects: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: lessModuleRegex,</span><br><span class="line">    use: getStyleLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">            modules: <span class="literal">true</span>,</span><br><span class="line">            getLocalIdent: getCSSModuleLocalIdent,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'less-loader'</span></span><br><span class="line">    )</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less_module.png" alt="less_module"></p><h5 id="用法-编写-less-文件：App-less"><a href="#用法-编写-less-文件：App-less" class="headerlink" title="用法: 编写 less 文件：App.less"></a>用法: 编写 less 文件：<code>App.less</code></h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.App</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00a4ff</span>;</span><br><span class="line">  <span class="selector-class">.common</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">color</span>: hotpink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在js文件中直接使用：改写App-js"><a href="#在js文件中直接使用：改写App-js" class="headerlink" title="在js文件中直接使用：改写App.js"></a>在js文件中直接使用：改写App.js</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./components/User'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.less'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p className=<span class="string">"common"</span>&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;User /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="注意：刚刚启用的scss、less是没有启动模块化的，在web-config-js中启动模块化"><a href="#注意：刚刚启用的scss、less是没有启动模块化的，在web-config-js中启动模块化" class="headerlink" title="注意：刚刚启用的scss、less是没有启动模块化的，在web.config.js中启动模块化"></a>注意：刚刚启用的scss、less是没有启动模块化的，在<code>web.config.js</code>中启动模块化</h4><h4 id="然后在css中不要启动模块化-确保引入第三方插件时能够正常使用"><a href="#然后在css中不要启动模块化-确保引入第三方插件时能够正常使用" class="headerlink" title="然后在css中不要启动模块化,确保引入第三方插件时能够正常使用"></a>然后在css中不要启动模块化,确保引入第三方插件时能够正常使用</h4></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less 解析配置</span></span><br><span class="line">            &#123;</span><br><span class="line">              test: lessRegex,</span><br><span class="line">              exclude: lessModuleRegex,</span><br><span class="line">              use: getStyleLoaders(</span><br><span class="line">                &#123;</span><br><span class="line">                  importLoaders: <span class="number">2</span>,</span><br><span class="line">                  modules: <span class="literal">true</span>,</span><br><span class="line">                  localIdentName: <span class="string">'[name]__[local]-[hash:base64:5]'</span>,</span><br><span class="line">                  sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'less-loader'</span></span><br><span class="line">              ),</span><br><span class="line">              sideEffects: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%9D%97%E5%8C%96.png" alt="less启动模块化"></p><h4 id="1-4-添加图片、字体图标、文件"><a href="#1-4-添加图片、字体图标、文件" class="headerlink" title="1.4 添加图片、字体图标、文件"></a>1.4 添加图片、字体图标、文件</h4><h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><blockquote><h6 id="在js文件中使用"><a href="#在js文件中使用" class="headerlink" title="在js文件中使用:"></a>在<code>js</code>文件中使用:</h6></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引用</span><br><span class="line">// 例如</span><br><span class="line">import logo from './logo.png'</span><br><span class="line"></span><br><span class="line">// &lt;img src=&#123;logo&#125; alt="Logo" /&gt;</span><br></pre></td></tr></table></figure><blockquote><h6 id="在css文件中使用："><a href="#在css文件中使用：" class="headerlink" title="在css文件中使用："></a>在<code>css</code>文件中使用：</h6></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 例如</span><br><span class="line"><span class="selector-class">.Logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(./logo.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><blockquote><h5 id="在index-js或者App根组件中直接引入iconfont-css"><a href="#在index-js或者App根组件中直接引入iconfont-css" class="headerlink" title="在index.js或者App根组件中直接引入iconfont.css"></a>在<code>index.js或者App根组件</code>中直接引入<code>iconfont.css</code></h5></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 例如</span><br><span class="line">import './style/iconfont.css'</span><br><span class="line"></span><br><span class="line">//引用</span><br><span class="line">&lt;p className="icon-fenxiang"&gt;子组件&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="2-配置代理"><a href="#2-配置代理" class="headerlink" title="2.配置代理"></a>2.配置代理</h2><p><strong>环境变量：</strong></p><blockquote><p>在根目录直接新建文件：<br><code>.env.production</code><br>就是生产环境的变量 </p><p> 变量规则：<br>必须是 <code>REACT_APP_</code>开头的 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REACT_APP_ROOT='/api'</span><br></pre></td></tr></table></figure><blockquote><p> 读取不变还是 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let root = process.env.REACT_APP_ROOT</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置代理</strong></p><p>在src 根目录新建：<code>setupProxy.js</code><br>配置还是一样的</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(proxy(<span class="string">'/api'</span>, &#123;</span><br><span class="line">    target: <span class="string">'http://192.168.152.55:6666'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">"^/api"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>react会自动加载这个文件 *</em></p><h2 id="3-Redux使用"><a href="#3-Redux使用" class="headerlink" title="3. Redux使用"></a>3. <code>Redux</code>使用</h2><h4 id="3-1-Redux介绍"><a href="#3-1-Redux介绍" class="headerlink" title="3.1 Redux介绍"></a>3.1 <code>Redux</code>介绍</h4><p> <code>Redux</code>是一个用来管理管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂，JavaScript需要管理比任何时候都要多的<code>state</code>（状态），Redux就是降低管理难度的 </p><p><img src="../image/create-react-app/redux_flow.png" alt="redux_flow"></p><h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux -S</span><br></pre></td></tr></table></figure><h4 id="项目src下新建TodoList-jsx："><a href="#项目src下新建TodoList-jsx：" class="headerlink" title="项目src下新建TodoList.jsx："></a>项目src下新建<code>TodoList.jsx</code>：</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span>  <span class="comment">// src下的创建的store文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; changeInputAction, addItemAction, deleteItemAction, getList &#125; <span class="keyword">from</span> <span class="string">'./store/actionCreators'</span></span><br><span class="line"><span class="keyword">import</span> TodoListUI <span class="keyword">from</span> <span class="string">'./TodoListUI'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// store.getState() 会拿到store中存储的值</span></span><br><span class="line">    <span class="keyword">this</span>.state = store.getState()</span><br><span class="line">    <span class="keyword">this</span>.changeInputValue = <span class="keyword">this</span>.changeInputValue.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.storeChange = <span class="keyword">this</span>.storeChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.clickBtn = <span class="keyword">this</span>.clickBtn.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.deleteItem = <span class="keyword">this</span>.deleteItem.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 订阅Redux的状态</span></span><br><span class="line">    store.subscribe(<span class="keyword">this</span>.storeChange)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">TodoListUI</span></span></span></span><br><span class="line"><span class="xml">      inputValue=&#123;this.state.inputValue&#125;</span></span><br><span class="line"><span class="xml">      list=&#123;this.state.list&#125;</span></span><br><span class="line"><span class="xml">      changeInputValue=&#123;this.changeInputValue&#125;</span></span><br><span class="line"><span class="xml">      clickBtn=&#123;this.clickBtn&#125;</span></span><br><span class="line"><span class="xml">      deleteItem=&#123;this.deleteItem&#125;</span></span><br><span class="line"><span class="xml">    /&gt;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  componentDidMount() &#123;</span></span><br><span class="line"><span class="xml">    axios.get('http://localhost:3000/List.json')</span></span><br><span class="line"><span class="xml">    .then(res =&gt; &#123;</span></span><br><span class="line"><span class="xml">      // console.log(res.data)</span></span><br><span class="line"><span class="xml">      const action = getList(res.data.data)</span></span><br><span class="line"><span class="xml">      store.dispatch(action)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  changeInputValue(e) &#123;</span></span><br><span class="line"><span class="xml">    const action = changeInputAction(e.target.value)</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  clickBtn() &#123;</span></span><br><span class="line"><span class="xml">    const action = addItemAction()</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  deleteItem(index) &#123;</span></span><br><span class="line"><span class="xml">    const action = deleteItemAction(index)</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 订阅Redux的状态</span></span><br><span class="line"><span class="xml">  storeChange() &#123;</span></span><br><span class="line"><span class="xml">    this.setState(store.getState())</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default TodoList;</span></span><br></pre></td></tr></table></figure><h4 id="项目src下新建TodoListUI-jsx"><a href="#项目src下新建TodoListUI-jsx" class="headerlink" title="项目src下新建TodoListUI.jsx"></a>项目src下新建<code>TodoListUI.jsx</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Input, Button, List &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TodoListUI = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(props)</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Input</span><br><span class="line">        placeholder=&#123;props.inputValue&#125;</span><br><span class="line">        style=&#123;&#123; width: '250px', marginRight: '10px' &#125;&#125;</span><br><span class="line">        onChange=&#123;props.changeInputValue&#125;</span><br><span class="line">        value=&#123;props.inputValue&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        type="primary"</span><br><span class="line">        onClick=&#123;props.clickBtn&#125;&gt;增加&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div style=&#123;&#123; margin: '10px', width: '300px' &#125;&#125;&gt;</span><br><span class="line">      &lt;List</span><br><span class="line">        bordered</span><br><span class="line">        dataSource=&#123;props.list&#125;</span><br><span class="line">        renderItem=&#123;(item, index) =&gt; (&lt;List.Item onClick=&#123;() =&gt; &#123; props.deleteItem(index) &#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default TodoListUI;</span><br></pre></td></tr></table></figure><h4 id="项目src下新建store文件夹，然后创建index-js"><a href="#项目src下新建store文件夹，然后创建index-js" class="headerlink" title="项目src下新建store文件夹，然后创建index.js"></a>项目src下新建store文件夹，然后创建<code>index.js</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入createStore方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据存储仓库</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    reducer,</span><br><span class="line">    <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h4 id="在创建reducer-jsx-reducer配合index-js使用"><a href="#在创建reducer-jsx-reducer配合index-js使用" class="headerlink" title="在创建reducer.jsx(reducer配合index.js使用)"></a>在创建<code>reducer.jsx</code>(reducer配合<code>index.js</code>使用)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;CHANGE_INPUT, ADD_ITEM, DELETE_ITEM, GET_LIST&#125; <span class="keyword">from</span> <span class="string">'./actionType'</span></span><br><span class="line"><span class="comment">// 默认数据</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  inputValue: <span class="string">'Write SomeThing...'</span>,</span><br><span class="line">  list: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reducer里只能接收state，不能改变state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123; <span class="comment">// 就是一个方法函数</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * state: 指的是原始仓库里的状态</span></span><br><span class="line"><span class="comment">   * action: 指的是action新传递的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(action.type === CHANGE_INPUT) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.inputValue = action.value</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === ADD_ITEM) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.list.unshift(newState.inputValue)</span><br><span class="line">    newState.inputValue = <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === DELETE_ITEM) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.list.splice(action.index,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === GET_LIST) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(action)</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state))</span><br><span class="line">    newState.list = action.list.list</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public文件夹下创建List-json"><a href="#public文件夹下创建List-json" class="headerlink" title="public文件夹下创建List.json"></a>public文件夹下创建<code>List.json</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当作axios请求的数据</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"list"</span>: [</span><br><span class="line">      <span class="string">"早上起不来，起床困难族"</span>,</span><br><span class="line">      <span class="string">"中午没精神,没办法,我太难了"</span>,</span><br><span class="line">      <span class="string">"别说了,晚上加班搞工作、学习、学习使我快乐"</span>,</span><br><span class="line">      <span class="string">"我要加班、我要加班、我要加班、重要的事情说三遍!!!"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redux的三个小坑"><a href="#Redux的三个小坑" class="headerlink" title="Redux的三个小坑"></a><code>Redux</code>的三个小坑</h4><blockquote><h5 id="1-store-必须是唯一的，多个store是坚决不被允许的，只能有一个store空间"><a href="#1-store-必须是唯一的，多个store是坚决不被允许的，只能有一个store空间" class="headerlink" title="1. store 必须是唯一的，多个store是坚决不被允许的，只能有一个store空间"></a>1. <code>store</code> 必须是唯一的，多个<code>store</code>是坚决不被允许的，只能有一个<code>store</code>空间</h5><h5 id="2-只有store能改变自己的内容，Reducer不能改变"><a href="#2-只有store能改变自己的内容，Reducer不能改变" class="headerlink" title="2. 只有store能改变自己的内容，Reducer不能改变"></a>2. 只有<code>store</code>能改变自己的内容，<code>Reducer</code>不能改变</h5><h5 id="3-Reducer必须是纯函数"><a href="#3-Reducer必须是纯函数" class="headerlink" title="3. Reducer必须是纯函数"></a>3. <code>Reducer</code>必须是纯函数</h5></blockquote><h5 id="纯函数的定义是："><a href="#纯函数的定义是：" class="headerlink" title="纯函数的定义是："></a>纯函数的定义是：</h5><blockquote><p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-create-react-app-创建及使用&quot;&gt;&lt;a href=&quot;#1-create-react-app-创建及使用&quot; class=&quot;headerlink&quot; title=&quot;1. create-react-app 创建及使用&quot;&gt;&lt;/a&gt;1. &lt;code&gt;crea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React Router4</title>
    <link href="http://yoursite.com/2020/02/03/React%E5%AD%A6%E4%B9%A0%E2%80%94React%20Router4/"/>
    <id>http://yoursite.com/2020/02/03/React%E5%AD%A6%E4%B9%A0%E2%80%94React%20Router4/</id>
    <published>2020-02-03T15:58:29.374Z</published>
    <updated>2020-02-04T06:19:12.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-React-Router-4"><a href="#1-React-Router-4" class="headerlink" title="1. React Router 4"></a>1. React Router 4</h3><ul><li><code>react-router</code> React Router核心</li><li><code>react-router-dom</code> 用于DOM绑定的React Router</li><li><code>react-router-native</code>用于React Native 的 React Router</li><li><code>react-router-redux</code> React Router和 Redux 的集成</li><li><code>react-router-config</code>用于配置静态路由</li></ul><blockquote><p>因此，在实际的 web 项目开发中，<code>react-router</code> 和 <code>react-router-dom</code> 不必同时引用。在 <code>react-router-dom</code> 中包含<code>BrowserRouter</code> 类似  的 DOM 类组件，所以只需要引入 <code>react-router-dom</code>包就可以了</p></blockquote><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Link, Switch&#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br></pre></td></tr></table></figure><h3 id="2-页面中多个模块同时渲染问题"><a href="#2-页面中多个模块同时渲染问题" class="headerlink" title="2. 页面中多个模块同时渲染问题"></a>2. 页面中多个模块同时渲染问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>当访问 <code>path=&quot;/card&quot;</code> 的页面时，<code>path=&quot;/&quot;</code> 的页面也会被渲染出来。匹配 <code>path=&quot;/card&quot;</code> 的路由会匹配 <code>path=&quot;/&quot;</code> 的路由。那么这个问题怎么解决呢？有以下两种方法</p></blockquote><ol><li><p>使用 <code>&lt;Router&gt;</code>的<code>exact</code>关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>使用独立路由：<code>&lt;switch&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route, Switch, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/"</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Switch&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h5 id="首先需要了解下-lt-Router-gt-。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进-lt-Router-gt-组件中，比如："><a href="#首先需要了解下-lt-Router-gt-。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进-lt-Router-gt-组件中，比如：" class="headerlink" title="首先需要了解下&lt;Router&gt;。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进&lt;Router&gt;组件中，比如："></a>首先需要了解下<code>&lt;Router&gt;</code>。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进<code>&lt;Router&gt;</code>组件中，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr/</span>&gt;</span><br><span class="line">        &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Router&gt;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：<Router>下值允许存在一个子元素，如存在多个则会报错。所以上面的代码中，需要使用<code>&lt;div&gt;</code>包裹起来</p></blockquote><h5 id="在实际的项目中，我们一般不会直接使用-lt-Router-gt-而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的-lt-BrowserRouter-gt-以及其他常用的高级路由。"><a href="#在实际的项目中，我们一般不会直接使用-lt-Router-gt-而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的-lt-BrowserRouter-gt-以及其他常用的高级路由。" class="headerlink" title="在实际的项目中，我们一般不会直接使用&lt;Router&gt;,而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的&lt;BrowserRouter&gt;以及其他常用的高级路由。"></a>在实际的项目中，我们一般不会直接使用<code>&lt;Router&gt;</code>,而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的<code>&lt;BrowserRouter&gt;</code>以及其他常用的高级路由。</h5><ol><li><p><code>&lt;BrowserRouter&gt;</code></p><p>使用 HTML5 提供的<code>history API (</code>pushState<code>,</code>replaceState<code>和</code>popstate<code>事件)</code>来保持 UI 和 url 的同步。下面介绍一下该路由组件中的 5 个属性：</p><ul><li><p><code>basename:string</code></p><p>当前位置的基准 <code>url</code> 。如果你的页面部署在服务器的二级（子）目录，你需要将 <code>basename</code> 设置到此子目录。 正确的 <code>url</code> 格式是前面有一个前导斜杠，但不能有尾部斜杠。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter basename=<span class="string">"/calendar"</span>/&gt;</span><br><span class="line">&lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// 渲染为 &lt;a href="/calendar/today"&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>getUserConfirmation: func</code></p><p>当导航需要确认时执行的函数。默认使用 <code>window.confirm</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的确认函数</span></span><br><span class="line"><span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> allowTransition = <span class="built_in">window</span>.confirm(message)</span><br><span class="line">  callback(allowTransition)</span><br><span class="line">&#125;</span><br><span class="line">&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>forceRefresh: bool</code></p><p>当设置为 <code>true</code> 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 <code>true</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> supportsHistory = <span class="string">'pushState'</span> <span class="keyword">in</span> <span class="built_in">window</span>.history</span><br><span class="line">&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>keyLength: number</code></p><p><code>location.key</code> 的长度，默认是 6。点击同一个链接时，每次该路由下的 <code>location.key</code> 都会改变，可以通过 <code>key</code> 的变化来刷新页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter keyLength=&#123;<span class="number">12</span>&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>children: node</code></p><p>渲染单一子组件（元素）。</p></li></ul></li><li><p><code>&lt;HashRouter&gt;</code></p><p>HashRouter 是一种特定的 <code>&lt;Router&gt;</code> ， HashRouter 使用 url 的 <code>hash</code> (例如： window.location.hash ) 来保持 UI 和 url 的同步。由于使用 hash 的方式记录导航历史不支持 <code>location.key</code> 和 <code>location.state</code> ，该技术仅用于支持传统的浏览器。</p></li></ol><h5 id="介绍完-，当然也要说下-，我们使用最频繁的组件，主要职责是当页面的访问地址与-Route-上的-path-匹配时渲染出对应的-UI-界面。"><a href="#介绍完-，当然也要说下-，我们使用最频繁的组件，主要职责是当页面的访问地址与-Route-上的-path-匹配时渲染出对应的-UI-界面。" class="headerlink" title="介绍完 ，当然也要说下 ，我们使用最频繁的组件，主要职责是当页面的访问地址与 Route 上的 path 匹配时渲染出对应的 UI 界面。"></a>介绍完 <code>，当然也要说下</code> ，我们使用最频繁的组件，主要职责是当页面的访问地址与 <code>Route</code> 上的 <code>path</code> 匹配时渲染出对应的 UI 界面。</h5><h5 id="lt-Route-gt-属性值主要有："><a href="#lt-Route-gt-属性值主要有：" class="headerlink" title="&lt;Route&gt; 属性值主要有："></a><code>&lt;Route&gt;</code> 属性值主要有：</h5><ul><li>path: string</li></ul><p>可以被 <code>path-to-regexp</code> 解析的有效 url 路径。如果没有 <code>path</code>，路由将总是被匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/users/:id"</span> component=&#123;User&#125;/&gt;</span><br></pre></td></tr></table></figure><ul><li>exact: bool</li></ul><p>为 <code>true</code> 时，则要求路径与 <code>location.pathname</code> 必须完全匹配。通过下表解释一下：</p><p><img src="https://jdc.jd.com/wp-content/uploads/2018/07/3.png" alt="img"></p><ul><li>strict: bool</li></ul><p>为 <code>true</code> 时，有结尾斜线的路径只能匹配有斜线的 <code>location.pathname</code> 。见下表：</p><p><img src="https://jdc.jd.com/wp-content/uploads/2018/07/4.png" alt="img"></p><p>第二个属性值 <code>exact</code> 就是我们用来解决多个模块同时渲染问题的，默认值为 <code>true</code> 。</p><p>在这里简要提下<code>&lt;Route&gt;</code>渲染的三种方法：</p><ul><li><code>&lt;Route component&gt;</code> 当访问地址和路由匹配时，一个 <code>React component</code> 将会被渲染</li><li><code>&lt;Route render&gt;</code> 此方法适用于内联渲染，而且不会产生重复装载问题</li><li><code>&lt;Route children&gt;</code></li></ul><p>当需要判断访问地址与路由是否匹配时，可以使用此方法。当不匹配时， <code>match</code> 为 null。</p><p>我们上面代码示例中使用的是第一种方法 <code>Route Component</code>，这三种渲染方法都会用到 <code>match</code> 、<code>location</code> 、 <code>history</code> 这些属性值。</p><p>需要注意的是 ：每一种渲染方法都有其适用背景, <code>&lt;Route component&gt;</code>的优先级比 <code>&lt;Route render&gt;</code>高，而他们又都优先于<code>&lt;Route children&gt;</code>，所以在同一个<code>&lt;Route&gt;</code>应该只使用一种方法，我们大多数使用的是 <code>component</code> 方法。</p><h5 id="说完第一种解决方法的原理，来剖析下第二种方法：-Switch-。"><a href="#说完第一种解决方法的原理，来剖析下第二种方法：-Switch-。" class="headerlink" title="说完第一种解决方法的原理，来剖析下第二种方法： Switch 。"></a>说完第一种解决方法的原理，来剖析下第二种方法： <code>Switch</code> 。</h5><p>该组件只渲染第一个与当前访问地址匹配的 <code>Route</code> 或 <code>Redirect</code> 。它和多个堆叠的<code>Route</code>组件之间的区别是： <code>Switch</code> 只渲染一个路由。</p><p>在解决方法 （2）中，当我们访问 <code>/card</code> ， <code>Switch</code> 将会开始寻找与之匹配的路由，查找到<code>&lt;Route path=&quot;/card&quot; /&gt;</code> 匹配后，<code>Switch</code> 将会停止寻找然后开始渲染 <code>/card</code> 。</p><ul><li>children: node</li></ul><p><code>&lt;Switch&gt;</code> 下的子节点只能是 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code> 元素且只有与当前访问地址匹配的第一个子节点才会被渲染。</p></li></ol><h3 id="3-如何定义默认访问页面"><a href="#3-如何定义默认访问页面" class="headerlink" title="3.如何定义默认访问页面"></a>3.如何定义默认访问页面</h3><blockquote><p>有时我们需要定义一个默认页面，重新引导用户的操作</p></blockquote><p>使用 <code>&lt;Redirect&gt;</code> 。比如当用户手动输入 <code>/test</code> 之后，我们需要跳转至首页，则代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">                &lt;Redirect to=<span class="string">"/"</span> /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><blockquote><p>方法解析：<code>&lt;Redirect&gt;</code> 渲染时将会导向一个新的地址，这个新的地址将会覆盖掉 <code>history</code> 堆栈中的当前地址。</p></blockquote><h5 id="lt-Redirect-gt-其常用的属性是："><a href="#lt-Redirect-gt-其常用的属性是：" class="headerlink" title="&lt;Redirect&gt;其常用的属性是："></a><code>&lt;Redirect&gt;</code>其常用的属性是：</h5><ul><li>to: string</li></ul><p>重定向的 url 地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">"/somewhere/else"</span> /&gt;</span><br></pre></td></tr></table></figure><ul><li>to: object</li></ul><p>重定向的 <code>location</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">'/login'</span>,</span><br><span class="line">  search: <span class="string">'?utm=your+face'</span>,</span><br><span class="line">  state: &#123; <span class="attr">referrer</span>: currentLocation &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure><ul><li>push: bool</li></ul><p>取值为 <code>true</code> 时，重定向操作将会把新地址加入到访问的历史记录里面，并不会替换掉当前的地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect push to=<span class="string">"/somewhere/else"</span>/&gt;</span><br></pre></td></tr></table></figure><ul><li>from: string</li></ul><p>需要匹配的将要被重定向的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">'/old-path'</span> to=<span class="string">'/new-path'</span>/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">'/new-path'</span> component=&#123;Place&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：<code>&lt;Route&gt;</code> 元素使用 <code>path</code> 属性进行匹配，<code>Redirect</code> 元素使用 <code>from</code> 属性进行匹配。如果元素中没有对应的 <code>path</code> 或 <code>from</code>，那么它们将匹配任何当前的访问地址。</p></blockquote><h3 id="4-路由激活状态的控制"><a href="#4-路由激活状态的控制" class="headerlink" title="4. 路由激活状态的控制"></a>4. 路由激活状态的控制</h3><blockquote><p>使用<Link>组件或者<NavLink></p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeClassName=<span class="string">"selected"</span></span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><h5 id="lt-NavLink-gt-是-lt-Link-gt-的特殊版本，当遇到匹配的-URL-渲染元素时会添加样式属性，适用于页面导航部分。"><a href="#lt-NavLink-gt-是-lt-Link-gt-的特殊版本，当遇到匹配的-URL-渲染元素时会添加样式属性，适用于页面导航部分。" class="headerlink" title="&lt;NavLink&gt;是&lt;Link&gt; 的特殊版本，当遇到匹配的 URL 渲染元素时会添加样式属性，适用于页面导航部分。"></a><code>&lt;NavLink&gt;</code>是<code>&lt;Link&gt;</code> 的特殊版本，当遇到匹配的 URL 渲染元素时会添加样式属性，适用于页面导航部分。</h5><ul><li>activeClassName: string</li></ul><p>导航选中时的样式名，默认样式名为 <code>active</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeClassName=<span class="string">"selected"</span></span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>activeStyle: object</li></ul><p>导航选中时的样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: <span class="string">'bold'</span>,</span><br><span class="line">    color: <span class="string">'red'</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>exact: bool</li></ul><p>若值为 <code>true</code>，当访问地址严格匹配时激活样式才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  exact</span><br><span class="line">  to=<span class="string">"/profile"</span></span><br><span class="line">&gt;Profile&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>strict: bool</li></ul><p>若值为 <code>true</code>，只有当访问地址后缀斜杠严格匹配（有或无）时激活样式才会生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  strict</span><br><span class="line">  to=<span class="string">"/events/"</span></span><br><span class="line">&gt;Events&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>isActive: func</li></ul><p>用于添加页面激活时的操作逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oddEvent = <span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID)</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/events/123"</span></span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;Event <span class="number">123</span>&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-页面跳转"><a href="#5-页面跳转" class="headerlink" title="5. 页面跳转"></a>5. 页面跳转</h3><ol><li><h5 id="使用-history-控制路由的跳转"><a href="#使用-history-控制路由的跳转" class="headerlink" title="使用 history 控制路由的跳转"></a>使用 history 控制路由的跳转</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.push(<span class="string">'/some/path'</span>);</span><br></pre></td></tr></table></figure><p><code>history</code> 指的是 <code>history</code> 包，是 4.x 中的重要依赖之一。常见的 <code>history</code> 路由方案有三种形式，分别是：</p><ul><li>browser history 在 DOM 上的实现，用于支持 HTML5 history API 的浏览器；</li><li>hash history 在 DOM 上的实现，用于旧版浏览器；</li><li>memory history 在内存上的实现，用于测试或非 DOM 环境（如 <code>React Native</code>）</li></ul><p><code>history</code> 对象包含的属性和方法如下所示：</p><ul><li><code>length</code>: number history 堆栈中的地址数目</li><li><code>action</code>: string 当前的动作 (PUSH , REPLACE , 或者是 POP )</li><li><code>location</code>: object 当前访问地址信息组成的对象</li><li><code>push(path, [state])</code>: func 在 history 堆栈信息里加入一个新路径</li><li><code>replace(path, [state])</code> : func 替换 history 堆栈信息里的当前路径</li><li><code>go(n)</code> : func 将 history 堆栈中的指针向前移动 n</li><li><code>goBack()</code>: func 等同于 go(-1)</li><li><code>goForward()</code>: func 等同于 go(1)</li><li><code>block(prompt)</code> : func 阻止跳转</li></ul><h5 id="需要注意的是：history-对象是可变的，所以不要从-history-location-直接获取，而是需要通过-lt-Route-gt-的prop-来获取-location。"><a href="#需要注意的是：history-对象是可变的，所以不要从-history-location-直接获取，而是需要通过-lt-Route-gt-的prop-来获取-location。" class="headerlink" title="需要注意的是：history 对象是可变的，所以不要从 history.location 直接获取，而是需要通过 &lt;Route&gt; 的prop 来获取 location。"></a>需要注意的是：<code>history</code> 对象是可变的，所以不要从 <code>history.location</code> 直接获取，而是需要通过 <code>&lt;Route&gt;</code> 的<code>prop</code> 来获取 <code>location</code>。</h5></li><li><h5 id="使用-Context，获得-router-对象"><a href="#使用-Context，获得-router-对象" class="headerlink" title="使用 Context，获得 router 对象"></a>使用 <code>Context</code>，获得 <code>router</code> 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">     <span class="keyword">super</span>(props, context);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  myFunction() &#123;</span><br><span class="line">    <span class="keyword">this</span>.context.router.history.push(<span class="string">"/some/Path"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-切换路由后，页面仍然停留在上一个页面的位置"><a href="#6-切换路由后，页面仍然停留在上一个页面的位置" class="headerlink" title="6.切换路由后，页面仍然停留在上一个页面的位置"></a>6.切换路由后，页面仍然停留在上一个页面的位置</h3><h5 id="问题：由-A-页面跳转到-B-页面，B-页面停留在-A-页面的位置，没有返回到顶部。"><a href="#问题：由-A-页面跳转到-B-页面，B-页面停留在-A-页面的位置，没有返回到顶部。" class="headerlink" title="问题：由 A 页面跳转到 B 页面，B 页面停留在 A 页面的位置，没有返回到顶部。"></a>问题：由 A 页面跳转到 B 页面，B 页面停留在 A 页面的位置，没有返回到顶部。</h5><p>用户可以对 window 和独立组件的滚动位置进行管理。可以使用 <code>withRouter</code> 组件： <code>withRouter</code> 可以访问历史对象的属性和最近的 <code>&lt;Route&gt;</code> 匹配项，当路由的属性值 { <code>match</code>, <code>location</code>, <code>history</code> } 改变时，<code>withRouter</code> 都会重新渲染。该组件可以携带组件的路由信息，避免组件之间一层层传递。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">withRouter(MyComponent)</span><br></pre></td></tr></table></figure><p>这样就可以获取到 MyComponent 组件的路由信息了。</p><p>解决方法：使用 <code>withRouter</code> 封装 <code>ScrollToTop</code> 组件。这里就用到了 <code>withRouter</code> 携带路由信息的特性，通过对比<code>props</code> 中 <code>location</code> 的变化，实现页面的滚动</p><ol><li><h5 id="定义-ScrollToTop-组件，代码如下："><a href="#定义-ScrollToTop-组件，代码如下：" class="headerlink" title="定义 ScrollToTop 组件，代码如下："></a>定义 <code>ScrollToTop</code> 组件，代码如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollToTop</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.props.location !== prevProps.location) &#123;</span><br><span class="line">          <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(ScrollToTop);</span><br></pre></td></tr></table></figure></li><li><h5 id="在定义路由处引用该组件，例如："><a href="#在定义路由处引用该组件，例如：" class="headerlink" title="在定义路由处引用该组件，例如："></a>在定义路由处引用该组件，例如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;ScrollToTop&gt;</span><br><span class="line">            &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ScrollToTop&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>这样处理之后，当跳转页面时都会自动回到该页面的顶部位置。</p></li></ol><h3 id="7-页面之间如何传值"><a href="#7-页面之间如何传值" class="headerlink" title="7.页面之间如何传值"></a>7.页面之间如何传值</h3><p>问题背景：当路由发生跳转时我们可能需要携带一些参数</p><p>解决方法：使用 <code>props</code> 属性，介绍以下三种传值方法：</p><ol><li><h5 id="props-params"><a href="#props-params" class="headerlink" title="props.params"></a><code>props.params</code></h5><p>指定一个 path ，然后指定通配符可以携带参数到指定的 <code>path</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/user/:name'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>跳转 UserPage 页面时，可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//link方法</span></span><br><span class="line">&lt;Link to=<span class="string">"/user/sam"</span>&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/push方法</span></span><br><span class="line"><span class="regexp">this.props.history.push("/u</span>ser/sam<span class="string">");</span></span><br></pre></td></tr></table></figure><p>在 UserPage 页面中通过 <code>this.props.params.name</code> 获取值。</p><p>上面的方法可以传递一个或多个值，但是每个值的类型都是字符串，没法传递一个对象。如果要传的话可以将 json 对象转换为字符串，传递过去之后再将 json 字符串转换为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line">data = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line"><span class="keyword">let</span> path = <span class="string">'/user/$&#123;data&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在页面中获取值时</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.props.params.data);</span><br></pre></td></tr></table></figure></li><li><h5 id="query"><a href="#query" class="headerlink" title="query"></a><code>query</code></h5><p><code>query</code> 方式可以传递任意类型的值，但是页面的 <code>url</code> 也是由 <code>query</code> 的值拼接的，<code>url</code> 很长且是明文传输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义路由</span></span><br><span class="line">&lt;Route path=<span class="string">'/user'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据定义</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> path = &#123;</span><br><span class="line">    pathname: <span class="string">'/user'</span>,</span><br><span class="line">    query: data,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面跳转</span></span><br><span class="line">&lt;Link to=&#123;path&#125;&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">this.props.history.push(path);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/页面取值</span></span><br><span class="line"><span class="regexp">let data = this.props.location.query;</span></span><br><span class="line"><span class="regexp">let &#123;id,name,age&#125; = data;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h5><p><code>state</code> 方式类似于 <code>post</code>，依然可以传递任意类型的数据，而且可以不以明文方式传输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义路由</span></span><br><span class="line">&lt;Route path=<span class="string">'/user'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据定义</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> path = &#123;</span><br><span class="line">    pathname: <span class="string">'/user'</span>,</span><br><span class="line">    state: data,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面跳转</span></span><br><span class="line">&lt;Link to=&#123;path&#125;&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">this.props.history.push(path);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/页面取值</span></span><br><span class="line"><span class="regexp">let data = this.props.location.state;</span></span><br><span class="line"><span class="regexp">let &#123;id,name,age&#125; = data;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="8-使用-lt-BrowserRouter-gt-配置路由，上传页面至服务器后页面出现-404"><a href="#8-使用-lt-BrowserRouter-gt-配置路由，上传页面至服务器后页面出现-404" class="headerlink" title="8.使用 &lt;BrowserRouter&gt; 配置路由，上传页面至服务器后页面出现 404"></a>8.使用 <code>&lt;BrowserRouter&gt;</code> 配置路由，上传页面至服务器后页面出现 404</h3><h5 id="问题背景：项目中控制路由跳转使用的是-lt-BrowserRouter-gt-，代码如下："><a href="#问题背景：项目中控制路由跳转使用的是-lt-BrowserRouter-gt-，代码如下：" class="headerlink" title="问题背景：项目中控制路由跳转使用的是 &lt;BrowserRouter&gt;，代码如下："></a>问题背景：项目中控制路由跳转使用的是 <code>&lt;BrowserRouter&gt;</code>，代码如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在开发过程中使用是没有问题的，但是将页面上传至服务器之后，问题就来了：用户访问的资源不存在，页面是空白的。</p><p>问题分析：`` 是使用 React-Router 应用推荐的 <code>history</code> 方案。它使用浏览器中的 History API 用于处理 url，创建一个像 <code>example.com/list/123</code> 这样真实的 url。当通过真实 url 访问网站的时候，由于路径是指向服务器的真实路径，但该路径下并没有相关资源，所以用户访问的资源不存在。</p><p>解决方法：</p><h5 id="1-使用-lt-HashRouter-gt-。"><a href="#1-使用-lt-HashRouter-gt-。" class="headerlink" title="1. 使用 &lt;HashRouter&gt;。"></a>1. 使用 <code>&lt;HashRouter&gt;</code>。</h5><p>它使用 url 中的 hash（#）部分去创建路由，举例来说，用户访问 <code>http://www.example.com/</code> ，实际会看到的是 <code>http://www.example.com/#/</code> 。<br>为什么本地开发时没有问题呢？那是因为我们的 <code>React</code> 脚手架中使用 <code>webpack-dev-server</code> 做了配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webpackConfig.devServer = &#123;</span><br><span class="line">    disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    contentBase: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">//gzip压缩</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-如果要使用-lt-BrowserRouter-gt-的话，服务器需要进行相关路由配置"><a href="#2-如果要使用-lt-BrowserRouter-gt-的话，服务器需要进行相关路由配置" class="headerlink" title="2.如果要使用 &lt;BrowserRouter&gt; 的话，服务器需要进行相关路由配置"></a>2.如果要使用 <code>&lt;BrowserRouter&gt;</code> 的话，服务器需要进行相关路由配置</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-React-Router-4&quot;&gt;&lt;a href=&quot;#1-React-Router-4&quot; class=&quot;headerlink&quot; title=&quot;1. React Router 4&quot;&gt;&lt;/a&gt;1. React Router 4&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Node学习—app.use中间件</title>
    <link href="http://yoursite.com/2020/01/13/Node%E5%AD%A6%E4%B9%A0%E2%80%94app.use%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/01/13/Node%E5%AD%A6%E4%B9%A0%E2%80%94app.use%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2020-01-13T08:00:19.963Z</published>
    <updated>2019-10-19T06:42:42.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Express中路由和中间件"><a href="#1-Express中路由和中间件" class="headerlink" title="1. Express中路由和中间件"></a>1. Express中路由和中间件</h3><h6 id="路由：就是如何处理HTTP请求中的路径部分"><a href="#路由：就是如何处理HTTP请求中的路径部分" class="headerlink" title="路由：就是如何处理HTTP请求中的路径部分"></a>路由：就是如何处理HTTP请求中的路径部分</h6><h6 id="中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数"><a href="#中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数" class="headerlink" title="中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数"></a>中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数</h6><h5 id="1-1-应用及中间件"><a href="#1-1-应用及中间件" class="headerlink" title="1.1 应用及中间件"></a>1.1 应用及中间件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next方法的作用就是将请求传递到下一个中间件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  当请求进来，会从第一个中间件开始进行匹配</span></span><br><span class="line"><span class="comment">     如果匹配，则进来</span></span><br><span class="line"><span class="comment">     如果请求进入中间件之后，没有调用 next 则代码会停在当前中间件</span></span><br><span class="line"><span class="comment">     如果调用了 next 则继续向后找到第一个匹配的中间件</span></span><br><span class="line"><span class="comment">     如果不匹配，则继续判断匹配下一个中间件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不关心请求路径的请求</span></span><br><span class="line"><span class="comment">// 不管以什么路径请求只要有next()传递</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>) <span class="comment">// 1</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)  <span class="comment">// 2</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">req,res.next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)  <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关心请求路径的请求</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/b'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 /a 开头的路径中间件</span></span><br><span class="line">app.use(<span class="string">'/a'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当在浏览器中以 /a 开头的请求时，会输出 1 a 2</span></span><br><span class="line"><span class="comment">// 当在浏览器中以 /b 开头的请求时，会输出 1 b,这里不会输出 2 因为当请求/b开头的请求后没有next()方法传递就会停留在那个请求中</span></span><br></pre></td></tr></table></figure><h5 id="1-2-错误处理中间件"><a href="#1-2-错误处理中间件" class="headerlink" title="1.2 错误处理中间件"></a>1.2 错误处理中间件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/user'</span>,(req,res,next) =&gt; &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(has error)</span><br><span class="line">       next()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">       next(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 全局错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack)</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'error message'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/a'</span>,(req,res,next) =&gt; &#123;</span><br><span class="line">  fs.readFile(path.join(__dirname,<span class="string">'./datas.txt'</span>),<span class="string">'utf8'</span>,(err,data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/a'</span>, (req,res,next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'/a'</span>)</span><br><span class="line">  res.send(<span class="string">'/a'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不匹配任何请求路径时 会进去此错误处理</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'404 not Found'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="1-3-express中的router"><a href="#1-3-express中的router" class="headerlink" title="1.3 express中的router"></a>1.3 express中的router</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> public = <span class="built_in">require</span>(<span class="string">'./router/public'</span>)</span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'./router/user'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/public'</span>, public) <span class="comment">// 当请求以/public开头的路径时才会进来</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/user'</span>, user) <span class="comment">// 当请求以/uer开头的路径时才会进来</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,() =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// router</span></span><br><span class="line"><span class="comment">// 1.user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/a'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello node'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.public.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/b'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><ul><li><strong>app.router() 要挂载在所有第三方中间件的后面，因为前面配置的中间件是app.router()中请求处理函数的依赖</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Express中路由和中间件&quot;&gt;&lt;a href=&quot;#1-Express中路由和中间件&quot; class=&quot;headerlink&quot; title=&quot;1. Express中路由和中间件&quot;&gt;&lt;/a&gt;1. Express中路由和中间件&lt;/h3&gt;&lt;h6 id=&quot;路由：就是如何
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Node学习—express中cookie和session</title>
    <link href="http://yoursite.com/2020/01/13/Node%E5%AD%A6%E4%B9%A0%E2%80%94express%E4%B8%ADcookie%E5%92%8Csession/"/>
    <id>http://yoursite.com/2020/01/13/Node%E5%AD%A6%E4%B9%A0%E2%80%94express%E4%B8%ADcookie%E5%92%8Csession/</id>
    <published>2020-01-13T08:00:19.952Z</published>
    <updated>2020-01-13T11:20:34.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Cookie-和-Session"><a href="#1-Cookie-和-Session" class="headerlink" title="1.Cookie 和 Session"></a>1.Cookie 和 Session</h3><p>​       会话管理：客户端和服务端通信过程中的数据是如何管理的</p><p>​       会话管理的技术：数据存在客户端  Cookie</p><p>​                                      数据存在服务端 Session</p><p>​       <strong>Cookie</strong>: http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据</p><p>​     <strong>Session</strong>: session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源</p><h5 id="1-1-express中使用cookie-parser中间件"><a href="#1-1-express中使用cookie-parser中间件" class="headerlink" title="1.1 express中使用cookie-parser中间件"></a>1.1 express中使用cookie-parser中间件</h5><p><img src="../image/cookie/%E5%9B%BE%E7%89%871.png" alt="cookie"></p><h6 id="1-1-1-安装：npm-install-cookie-parser-S"><a href="#1-1-1-安装：npm-install-cookie-parser-S" class="headerlink" title="1.1.1 安装：npm install cookie-parser -S"></a>1.1.1 安装：npm install cookie-parser -S</h6><h6 id="1-1-2-引包：const-cookieParser-require-‘cookie-parser’"><a href="#1-1-2-引包：const-cookieParser-require-‘cookie-parser’" class="headerlink" title="1.1.2 引包：const cookieParser = require(‘cookie-parser’)"></a>1.1.2 引包：const cookieParser = require(‘cookie-parser’)</h6><h6 id="1-1-3-配置cookie-parser中间件"><a href="#1-1-3-配置cookie-parser中间件" class="headerlink" title="1.1.3 配置cookie-parser中间件"></a>1.1.3 配置cookie-parser中间件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>))</span><br></pre></td></tr></table></figure><h6 id="1-1-4在服务器通过res-cookie-方法创建一个cookie"><a href="#1-1-4在服务器通过res-cookie-方法创建一个cookie" class="headerlink" title="1.1.4在服务器通过res.cookie()方法创建一个cookie"></a>1.1.4在服务器通过res.cookie()方法创建一个cookie</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie的配置参数：</span><br><span class="line">maxAge  : 是cookie最大的有效时间 单位为毫秒</span><br><span class="line">expires ：是cookie的过期时间  是一个date对象</span><br><span class="line">httpOnly ： 当前cookie是否只能被web服务器获取</span><br><span class="line">singed:  是否对cookie进行签名(防止cookie被用户在浏览器修改)</span><br><span class="line">path：   是cookie的有效访问路径(如果没有设置，则默认为根路径)</span><br><span class="line">        比如我们设置了path:&quot;&#x2F;&quot; ，即意味着访问当前网站的任何接口都会携带cookie</span><br><span class="line">        比如我们设置了path:&quot;&#x2F;user&quot;，即意味着只有访问有&#x2F;user开头的接口才会在请求中携带cookie</span><br></pre></td></tr></table></figure><h6 id="1-1-5设置cookie的请求"><a href="#1-1-5设置cookie的请求" class="headerlink" title="1.1.5设置cookie的请求"></a>1.1.5设置cookie的请求</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/setCookie"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.cookie(<span class="string">"name"</span>,<span class="string">"cookiename"</span>,      &#123;<span class="attr">path</span>:<span class="string">"/user"</span>,<span class="attr">maxAge</span>:<span class="number">600000</span>,<span class="attr">httpOnly</span>:<span class="literal">true</span>,<span class="string">'signed'</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">    res.send(<span class="string">'setcookie'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="1-1-6-浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器-服务器此时可以通过req-cookies来查看当前的cookie"><a href="#1-1-6-浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器-服务器此时可以通过req-cookies来查看当前的cookie" class="headerlink" title="1.1.6 浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器,服务器此时可以通过req.cookies来查看当前的cookie"></a>1.1.6 浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器,服务器此时可以通过req.cookies来查看当前的cookie</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/getCookie"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//如果没有对cookie进行签名，则通过req.cookies来获取cookie</span></span><br><span class="line">    <span class="comment">//如果对cookie进行了签名，则通过req.signedCookies来获取cookie</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies,req.signedCookies)  <span class="comment">// &#123;&#125; &#123;&#125;</span></span><br><span class="line">    res.send(<span class="string">'getcookie'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/user"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies,req.signedCookies) <span class="comment">// &#123;&#125; &#123;name: 'cookiename'&#125;</span></span><br><span class="line">    res.send(<span class="string">'getcookie'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="1-1-7-Cookie记住用户名"><a href="#1-1-7-Cookie记住用户名" class="headerlink" title="1.1.7 Cookie记住用户名"></a>1.1.7 Cookie记住用户名</h6><p><img src="../image/cookie/%E5%9B%BE%E7%89%872.png" alt="cookie"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line"></span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;)</span><br><span class="line"></span><br><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;)</span><br><span class="line"></span><br><span class="line">const app &#x3D; express()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: false &#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.engine(&#39;html&#39;, require(&#39;express-art-template&#39;))</span><br><span class="line">app.set(&#39;views&#39;, __dirname + &#39;&#x2F;views&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(cookieParser(&#39;xiaoxiong&#39;))</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;login&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.signedCookies.name) &#123;</span><br><span class="line">    res.render(&#39;login.html&#39;,&#123;</span><br><span class="line">      name: req.signedCookies.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.render(&#39;login.html&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;usercenter&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.signedCookies.name) &#123;</span><br><span class="line">    res.render(&#39;usercenter.html&#39;,&#123;</span><br><span class="line">      name: req.signedCookies.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.render(&#39;usercenter.html&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&#39;&#x2F;login&#39;,(req,res) &#x3D;&gt; &#123;</span><br><span class="line">  let name &#x3D; req.body.name</span><br><span class="line">  let pwd &#x3D; req.body.pwd</span><br><span class="line">  let rmbname &#x3D; req.body.rmbname</span><br><span class="line">  &#x2F;&#x2F; console.log(name+&#39;---&#39;+pwd+&#39;---&#39;+&#39;---&#39;+rmbname)</span><br><span class="line">  if(rmbname &#x3D;&#x3D; &#39;on&#39;) &#123;</span><br><span class="line">    if(name &#x3D;&#x3D; &#39;朱艳&#39; &amp;&amp; pwd &#x3D;&#x3D; &#39;zhuyan&#39;) &#123;</span><br><span class="line">      res.cookie(&#39;name&#39;,name,&#123;</span><br><span class="line">        maxAge: 60000,</span><br><span class="line">        httpOnly: true,</span><br><span class="line">        &#39;signed&#39;: true</span><br><span class="line">      &#125;)</span><br><span class="line">      res.redirect(&#39;&#x2F;usercenter&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.send(&#39;账号或者密码有误&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if(name &#x3D;&#x3D; &#39;朱艳&#39; &amp;&amp; pwd &#x3D;&#x3D; &#39;zhuyan&#39;) &#123;</span><br><span class="line">      res.redirect(&#39;&#x2F;usercenter&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.send(&#39;账号或者密码错误&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;running..&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="2-1express中express-session中间件"><a href="#2-1express中express-session中间件" class="headerlink" title="2.1express中express-session中间件"></a>2.1express中express-session中间件</h5><p><img src="../image/cookie/%E5%9B%BE%E7%89%873.png" alt="session"></p><h6 id="2-1-1-安装：npm-install-express-session-S"><a href="#2-1-1-安装：npm-install-express-session-S" class="headerlink" title="2.1.1 安装：npm install express-session -S"></a>2.1.1 安装：npm install express-session -S</h6><h6 id="2-1-2-引包：const-expressSession-require-‘express-session’"><a href="#2-1-2-引包：const-expressSession-require-‘express-session’" class="headerlink" title="2.1.2 引包：const expressSession = require(‘express-session’)"></a>2.1.2 引包：<em>const</em> expressSession = require(‘express-session’)</h6><h6 id="2-1-3-配置中间件"><a href="#2-1-3-配置中间件" class="headerlink" title="2.1.3 配置中间件"></a>2.1.3 配置中间件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(expressSession(&#123;</span><br><span class="line">  name : <span class="string">"cookieid"</span>,  <span class="comment">//指定所创建的session对应的cookie的名字</span></span><br><span class="line">  secret : <span class="string">'secret'</span>,  <span class="comment">//指定是否要签名这个cookie</span></span><br><span class="line">  <span class="comment">//resave: 强制保存 session 即使它并没有变化,。默认为 true。建议设置成 false。但是这个并不一定是必须的，如果客户端有两个并行的请求到你的服务端，</span></span><br><span class="line">  <span class="comment">// 一个请求对session的修改可能被另外一个请求覆盖掉，即使第二个请求并没有修改session</span></span><br><span class="line">  resave : <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// rolling:强制在每一个response中都发送session标识符的cookie。roling默认是false。如果把这个值设置为true但是  saveUnitialized设置为false,</span></span><br><span class="line">  <span class="comment">// 没有初始化的session的cookie不会被包含在响应中。主要作用：每次请求都重置cookie过期时间</span></span><br><span class="line">  rolling: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 强制没有“初始化”的session保存到storage(store:保存session的地方)中，</span></span><br><span class="line">  <span class="comment">// 没有初始化的session指的是刚被创建没有被修改。默认是true,但是不建议使用默认值</span></span><br><span class="line">  saveUninitialized: <span class="literal">false</span>, </span><br><span class="line">  cookie : &#123;</span><br><span class="line">      maxAge : <span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>,   <span class="comment">//指定session对应的cookie的有效时间</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h6 id="2-1-4设置session"><a href="#2-1-4设置session" class="headerlink" title="2.1.4设置session"></a>2.1.4设置session</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;setsession&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  req.session.userinfo &#x3D; &#39;xiaoyang&#39;</span><br><span class="line">  res.send(&#39;setsession&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="2-1-5-得到session"><a href="#2-1-5-得到session" class="headerlink" title="2.1.5 得到session"></a>2.1.5 得到session</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/getsession'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.session)</span><br><span class="line">  res.send(req.session.userinfo)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="2-1-6-session登录案例"><a href="#2-1-6-session登录案例" class="headerlink" title="2.1.6 session登录案例"></a>2.1.6 session登录案例</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> expressSession = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'html'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>))</span><br><span class="line">app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>)</span><br><span class="line"></span><br><span class="line">app.use(expressSession(&#123;</span><br><span class="line">  name: <span class="string">"cookieid"</span>,  <span class="comment">//指定所创建的session对应的cookie的名字</span></span><br><span class="line">  secret: <span class="string">'secret'</span>,  <span class="comment">//指定是否要签名这个cookie</span></span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  rolling: <span class="literal">true</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">false</span>,</span><br><span class="line">  cookie: &#123;</span><br><span class="line">    maxAge: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>,   <span class="comment">//指定session对应的cookie的有效时间</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/login'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="built_in">console</span>.log(user)</span><br><span class="line">  res.render(<span class="string">'login.html'</span>,user)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取请求参数信息</span></span><br><span class="line">  <span class="keyword">let</span> name = req.body.name</span><br><span class="line">  <span class="keyword">let</span> pwd = req.body.pwd</span><br><span class="line">  <span class="comment">// 如果用户登录成功 则把用户的信息存储到session中</span></span><br><span class="line">  <span class="keyword">if</span> (name == <span class="string">'sessionName'</span> &amp;&amp; pwd == <span class="string">'123'</span>) &#123;</span><br><span class="line">    <span class="comment">// 存储会话数据</span></span><br><span class="line">    req.session.user = req.body</span><br><span class="line">    <span class="comment">// 跳转到用户中心页面</span></span><br><span class="line">    res.redirect(<span class="string">'/usercenter'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">'账号或者密码错误'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/usercenter'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从session中获取之前保存的数据</span></span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="built_in">console</span>.log(user)</span><br><span class="line">  <span class="keyword">if</span> (user &amp;&amp; user.name) &#123;</span><br><span class="line">    res.render(<span class="string">'usercenter.html'</span>, &#123;</span><br><span class="line">      name: user.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.render(<span class="string">'usercenter.html'</span>, &#123;</span><br><span class="line">      name: <span class="string">'default'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出的登录</span></span><br><span class="line">app.get(<span class="string">'/layout'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 清空session</span></span><br><span class="line">  req.session.destroy()</span><br><span class="line">  res.redirect(<span class="string">'/home'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/home'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="keyword">if</span> (user &amp;&amp; user.name) &#123;</span><br><span class="line">    res.render(<span class="string">"home.html"</span>, &#123; <span class="attr">name</span>: user.name &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    res.render(<span class="string">"home.html"</span>, &#123; <span class="attr">name</span>: <span class="string">"default"</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Cookie-和-Session&quot;&gt;&lt;a href=&quot;#1-Cookie-和-Session&quot; class=&quot;headerlink&quot; title=&quot;1.Cookie 和 Session&quot;&gt;&lt;/a&gt;1.Cookie 和 Session&lt;/h3&gt;&lt;p&gt;​     
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
