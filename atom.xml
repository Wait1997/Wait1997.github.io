<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wait1997</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-12T14:41:54.072Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaoxiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue学习—KeepAlive介绍与应用</title>
    <link href="http://yoursite.com/2020/02/12/Vue%E5%AD%A6%E4%B9%A0%E2%80%94KeepAlive%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/12/Vue%E5%AD%A6%E4%B9%A0%E2%80%94KeepAlive%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-12T12:56:09.836Z</published>
    <updated>2020-02-12T14:41:54.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue中的keepAlive的介绍与应用"><a href="#Vue中的keepAlive的介绍与应用" class="headerlink" title="Vue中的keepAlive的介绍与应用"></a><code>Vue</code>中的<code>keepAlive</code>的介绍与应用</h3><h4 id="1-keep-alive是什么"><a href="#1-keep-alive是什么" class="headerlink" title="1. keep-alive是什么"></a>1. <code>keep-alive</code>是什么</h4><blockquote><p>keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹组件时，会缓存不活动的组件实例，而不是销毁它们。</p></blockquote><h4 id="2-keep-alive用法"><a href="#2-keep-alive用法" class="headerlink" title="2. keep-alive用法"></a>2. <code>keep-alive</code>用法</h4><ul><li><p><strong>Props</strong>：</p><ul><li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li><code>max</code> - 数字。最多可以缓存多少组件实例。</li></ul><p><strong><code>include</code> 和 <code>exclude</code> 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</strong></p><p><strong>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)。匿名组件不能被匹配</strong></p><p><strong><code>max</code>最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</strong></p></li><li><p>用法：</p><p><code>keep-alive</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>transition</code> 相似，<code>keep-alive</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p><p>当组件在 <code>keep-alive</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p><ol><li><p>在动态组件中的应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">"whiteList"</span> :exclude=<span class="string">"blackList"</span> :max=<span class="string">"amount"</span>&gt;</span><br><span class="line">  &lt;component :is=<span class="string">"currentComponent"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>vue-router</code>中的应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">"whiteList"</span> :exclude=<span class="string">"blackList"</span> :max=<span class="string">"amount"</span>&gt;</span><br><span class="line">  &lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：<code>keep-alive</code> 是用在其一个直属的子组件被开关的情形。如果你在其中有 <code>v-for</code> 则不会工作。如果有上述的多个条件性的子元素，<code>keep-alive</code> 要求同时只有一个子元素被渲染。</p></li></ul><h4 id="3-keepAlive解决条件缓存的例子"><a href="#3-keepAlive解决条件缓存的例子" class="headerlink" title="3. keepAlive解决条件缓存的例子"></a>3. <code>keepAlive</code>解决条件缓存的例子</h4><h5 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h5><p>主页 –&gt;前进 列表页–&gt;前进 详情页，详情页 –&gt;返回 列表页 –&gt;返回 主页</p><h5 id="希望："><a href="#希望：" class="headerlink" title="希望："></a>希望：</h5><p>从 详情页 –&gt;返回 列表页 的时候页面的状态是缓存，不用重新请求数据，提升用户体验。</p><p>从 列表页 –&gt;返回 主页 的时候页面，注销掉列表页，以在进入不同的列表页的时候，获取最新的数据。</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><ol><li><p>思路</p><p><img src="..%5Cimage%5CkeepAlive%5Ck1.png" alt="k1"></p></li><li><p>写2个 <code>router-view</code> 出口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;!-- 需要缓存的视图组件 --&gt;</span><br><span class="line">  &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 不需要缓存的视图组件 --&gt;</span><br><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/router-view&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>Router</code>里定义好需要缓存的视图组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Home'</span>)</span><br><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/List'</span>)</span><br><span class="line"><span class="keyword">const</span> Detail = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Detail'</span>)</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'App'</span>,</span><br><span class="line">    redirect: <span class="string">'/home'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      deepth: <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home/list'</span>,</span><br><span class="line">    name: <span class="string">'list'</span>,</span><br><span class="line">    component: List,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      deepth: <span class="number">1</span>,</span><br><span class="line">      keepAlive: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home/list/detail'</span>,</span><br><span class="line">    name: <span class="string">'detail'</span>,</span><br><span class="line">    component: Detail,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      deepth: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>按需<code>keepAlive</code></p><p><img src="..%5Cimage%5CkeepAlive%5Ck2.png" alt="k2"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">"include"</span>&gt;</span><br><span class="line">    &lt;!-- 需要缓存的视图组件 --&gt;</span><br><span class="line">  &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 不需要缓存的视图组件 --&gt;</span><br><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/router-view&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>app.vue</code>里监听路由的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"App"</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">"app-left"</span>,</span><br><span class="line">      include: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">//如果要 to(进入)的页面需要 keepAlive 缓存的 把 name push 进 include 数组</span></span><br><span class="line">      <span class="keyword">if</span> (to.meta.keepAlive) &#123;</span><br><span class="line">        !<span class="keyword">this</span>.include.includes(to.name) &amp;&amp; <span class="keyword">this</span>.include.push(to.name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果要 from(离开) 的页面是 keepAlive 缓存的</span></span><br><span class="line">      <span class="comment">// 再根据 deepth 来判断是前进还是后退</span></span><br><span class="line">      <span class="comment">// 如果是后退</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">from</span>.meta.keepAlive &amp;&amp; to.meta.deepth &lt; <span class="keyword">from</span>.meta.deepth) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="keyword">this</span>.include.indexOf(<span class="keyword">from</span>.name);</span><br><span class="line">        <span class="built_in">console</span>.log(index);</span><br><span class="line">        index !== <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.include.splice(index, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> toDepth = to.path.split(<span class="string">"/"</span>).length;</span><br><span class="line">      <span class="keyword">const</span> fromDepth = <span class="keyword">from</span>.path.split(<span class="string">"/"</span>).length;</span><br><span class="line">      <span class="keyword">this</span>.name = toDepth &lt; fromDepth ? <span class="string">"app-right"</span> : <span class="string">"app-left"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可以满足需求</p></li></ol><h4 id="4-补充："><a href="#4-补充：" class="headerlink" title="4. 补充："></a>4. 补充：</h4><blockquote><p>再<code>vue-router</code>的<code>过渡动效</code>中可以根据数组的<code>split</code>方法分割成数组的长度，达成左右切换的过渡效果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    $route(to, from) &#123;</span><br><span class="line">      &#x2F;&#x2F;如果要 to(进入)的页面需要 keepAlive 缓存的 把 name push 进 include 数组</span><br><span class="line">      if (to.meta.keepAlive) &#123;</span><br><span class="line">        !this.include.includes(to.name) &amp;&amp; this.include.push(to.name);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果要 from(离开) 的页面是 keepAlive 缓存的</span><br><span class="line">      &#x2F;&#x2F; 再根据 deepth 来判断是前进还是后退</span><br><span class="line">      &#x2F;&#x2F; 如果是后退</span><br><span class="line">      if (from.meta.keepAlive &amp;&amp; to.meta.deepth &lt; from.meta.deepth) &#123;</span><br><span class="line">        let index &#x3D; this.include.indexOf(from.name);</span><br><span class="line">        console.log(index);</span><br><span class="line">        index !&#x3D;&#x3D; -1 &amp;&amp; this.include.splice(index, 1);</span><br><span class="line">      &#125;</span><br><span class="line">      const toDepth &#x3D; to.path.split(&quot;&#x2F;&quot;).length;</span><br><span class="line">      const fromDepth &#x3D; from.path.split(&quot;&#x2F;&quot;).length;</span><br><span class="line">      this.name &#x3D; toDepth &lt; fromDepth ? &quot;app-right&quot; : &quot;app-left&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'App'</span>,</span><br><span class="line">    redirect: <span class="string">'/home'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      deepth: <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home/list'</span>,</span><br><span class="line">    name: <span class="string">'list'</span>,</span><br><span class="line">    component: List,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      deepth: <span class="number">1</span>,</span><br><span class="line">      keepAlive: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home/list/detail'</span>,</span><br><span class="line">    name: <span class="string">'detail'</span>,</span><br><span class="line">    component: Detail,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      deepth: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：需要搭配好路由</p><h5 id="过渡效果实现"><a href="#过渡效果实现" class="headerlink" title="过渡效果实现"></a>过渡效果实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition :name=<span class="string">"name"</span>&gt;</span><br><span class="line">      &lt;keep-alive :include=<span class="string">"include"</span>&gt;</span><br><span class="line">        &lt;router-view v-<span class="keyword">if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>transition&gt;</span><br><span class="line">    &lt;transition :name=<span class="string">"name"</span>&gt;</span><br><span class="line">      &lt;router-view v-<span class="keyword">if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/transition&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">  <span class="selector-class">.app-left-enter-active</span>,</span><br><span class="line">  <span class="selector-class">.app-right-enter-active</span>,</span><br><span class="line">  <span class="selector-class">.app-left-leave-active</span>,</span><br><span class="line">  <span class="selector-class">.app-right-leave-active</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.app-left-enter</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translateX(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.app-left-leave-active-to</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translateX(-<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.app-right-enter</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translateX(-<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.app-right-leave-active-to</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translateX(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue中的keepAlive的介绍与应用&quot;&gt;&lt;a href=&quot;#Vue中的keepAlive的介绍与应用&quot; class=&quot;headerlink&quot; title=&quot;Vue中的keepAlive的介绍与应用&quot;&gt;&lt;/a&gt;&lt;code&gt;Vue&lt;/code&gt;中的&lt;code&gt;ke
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—防抖节流</title>
    <link href="http://yoursite.com/2020/02/10/JavaScript%E2%80%94%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>http://yoursite.com/2020/02/10/JavaScript%E2%80%94%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-02-10T08:35:33.197Z</published>
    <updated>2020-02-10T09:07:10.214Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS防抖、节流的使用"><a href="#JS防抖、节流的使用" class="headerlink" title="JS防抖、节流的使用"></a><code>JS</code>防抖、节流的使用</h3><blockquote><p>在项目中过程中，经常遇到一个按钮被点击多次并且多次调用对应处理函数的问题。有时也会遇到需要再某一规则内有规律的去触发对应的处理函数，所以就需要使用到函数防抖与节流来帮助我们实现想要的场景以及避免不必要的问题。</p></blockquote><h4 id="1-函数防抖"><a href="#1-函数防抖" class="headerlink" title="1. 函数防抖"></a>1. 函数防抖</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>当持续触发事件时，一定时间段没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，有一次触发了事件，就重新开始延时。</p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>维护一个定时器，规定在延时时间后触发函数，但是在延时时间内再次触发的话，就取消之前的定时器而重新设置，这样就能保证只有最后一次操作被触发。即将所有操作合并为一个操作进行，并且只有最后一次操作是有效的</p><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><ul><li><code>文本框输入值的时候</code>，<code>search</code>搜索框的时候，用户在不断输入值时，用防抖来节约请求资源</li><li>监听窗口滚动条<code>scroll</code>事件的时候，用户需要多次触发只执行最后一次</li><li><code>window</code>触发<code>resize</code>的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖只触发一次</li></ul><h5 id="代码使用："><a href="#代码使用：" class="headerlink" title="代码使用："></a>代码使用：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay=<span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>; <span class="comment">// dom</span></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>,args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以把节流代码封装在自己<code>函数库</code>中，使用的时候调用即可。</p><h4 id="2-函数节流"><a href="#2-函数节流" class="headerlink" title="2. 函数节流"></a>2. 函数节流</h4><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数，按照一定的规律在某个时间间隔内去处理函数。</p><h5 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h5><p>原理是通过判断是否到达一定时间来触发函数，使得一定时间内只触发一次函数。</p><h5 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h5><ul><li><code>button</code>的<code>click</code>事件，用户点击按钮，让在间隔的时间内只触发一次</li></ul><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Throttle = <span class="function">(<span class="params">fn, delay = <span class="number">500</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> last;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (last &amp;&amp; now - last &lt; delay) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      last = now;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>防抖、节流在<code>vue</code>、<code>react</code>项目使用很常见。封装在<code>utils</code>文件中，使用的时候调用即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS防抖、节流的使用&quot;&gt;&lt;a href=&quot;#JS防抖、节流的使用&quot; class=&quot;headerlink&quot; title=&quot;JS防抖、节流的使用&quot;&gt;&lt;/a&gt;&lt;code&gt;JS&lt;/code&gt;防抖、节流的使用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在项目中过程中，经常遇到
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—react hook实现简易redux</title>
    <link href="http://yoursite.com/2020/02/08/React%E5%AD%A6%E4%B9%A0%E2%80%94react%20hook%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93redux/"/>
    <id>http://yoursite.com/2020/02/08/React%E5%AD%A6%E4%B9%A0%E2%80%94react%20hook%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93redux/</id>
    <published>2020-02-08T11:37:52.005Z</published>
    <updated>2020-02-09T10:00:15.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React-hook-实现-Redux功能"><a href="#React-hook-实现-Redux功能" class="headerlink" title="React hook 实现 Redux功能"></a>React hook 实现 Redux功能</h3><p>![redux](..\image\react hooks实现redux\redux.png)</p><h4 id="1-useContext的使用"><a href="#1-useContext的使用" class="headerlink" title="1. useContext的使用"></a>1. <code>useContext</code>的使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useContext, useMemo, createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CountContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> Count = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = useContext(CountContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> counts = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;p&gt;&#123;counts&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> Num = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; num &#125; = useContext(CountContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nums = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;, [num]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;p&gt;&#123;nums&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> Example1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;YOU CLICK ME &#123;count&#125; TIMES&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;YOU CLICK His &#123;num&#125; TIMES&lt;/</span>div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + <span class="number">1</span>) &#125;&#125;&gt;点击按钮+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; &#123; setNum(num + 2) &#125;&#125;&gt;点击按钮+2&lt;/</span>button&gt;</span><br><span class="line">      &lt;CountContext.Provider value=&#123;&#123; count, num &#125;&#125;&gt;</span><br><span class="line">        &lt;Count /&gt;</span><br><span class="line">        &lt;Num /&gt;</span><br><span class="line">      &lt;<span class="regexp">/CountContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example1;</span><br></pre></td></tr></table></figure><p>通过<code>createContext()</code>创建一个<code>contenxt</code>环境可以想子孙组件传值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CountContext = createContext();</span><br></pre></td></tr></table></figure><p>通过在父组件注册：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;CountContext.Provider value=&#123;&#123; count, num &#125;&#125;&gt;</span><br><span class="line">  &lt;Count /&gt;</span><br><span class="line">  &lt;Num /&gt;</span><br><span class="line">&lt;<span class="regexp">/CountContext.Provider&gt;</span></span><br></pre></td></tr></table></figure><p>在子组件中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; num &#125; = useContext(CountContext);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = useContext(CountContext);</span><br></pre></td></tr></table></figure><p>使用<code>useMemo</code>做性能优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> counts = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"><span class="comment">//count数值没有改变时，缓存值，不渲染</span></span><br></pre></td></tr></table></figure><h4 id="2-useReducer使用"><a href="#2-useReducer使用" class="headerlink" title="2. useReducer使用"></a>2. <code>useReducer</code>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Example2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(state, action)</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'sub'</span>:</span><br><span class="line">        <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [count, dispatch] = useReducer(reducer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;现在的数量是&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; &#123; dispatch('add') &#125;&#125;&gt;Add&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123; dispatch(<span class="string">'sub'</span>) &#125;&#125;&gt;Sub&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example2;</span><br></pre></td></tr></table></figure><p><code>useReducer</code> 接受一个 <code>reducer</code> 函数作为参数，<code>reducer</code> 接受两个参数一个是 <code>state</code> 另一个是 <code>action</code> 。然后返回一个状态<code>count</code>和 <code>dispath</code>，<code>count</code> 是返回状态中的值，而<code>dispatch</code> 是一个可以发布事件来更新 <code>state</code> 的。</p><h4 id="3-Redux的功能的实现"><a href="#3-Redux的功能的实现" class="headerlink" title="3. Redux的功能的实现"></a>3. <code>Redux</code>的功能的实现</h4><blockquote><p>对与<code>Redux</code>的实现，需要使用<code>useContext</code>、<code>useReducer</code>两个钩子函数</p></blockquote><ol><li><p>首先</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Color <span class="keyword">from</span> <span class="string">'./component/Color'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'./component/Button'</span>;</span><br><span class="line"><span class="keyword">import</span> ShowArea <span class="keyword">from</span> <span class="string">'./component/ShowArea'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Example3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Color</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ShowArea</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Color</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example3;</span><br></pre></td></tr></table></figure></li><li><p>然后创建<code>Color</code>组件，其中<code>Color</code>组件充当<code>Provider</code>的作用，向其他<code>子组件</code>传值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer &#125; <span class="keyword">from</span> <span class="string">'../store/reducer'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ColorContext &#125; <span class="keyword">from</span> <span class="string">'../store/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Color = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [color, dispatch] = useReducer(reducer, <span class="string">'pink'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ColorContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>, <span class="attr">dispatch</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;props.children&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ColorContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Color;</span><br></pre></td></tr></table></figure></li><li><p>同时再创建<code>store</code>文件夹，再<code>store</code>文件夹下面创建<code>index.js</code>、<code>reducer.js</code>、<code>constants.js</code>、<code>actionCreators.js</code>文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ColorContext = createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; UPDATE_COLOR &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> UPDATE_COLOR:</span><br><span class="line">      <span class="keyword">return</span> action.data</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// contants.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UPDATE_COLOR = <span class="string">'UPDATE_COLOR'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actionCreators.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; UPDATE_COLOR &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeColor = <span class="function">(<span class="params">data</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: UPDATE_COLOR,</span><br><span class="line">  data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建<code>Button.js</code>提供<code>useReducer</code> 的 <code>dispatch</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ColorContext &#125; <span class="keyword">from</span> <span class="string">'../store/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; changeColor &#125; <span class="keyword">from</span> <span class="string">'../store/actionCreators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; dispatch &#125; = useContext(ColorContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleRed = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(changeColor(data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleBlue = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(changeColor(data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123; handleRed(<span class="string">'red'</span>) &#125;&#125;&gt;红色&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; &#123; handleBlue('blue') &#125;&#125;&gt;蓝色&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Button;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>ShowArea.js</code>提供<code>useReducer</code>提供的<code>color</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ColorContext &#125; <span class="keyword">from</span> <span class="string">'../store/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ShowArea = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; color &#125; = useContext(ColorContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123; <span class="attr">color</span>: color &#125;&#125;&gt;</span><br><span class="line">      字体颜色是&#123;color&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default ShowArea;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="如何就能实现Redux的功能"><a href="#如何就能实现Redux的功能" class="headerlink" title="如何就能实现Redux的功能"></a>如何就能实现<code>Redux</code>的功能</h5><h4 id="4-Contenxt的性能问题"><a href="#4-Contenxt的性能问题" class="headerlink" title="4. Contenxt的性能问题"></a>4. <code>Contenxt</code>的性能问题</h4><p>![性能](..\image\react hooks实现redux\性能.png)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React-hook-实现-Redux功能&quot;&gt;&lt;a href=&quot;#React-hook-实现-Redux功能&quot; class=&quot;headerlink&quot; title=&quot;React hook 实现 Redux功能&quot;&gt;&lt;/a&gt;React hook 实现 Redux功能&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—class语法糖</title>
    <link href="http://yoursite.com/2020/02/08/ES6%E2%80%94class%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://yoursite.com/2020/02/08/ES6%E2%80%94class%E8%AF%AD%E6%B3%95%E7%B3%96/</id>
    <published>2020-02-08T07:30:09.267Z</published>
    <updated>2020-02-08T08:24:08.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6—class语法糖"><a href="#ES6—class语法糖" class="headerlink" title="ES6—class语法糖"></a>ES6—class语法糖</h3><blockquote><p>首先，ES6 的 <code>class</code> 属于一种“语法糖”，所以只是写法更加优雅，更加像面对对象的编程，其思想和 ES5 是一致的。</p></blockquote><h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point = <span class="keyword">new</span> Point(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(point.toString());</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(point.toString());</span><br></pre></td></tr></table></figure><p>其中 <code>constructor</code> 方法是类的构造函数，是一个默认方法，通过 <code>new</code> 命令创建对象实例时，自动调用该方法。一个类必须有 <code>constructor</code> 方法，如果没有显式定义，一个默认的 <code>consructor</code> 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 <code>constructor</code> 方法返回实例对象 <code>this</code> ，但是也可以指定  <code>constructor</code> 方法返回一个全新的对象，让返回的实例对象不是该类的实例。</p><h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h5><p><code>super</code>关键字，既可以当做函数使用，也可以当作对象使用。这两种情况下，它的用法完全不用</p><h5 id="1-当作函数使用"><a href="#1-当作函数使用" class="headerlink" title="1. 当作函数使用"></a>1. 当作函数使用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ES6要求，子类的构造函数必须</span></span><br><span class="line"><span class="comment">     * 执行一次super()函数，否则会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在 <code>constructor</code> 中必须调用 <code>super</code> 方法，因为子类没有自己的 <code>this</code> 对象，而是继承父类的 <code>this</code> 对象，然后对其进行加工,而 <code>super</code> 就代表了父类的构造函数。<code>super</code> 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 <code>super</code> 内部的 <code>this</code> 指的是 B，因此 <code>super()</code> 在这里相当于 ```A.prototype.constructor.call(this, props)``。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> A(); <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B(); <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>可以看到，在 <code>super()</code> 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，<code>super()</code> 内部的 <code>this</code> 指向的是 B。</p><h5 id="2-当作普通对象使用"><a href="#2-当作普通对象使用" class="headerlink" title="2. 当作普通对象使用"></a>2. 当作普通对象使用</h5><p>在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  c() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.c()); <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，子类 B 当中的 <code>super.c()</code>，就是将 <code>super</code> 当作一个对象使用。这时，<code>super</code> 在普通方法之中，指向 <code>A.prototype</code>，所以 <code>super.c()</code> 就相当于 <code>A.prototype.c()</code>。</p><p><strong>通过 <code>super</code> 调用父类的方法时，<code>super</code> 会绑定子类的 <code>this</code>。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.s();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.s()</code> 虽然调用的是 <code>A.prototytpe.s()</code>，但是 <code>A.prototytpe.s()</code>会绑定子类 B 的 <code>this</code>，导致输出的是 2，而不是 1。也就是说，实际上执行的是 <code>super.s.call(this)</code>。</p><p><strong>由于绑定子类的 <code>this</code>，所以如果通过 <code>super</code> 对某个属性赋值，这时 <code>super</code> 就是 <code>this</code>，赋值的属性会变成子类实例的属性。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">super</span>.x = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.x); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.x</code> 赋值为 3，这时等同于对 <code>this.x</code> 赋值为 3。而当读取 <code>super.x</code> 的时候，调用的是 <code>A.prototype.x</code>，但并没有 <code>x</code> 方法，所以返回 undefined。</p><p><strong>注意，使用 <code>super</code> 的时候，必须显式指定是作为函数，还是作为对象使用，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>console.log(super);</code> 的当中的 <code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这是，如果能清晰的表明 <code>super</code> 的数据类型，就不会报错。</p><p><strong>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 <code>super</code> 关键字</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6—class语法糖&quot;&gt;&lt;a href=&quot;#ES6—class语法糖&quot; class=&quot;headerlink&quot; title=&quot;ES6—class语法糖&quot;&gt;&lt;/a&gt;ES6—class语法糖&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;首先，ES6 的 &lt;code&gt;cl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—数组扁平化</title>
    <link href="http://yoursite.com/2020/02/07/JavaScript%E2%80%94%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    <id>http://yoursite.com/2020/02/07/JavaScript%E2%80%94%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</id>
    <published>2020-02-07T11:45:11.193Z</published>
    <updated>2020-02-07T14:21:29.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS数组扁平化"><a href="#JS数组扁平化" class="headerlink" title="JS数组扁平化"></a><code>JS</code>数组扁平化</h3><blockquote><p>需求：多维数组 =&gt; 一维数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第0种处理：直接的调用</span></span><br><span class="line">arr_flat = arr.flat(n); <span class="comment">// n表示数组的深度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第1种处理</span></span><br><span class="line">arr = str.replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>).split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> +item);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">或者</span><br><span class="line">arr = arr.toString().split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> +item);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种处理</span></span><br><span class="line">str = str.replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>);</span><br><span class="line">str = <span class="string">`[<span class="subst">$&#123;str&#125;</span>]`</span>;</span><br><span class="line">arr = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第3种处理：递归处理</span></span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      fn(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第4种处理：用reduce实现数组的flat方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur);</span><br><span class="line">  &#125;,[]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//第5种处理：扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">while</span> (arr.some(<span class="built_in">Array</span>.isArray)) &#123;</span><br><span class="line">  arr = [].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS数组扁平化&quot;&gt;&lt;a href=&quot;#JS数组扁平化&quot; class=&quot;headerlink&quot; title=&quot;JS数组扁平化&quot;&gt;&lt;/a&gt;&lt;code&gt;JS&lt;/code&gt;数组扁平化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;需求：多维数组 =&amp;gt; 一维数组&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—执行机制</title>
    <link href="http://yoursite.com/2020/02/07/JavaScript%E2%80%94%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/02/07/JavaScript%E2%80%94%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-07T11:02:02.146Z</published>
    <updated>2020-02-07T11:44:36.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript执行机制"><a href="#JavaScript执行机制" class="headerlink" title="JavaScript执行机制"></a>JavaScript执行机制</h3><h4 id="1-大致流程"><a href="#1-大致流程" class="headerlink" title="1. 大致流程"></a>1. 大致流程</h4><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97.png" alt="执行队列"></p><p>可以看出：</p><ol><li>js代码分为同步任务和异步任务。</li><li>同步任务会进入主线程，异步任务会进入Event Table（事件表），当事件表中的异步任务完成后会在Event Queue（事件队列）中注册回调函数。</li><li>主线程任务全部完成后，才会完成Event Queue中的任务。</li><li>js解析器会不断地重复检查主线程执行栈是否为空，然后重复第3步，这就是Event Loop（事件循环）。</li></ol><h5 id="js代码的类型分为："><a href="#js代码的类型分为：" class="headerlink" title="js代码的类型分为："></a>js代码的类型分为：</h5><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E4%BB%BB%E5%8A%A1.png" alt="任务"></p><ol><li>任务又可以进一步分为宏任务和微任务，这对js代码的执行有更为细致的影响，在文章下面会有讲解。</li><li>异步任务中的宏任务和微任务会进入不同的Event Queue事件队列，即Event Queue又可以分为宏任务队列和微任务队列。</li><li>setInterval会按照设定的时间间隔重复地在Event Queue注册回调函数，如果某一段时间主线程代码执行太久，那么setInterval的回调函数可能阻塞到一起执行，无法保持设定的时间间隔，如果此时setInterval用于动画，则体现为卡顿。</li></ol><h4 id="2-详细流程"><a href="#2-详细流程" class="headerlink" title="2.详细流程"></a>2.详细流程</h4><p>在事件循环（主线程 → 事件队列）中其实有更细致的操作流程，即（宏任务 → 微任务）之间的循环，如下图所示：</p><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B.png" alt="详细流程"></p><p>通常来说，我们页面中的js执行顺序是这样的：</p><ul><li>第一轮事件循环：<ol><li>主线程执行js整段代码（宏任务），将ajax、setTimeout、promise等回调函数注册到Event Queue，并区分宏任务和微任务。</li><li>主线程提取并执行Event Queue 中的ajax、promise等所有微任务，并注册微任务中的异步任务到Event Queue。</li></ol></li><li>第二轮事件循环:<ol><li>主线程提取Event Queue 中的<strong>第一个</strong>宏任务（通常是setTimeout）。</li><li>主线程执行setTimeout宏任务，并注册setTimeout代码中的异步任务到Event Queue（如果有）。</li><li>执行Event Queue中的所有微任务，并注册微任务中的异步任务到Event Queue（如果有）。</li></ol></li><li>类似的循环：<strong>宏任务每执行完一个，就清空一次事件队列中的微任务</strong>。</li></ul><blockquote><p><strong>注意</strong>：事件队列中分“宏任务队列”和“微任务队列”，每执行一次任务都可能注册新的宏任务或微任务到相应的任务队列中，只要遵循“每执行一个宏任务，就会清空一次事件队列中的所有微任务”这一循环规则，就不会弄乱。</p></blockquote><h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">  <span class="comment">// 记作 set1</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="comment">// set4</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// pro2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记作 pro1</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    <span class="comment">// set3</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'8'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记作 set2</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    <span class="comment">// 记作 pro3</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 1 6 7 2 4 5 9 10 11 8 3</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>第一轮事件循环：</p><ol><li><p>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</p><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E5%BE%AA%E7%8E%AF1.png" alt="循环1"></p></li><li><p>遇到set1，其回调函数被分发到宏任务Event Queue中。</p><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E5%BE%AA%E7%8E%AF2.png" alt="循环2"></p></li><li><p>遇到pro1，<code>new Promise</code>直接执行，输出6。then被分发到微任务Event Queue中。</p><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E5%BE%AA%E7%8E%AF3.png" alt="循环3"></p></li><li><p>遇到了set2，其回调函数被分发到宏任务Event Queue中。</p><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E5%BE%AA%E7%8E%AF4.png" alt="循环4"></p></li><li><p>主线程的整段js代码（宏任务）执行完，开始清空所有微任务；主线程执行微任务pro1，输出7；遇到set3，注册回调函数。</p><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E5%BE%AA%E7%8E%AF5.png" alt="循环5"></p></li></ol></li><li><p>第二轮事件循环：</p><ol><li><p>主线程执行队列中第一个宏任务set1，输出2；代码中遇到了set4，注册回调；又遇到了pro2，new promise()直接执行输出4，并注册回调；</p><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E5%BE%AA%E7%8E%AF6.png" alt="循环6"></p></li><li><p>set1宏任务执行完毕，开始清空微任务，主线程执行微任务pro2，输出5。</p><p><img src="..%5Cimage%5Cjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%5C%E5%BE%AA%E7%8E%AF7.png" alt="循环7"></p></li></ol></li><li><p>第三轮事件循环:</p><ol><li>主线程执行队列中第一个宏任务set2，输出9；代码中遇到了pro3，new promise()直接输出10，并注册回调；</li><li>et2宏任务执行完毕，开始情况微任务，主线程执行微任务pro3，输出11。</li><li>…类似循环</li></ol></li></ul><h5 id="所以最后输出结果为1、6、7、2、4、5、9、10、11、8、3"><a href="#所以最后输出结果为1、6、7、2、4、5、9、10、11、8、3" class="headerlink" title="所以最后输出结果为1、6、7、2、4、5、9、10、11、8、3"></a>所以最后输出结果为<code>1、6、7、2、4、5、9、10、11、8、3</code></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JavaScript执行机制&quot;&gt;&lt;a href=&quot;#JavaScript执行机制&quot; class=&quot;headerlink&quot; title=&quot;JavaScript执行机制&quot;&gt;&lt;/a&gt;JavaScript执行机制&lt;/h3&gt;&lt;h4 id=&quot;1-大致流程&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—原型链与继承</title>
    <link href="http://yoursite.com/2020/02/07/JavaScript%E2%80%94%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2020/02/07/JavaScript%E2%80%94%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/</id>
    <published>2020-02-07T09:18:20.660Z</published>
    <updated>2020-02-07T11:01:46.144Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS中原型链与继承"><a href="#JS中原型链与继承" class="headerlink" title="JS中原型链与继承"></a><code>JS</code>中原型链与继承</h3><h4 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h4><p>原型链一直都是一个在<code>JS</code>中比较让人费解的知识点，在<code>js</code>中十分重要，首先引入一个关系图：</p><p><img src="..%5Cimage%5C%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%5C%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p><h5 id="一-要理解原型链，首先可以从上图开始入手，图中有三个概念："><a href="#一-要理解原型链，首先可以从上图开始入手，图中有三个概念：" class="headerlink" title="一. 要理解原型链，首先可以从上图开始入手，图中有三个概念："></a>一. 要理解原型链，首先可以从上图开始入手，图中有三个概念：</h5><ol><li><p>构造函数：<code>JS</code>中所有函数都可以作为构造函数，前提是被new操作符操作；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个JS函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parent1 = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="comment">//这里函数被new操作符操作了，所以我们称Parent为一个构造函数；</span></span><br></pre></td></tr></table></figure></li><li><p>实例： <code>parent1</code> 接收了<code>new Parent()</code>,<code>parent1</code>可以称之为实例；</p></li><li><p>原型对象： 构造函数有一个<code>prototype</code>属性，这个属性会初始化一个原型对象；</p></li></ol><h5 id="二-弄清楚了这三个概念，下面我们来说说这三个概念的关系（参考上图）："><a href="#二-弄清楚了这三个概念，下面我们来说说这三个概念的关系（参考上图）：" class="headerlink" title="二. 弄清楚了这三个概念，下面我们来说说这三个概念的关系（参考上图）："></a>二. 弄清楚了这三个概念，下面我们来说说这三个概念的关系（参考上图）：</h5><ol><li>通过new操作符作用于<code>JS</code>函数，那么就得到了一个实例；</li><li>构造函数会初始化一个prototype，这个prototype会初始化一个原型对象，那么原型对象是怎么知道自己是被哪个函数初始化的呢？原来原型对象会有一个constructor属性，这个属性指向了构造函数；</li><li>那么关键来了实例对象是怎么和原型对象关联起来的呢？原来实例对象会有一个<code>__proto__</code>属性，这个属性指向了该实例对象的构造函数对应的原型对象；</li><li>假如我们从一个对象中去找一个属性name，如果在当前对象中没有找到，那么会通过<code>__proto__</code>属性一直往上找，直到找到Object对象还没有找到name属性，才证明这个属性name是不存在，否则只要找到了，那么这个属性就是存在的，从这里可以看出<code>JS</code>对象和上级的关系就像一条链条一样，这个称之为原型链；</li></ol><h5 id="三-new操作符的工作原理"><a href="#三-new操作符的工作原理" class="headerlink" title="三. new操作符的工作原理"></a>三. new操作符的工作原理</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = &#123;&#125;</span><br><span class="line">    t.prototype = func.prototype</span><br><span class="line">    <span class="keyword">var</span> o = t</span><br><span class="line">    <span class="keyword">var</span> k =func.call(o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> k === <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent1 = newObj(Parent)等价于<span class="keyword">new</span>操作</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>一个新对象被创建，它继承自func.prototype。</span><br><span class="line"><span class="number">2.</span>构造函数func 被执行，执行的时候，相应的参数会被传入，同时上下文（<span class="keyword">this</span>） 会被指定为这个新实例。</span><br><span class="line"><span class="number">3.</span>如果构造函数返回了一个新对象，那么这个对象会取代整个<span class="keyword">new</span>出来的结果，如果构造函数没有返回对象，</span><br><span class="line">那么<span class="keyword">new</span>出来的结果为步骤<span class="number">1</span>创建的对象。</span><br></pre></td></tr></table></figure><h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h4><h5 id="一-构造函数实现继承（构造继承）"><a href="#一-构造函数实现继承（构造继承）" class="headerlink" title="一.构造函数实现继承（构造继承）"></a>一.构造函数实现继承（构造继承）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent1'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);<span class="comment">//apply</span></span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'parent2'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.id = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child1.name)<span class="comment">//parent1</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.id)<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码看完继承方式2，再回过头来看</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.play[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(child2.play)<span class="comment">//[1,2,3]</span></span><br><span class="line"></span><br><span class="line">从上面构造继承的代码可以看出，构造继承实现了继承，</span><br><span class="line">打印出来父级的name属性，但是实例对象并没有访问到父级原型上面到属性；</span><br></pre></td></tr></table></figure><h5 id="二-原型链实现继承"><a href="#二-原型链实现继承" class="headerlink" title="二.原型链实现继承"></a>二.原型链实现继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'child'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Parent.prototype.id = <span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();    </span><br><span class="line"><span class="built_in">console</span>.log(child1.name)<span class="comment">//parent1</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.id)<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">从这里可以看出，原型继承弥补了构造继承到缺点，继承了原型上到属性;</span><br><span class="line">但是下面再做一个操作：</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.play[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(child2.play)<span class="comment">//[2,2,3]</span></span><br><span class="line">这里我只是改变了实例对象child1到play数组，但是实例打印实例对象child2到paly数组，发现也跟着变化</span><br><span class="line">了，所以可以得出结论，原型链继承引用类型到属性，在所有实例对象上面改变该属性，所有实例对象该属性都会</span><br><span class="line">变化，这样肯定就存在问题，现在我们回到继承方式<span class="number">1</span>（构造继承），会发现构造继承不会存在这个问题，所以</span><br><span class="line">其实构造继承和原型链继承完全可以互补，由此我们引入第三种继承方式；</span><br><span class="line"></span><br><span class="line">额外解释：这里通过一个原型链继承，我们再来回顾一下对原型链的理解，上面代码，我们进行了一个操作：</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">这个操作把父类的实例赋值给子类的原型，然后结合上面原型链的关系图，我们再来理一下（为了阅读方便，复</span><br><span class="line">制上图到此处）：</span><br></pre></td></tr></table></figure><h5 id="三-组合继承"><a href="#三-组合继承" class="headerlink" title="三.组合继承"></a>三.组合继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent1'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);<span class="comment">//apply</span></span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'parent2'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Parent.prototype.id = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child1.name)<span class="comment">//parent1</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.id)<span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.play[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(child2.play)<span class="comment">//[1,2,3]</span></span><br><span class="line"></span><br><span class="line">从上面代码可以看出，组合继承就是把构造继承和原型链继承组合在一起，把他们的优势互补，从而弥补了各自的</span><br><span class="line">缺点；那么组合继承就完美了吗？我们继续思考，从代码中可以发现，我们调用了两次Parent函数，一次是</span><br><span class="line"><span class="keyword">new</span> Parent()，一次是Parent.call(<span class="keyword">this</span>)，是否可以优化呢？我们引入第四种继承方式；</span><br></pre></td></tr></table></figure><h5 id="四-组合继承（优化）"><a href="#四-组合继承（优化）" class="headerlink" title="四.组合继承（优化）"></a>四.组合继承（优化）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent1'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);<span class="comment">//apply</span></span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'parent2'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = Parent.prototype;</span><br><span class="line">Child.prototype.constructor = Child<span class="comment">//这里改变了</span></span><br><span class="line">Parent.prototype.id = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child1.name)<span class="comment">//parent1</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.id)<span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.play[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(child2.play)<span class="comment">//[1,2,3]</span></span><br><span class="line"></span><br><span class="line">现在我们打印</span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype.constructor)<span class="comment">//Child</span></span><br><span class="line">这里就解决了问题，但是我们继续打印</span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.constructor)<span class="comment">//Child</span></span><br><span class="line">发现父类的构造器也出现了紊乱，所有我们通过一个中间值来解决这个问题，最终版本为：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent1'</span></span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);<span class="comment">//apply</span></span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'parent2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = obj;</span><br><span class="line"><span class="comment">//上面三行代码也可以简化成Child.prototype = Object.create(Parent.prototype);</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype.constructor)<span class="comment">//Child</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.constructor)<span class="comment">//Parent</span></span><br><span class="line">用一个中间obj，完美解决了这个问题</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS中原型链与继承&quot;&gt;&lt;a href=&quot;#JS中原型链与继承&quot; class=&quot;headerlink&quot; title=&quot;JS中原型链与继承&quot;&gt;&lt;/a&gt;&lt;code&gt;JS&lt;/code&gt;中原型链与继承&lt;/h3&gt;&lt;h4 id=&quot;1-原型链&quot;&gt;&lt;a href=&quot;#1-原型链&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—Symbol</title>
    <link href="http://yoursite.com/2020/02/07/ES6%E2%80%94Symbol/"/>
    <id>http://yoursite.com/2020/02/07/ES6%E2%80%94Symbol/</id>
    <published>2020-02-07T07:52:20.948Z</published>
    <updated>2020-02-07T08:19:46.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6—Symbol"><a href="#ES6—Symbol" class="headerlink" title="ES6—Symbol"></a>ES6—Symbol</h3><blockquote><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p></blockquote><h4 id="1-Symbol-值通过-Symbol-函数生成，使用-typeof，结果为-quot-symbol-quot"><a href="#1-Symbol-值通过-Symbol-函数生成，使用-typeof，结果为-quot-symbol-quot" class="headerlink" title="1.  Symbol 值通过 Symbol 函数生成，使用 typeof，结果为 &quot;symbol&quot;"></a>1.  <code>Symbol</code> 值通过 <code>Symbol</code> 函数生成，使用 <code>typeof</code>，结果为 <code>&quot;symbol&quot;</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure><h4 id="2-Symbol-函数前不能使用-new-命令，否则会报错。这是因为生成的-Symbol是一个原始类型的值，不是对象。"><a href="#2-Symbol-函数前不能使用-new-命令，否则会报错。这是因为生成的-Symbol是一个原始类型的值，不是对象。" class="headerlink" title="2. Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol是一个原始类型的值，不是对象。"></a>2. <code>Symbol</code> 函数前不能使用 <code>new 命令</code>，否则会报错。这是因为生成的 <code>Symbol</code>是一个原始类型的值，不是对象。</h4><h4 id="3-instanceof-的结果为-false"><a href="#3-instanceof-的结果为-false" class="headerlink" title="3. instanceof 的结果为 false"></a>3. <code>instanceof</code> 的结果为 false</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="4-Symbol-函数可以接受一个字符串作为参数，表示对-Symbol-实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分"><a href="#4-Symbol-函数可以接受一个字符串作为参数，表示对-Symbol-实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分" class="headerlink" title="4. Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分"></a>4. <code>Symbol</code> 函数可以接受一个字符串作为参数，表示对 <code>Symbol</code> 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1); <span class="comment">// Symbol(foo)</span></span><br></pre></td></tr></table></figure><h4 id="5-如果-Symbol-的参数是一个对象，就会调用该对象的-toString-方法，将其转为字符串，然后才生成一个-Symbol-值。"><a href="#5-如果-Symbol-的参数是一个对象，就会调用该对象的-toString-方法，将其转为字符串，然后才生成一个-Symbol-值。" class="headerlink" title="5. 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。"></a>5. 如果 <code>Symbol</code> 的参数是一个对象，就会调用该对象的 <code>toString</code> 方法，将其转为字符串，然后才生成一个 Symbol 值。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line"><span class="built_in">console</span>.log(sym); <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure><h4 id="6-Symbol-函数的参数只是表示对当前-Symbol-值的描述，相同参数的-Symbol-函数的返回值是不相等的"><a href="#6-Symbol-函数的参数只是表示对当前-Symbol-值的描述，相同参数的-Symbol-函数的返回值是不相等的" class="headerlink" title="6. Symbol 函数的参数只是表示对当前 Symbol 值的描述，相同参数的 Symbol 函数的返回值是不相等的"></a>6. <code>Symbol</code> 函数的参数只是表示对当前 <code>Symbol</code> 值的描述，相同参数的 <code>Symbol</code> 函数的返回值是不相等的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="7-Symbol-值不能与其他类型的值进行运算，会报错"><a href="#7-Symbol-值不能与其他类型的值进行运算，会报错" class="headerlink" title="7. Symbol 值不能与其他类型的值进行运算，会报错"></a>7. <code>Symbol</code> 值不能与其他类型的值进行运算，会报错</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"your symbol is "</span> + sym); <span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure><h4 id="8-Symbol-值可以显式转为字符串"><a href="#8-Symbol-值可以显式转为字符串" class="headerlink" title="8. Symbol 值可以显式转为字符串"></a>8. <code>Symbol</code> 值可以显式转为字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(sym)); <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString()); <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><h4 id="9-Symbol-值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性"><a href="#9-Symbol-值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性" class="headerlink" title="9. Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性"></a>9. <code>Symbol</code> 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a[mySymbol]); <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><h4 id="10-Symbol作为属性名，该属性不会出现在-for-in、for-of-循环中，也不会被-Object-keys-、Object-getOwnPropertyNames-、JSON-stringify-返回。但是，它也不是私有属性，有一个-Object-getOwnPropertySymbols-方法，可以获取指定对象的所有-Symbol-属性名。"><a href="#10-Symbol作为属性名，该属性不会出现在-for-in、for-of-循环中，也不会被-Object-keys-、Object-getOwnPropertyNames-、JSON-stringify-返回。但是，它也不是私有属性，有一个-Object-getOwnPropertySymbols-方法，可以获取指定对象的所有-Symbol-属性名。" class="headerlink" title="10. Symbol作为属性名，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。"></a>10. <code>Symbol</code>作为属性名，该属性不会出现在 <code>for...in</code>、<code>for...of</code> 循环中，也不会被 <code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols</code> 方法，可以获取指定对象的所有 <code>Symbol</code> 属性名。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols);</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><h4 id="11-如果我们希望使用同一个-Symbol-值，可以使用-Symbol-for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的-Symbol值。如果有，就返回这个-Symbol-值，否则就新建并返回一个以该字符串为名称的-Symbol-值。"><a href="#11-如果我们希望使用同一个-Symbol-值，可以使用-Symbol-for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的-Symbol值。如果有，就返回这个-Symbol-值，否则就新建并返回一个以该字符串为名称的-Symbol-值。" class="headerlink" title="11. 如果我们希望使用同一个 Symbol 值，可以使用 Symbol.for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。"></a>11. 如果我们希望使用同一个 <code>Symbol</code> 值，可以使用 <code>Symbol.for</code>。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code>值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建并返回一个以该字符串为名称的 <code>Symbol</code> 值。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="12-Symbol-keyFor-方法返回一个已登记的-Symbol-类型值的-key"><a href="#12-Symbol-keyFor-方法返回一个已登记的-Symbol-类型值的-key" class="headerlink" title="12. Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key"></a>12. <code>Symbol.keyFor</code> 方法返回一个已登记的 <code>Symbol</code> 类型值的 <code>key</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)); <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2) ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6—Symbol&quot;&gt;&lt;a href=&quot;#ES6—Symbol&quot; class=&quot;headerlink&quot; title=&quot;ES6—Symbol&quot;&gt;&lt;/a&gt;ES6—Symbol&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;ES6 引入了一种新的原始数据类型 Symbol，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—中this,apply,call,bind使用</title>
    <link href="http://yoursite.com/2020/02/07/JavaScript%E2%80%94%E4%B8%ADthis,apply,call,bind%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/07/JavaScript%E2%80%94%E4%B8%ADthis,apply,call,bind%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-07T07:02:08.907Z</published>
    <updated>2020-02-07T07:52:09.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS中this-apply-call-bind使用"><a href="#JS中this-apply-call-bind使用" class="headerlink" title="JS中this,apply,call,bind使用"></a><code>JS</code>中<code>this</code>,<code>apply</code>,<code>call</code>,<code>bind</code>使用</h3><ul><li><h5 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h5></li></ul><p>this 代表<code>函数</code>运行时的环境。注意是函数，是函数，还有就是<code>运行时</code>!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p>当 hello 函数执行时，在函数内部有个变量 this,代表这个函数运行环境，上述函数在全局环境下且在浏览器环境下运行，那么这个 this 就指向 window,这个比较好理解。但是许多现在许多 js 框架的设计都是使用<code>构造函数</code>方式设计的,例如下面构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Dog(<span class="string">"阿黄"</span>,<span class="string">"黄色"</span>)</span><br></pre></td></tr></table></figure><p>构造函数首先函数名称<code>首字母都会大写</code>，其次都会使用一个 <code>new</code> 来构造一个实例,new 的时候 构造函数就会运行一次，这个时候构造函数里的this就指向这个实例对象</p><p>上述构造函数只是实现了一些属性，其实更多的时候构造函数内部应该根据传入的值来实现一些方法，从而体现良好的封装性。例如使得上述狗类增加一个方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span> dog ,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ahuang = <span class="keyword">new</span> Dog(<span class="string">"阿黄"</span>,<span class="string">"黄色"</span>)</span><br><span class="line">ahuang.say() <span class="comment">// I am a 黄色 dog ,my name is 阿黄</span></span><br></pre></td></tr></table></figure><p>首先先实例出来一个对象 <code>ahuang</code>,再调用 <code>ahuang</code> 的 say 方法,say 方法内部可以获取到 color 和 name.</p><p>现在稍作改动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span> dog ,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ahuang = <span class="keyword">new</span> Dog(<span class="string">"阿黄"</span>, <span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">let</span> a = ahuang.say;</span><br><span class="line">a(); <span class="comment">// I am a undefined dog ,my name is</span></span><br></pre></td></tr></table></figure><p>a 变量只是获取了<code>ahuang</code>的 say 方法定义，还没有执行，此时的 a 定于在全局，如果直接这样执行，那么say方法的this自然也就指向了全局的 window 了，由于全局上没有color和name,所以就成 undefined了</p><p>其实我的理解是：函数一个工具和机器，只负责执行，可以理解为函数独立于对象，犹如一个榨汁机，如果放入橙子，运行时自然就会榨出橙汁，如果放入苹果，自然就会榨出苹果汁。这里苹果和橙子就是运行环境。</p><p>对于给定什么环境运行函数，就可能产生不同结果，这样虽然比较自由，但过分自由也会导致一些问题产生，例如上述 Dog 的 say 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span> dog ,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这个方法只有运行于狗这个对象才有意义，放在全局虽然也能运行，但却失去了这个方法的意义。 所以需要一种机制能够始终使得这个方法能够在狗对象中运行。</p><h5 id="方案一：采用箭头函数来定义"><a href="#方案一：采用箭头函数来定义" class="headerlink" title="方案一：采用箭头函数来定义"></a>方案一：采用箭头函数来定义</h5><p>箭头函数绑定了运行环境，即定义在哪个对象内，则这个箭头函数内部 this 始终为这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span> dog ,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ahuang = <span class="keyword">new</span> Dog(<span class="string">"阿黄"</span>,<span class="string">"黄色"</span>)</span><br><span class="line"><span class="keyword">let</span> a = ahuang.say</span><br><span class="line">a() <span class="comment">// I am a 黄色 dog ,my name is 阿黄</span></span><br></pre></td></tr></table></figure><p>上述函数，即使a在全局定义，但是 say 是箭头函数定义的，里面 this 依然指向 <code>ahuang.</code></p><h5 id="方案二-使用-call-或者-apply-来实现。"><a href="#方案二-使用-call-或者-apply-来实现。" class="headerlink" title="方案二 使用 call 或者 apply 来实现。"></a>方案二 使用 call 或者 apply 来实现。</h5><ul><li><h5 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h5><p>call和 apply 方法功能是一样的，只是传入的参数形式不一样，作用都是绑定（劫持）一个特定的执行环境：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func.call(<span class="keyword">this</span>, arg1, arg2,...);</span><br><span class="line">func.apply(<span class="keyword">this</span>, [arg1, arg2]);</span><br></pre></td></tr></table></figure><p>call 第一个参数为执行环境，其余参数为 <code>func</code>的参数,可以有无数个参数，而apply只有两个参数，第一个为执行环境，第二个为其余数组，通过一个数组来传递</p><p>例如上述狗的构造函数也可以使用call来实现箭头函数效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span> dog ,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ahuang = <span class="keyword">new</span> Dog(<span class="string">"阿黄"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">let</span> b = ahuang.say;</span><br><span class="line">b.call(ahuang);<span class="comment">// 30 I am a 黄色 dog ,my name is 阿黄</span></span><br></pre></td></tr></table></figure><h5 id="使用call-和-apply-还有一些常用的应用"><a href="#使用call-和-apply-还有一些常用的应用" class="headerlink" title="使用call 和 apply 还有一些常用的应用"></a>使用call 和 apply 还有一些常用的应用</h5><ol><li><p>求数组最大值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="built_in">Math</span>.max(...arr)</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,arr) <span class="comment">// 巧妙地利用了第二个参数为数组特征</span></span><br></pre></td></tr></table></figure></li><li><p>判断数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p>bind 和 call，apply 也有相似之处，bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span> dog ,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ahuang = <span class="keyword">new</span> Dog(<span class="string">"阿黄"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="comment">// 使用bind后b返回的是一个函数，这个函数内的this永远是ahuang了</span></span><br><span class="line"><span class="keyword">let</span> b = ahuang.say.bind(ahuang); </span><br><span class="line">b(); <span class="comment">// I am a 黄色 dog ,my name is 阿黄</span></span><br></pre></td></tr></table></figure><p>可见 bind 绑定执行环境是<code>静态</code>的，关键是在<code>定义时</code>就可以绑定，而不是像 call 那样需要调用时去绑定.有点类似于箭头函数。</p><h5 id="bind-一般有几个经典的应用场景："><a href="#bind-一般有几个经典的应用场景：" class="headerlink" title="bind 一般有几个经典的应用场景："></a>bind 一般有几个经典的应用场景：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>匿名的回调函数里面 this 一般为指向 window 假如我们要在这个函数内用到一些其他对象的值，则可以通过bind来改变回调函数的值，以<code>Vue</code>框架为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      height:<span class="number">768</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.height = <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    &#125;).bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果不绑定this,则回调函数内this为 window ,显然读取不到<code>this.height</code>,当然还可以使用箭头函数或者声明一个中间变量来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line">   <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,()=&gt;&#123;</span><br><span class="line">     <span class="keyword">this</span>.height = <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">// 或者</span></span><br><span class="line">   <span class="keyword">let</span> _this =<span class="keyword">this</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     _this.height = <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以在 <code>Vue</code>框架内建议多用箭头函数来定义，<code>forEach</code>,<code>map</code>等方法也是如此</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><blockquote><p>关于call、bind实现原理</p></blockquote><ul><li><h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><p>例如有个榨汁机现在在榨橙汁，现在我们想让榨汁机在苹果的环境中运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">榨汁机.call(<span class="string">"苹果"</span>)</span><br></pre></td></tr></table></figure><p>调用 call 时会传入苹果对象，我们需要在苹果对象上增加榨汁机的方法，再执行一次，执行完毕后再把原属于榨汁机的方法给删掉即可！虽然有点牵强，但实际就是这么干的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments];</span><br><span class="line">  <span class="keyword">let</span> ctx = args.length &gt; <span class="number">0</span> ? args.shift() : <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="built_in">Symbol</span>(); <span class="comment">// 生成一个唯一值</span></span><br><span class="line">  <span class="comment">// 在被劫持者对象属性中加入这个属性</span></span><br><span class="line">  ctx[s] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result = ctx[s](...args);</span><br><span class="line">  <span class="keyword">delete</span> ctx[s];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="bind-1"><a href="#bind-1" class="headerlink" title="bind"></a>bind</h5><p>bind 返回的是一个函数,或者说闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments]</span><br><span class="line">  <span class="keyword">let</span> ctx = args.length&gt;<span class="number">0</span> ? args.shift() : <span class="built_in">window</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="built_in">Symbol</span>() <span class="comment">// 生成一个唯一值</span></span><br><span class="line">  <span class="comment">// 在被劫持者对象属性中加入这个属性</span></span><br><span class="line">  ctx[s] = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = ctx[s](...args) <span class="comment">// 定义了在特定的上下文运行的结果，当执行时就能得到这个特定上下文的结果。</span></span><br><span class="line">    <span class="keyword">delete</span> ctx[s]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS中this-apply-call-bind使用&quot;&gt;&lt;a href=&quot;#JS中this-apply-call-bind使用&quot; class=&quot;headerlink&quot; title=&quot;JS中this,apply,call,bind使用&quot;&gt;&lt;/a&gt;&lt;code&gt;JS&lt;/c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—Iterator的理解</title>
    <link href="http://yoursite.com/2020/02/06/ES6%E2%80%94Iterator%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/02/06/ES6%E2%80%94Iterator%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-02-06T11:11:47.611Z</published>
    <updated>2020-02-08T08:42:11.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6—Iterator的理解"><a href="#ES6—Iterator的理解" class="headerlink" title="ES6—Iterator的理解"></a>ES6—<code>Iterator</code>的理解</h3><blockquote><p><code>Iterator</code>可以说是ES6内相当重大的一个特性</p></blockquote><h4 id="1-从一个变量说起"><a href="#1-从一个变量说起" class="headerlink" title="1. 从一个变量说起"></a>1. 从一个变量说起</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'红'</span>, <span class="string">'绿'</span>, <span class="string">'蓝'</span>];</span><br></pre></td></tr></table></figure><p>如果要获取它的每一项数据，可以使用普通的<code>for</code>循环或者<code>forEach</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="当变量是字符串的时候"><a href="#当变量是字符串的时候" class="headerlink" title="当变量是字符串的时候"></a>当变量是字符串的时候</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'1234567890'</span>;</span><br></pre></td></tr></table></figure><p>可以使用<code>for...in</code>,也可以使用<code>for</code>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">in</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者转换成数组</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(str);</span><br></pre></td></tr></table></figure><p><code>for in</code> 不是用来获取数据的，他会遍历对象上所有可枚举的属性，包括自身的和原型链上的</p><h5 id="看下面给定的一个map对象，然后输出它的每一项数据"><a href="#看下面给定的一个map对象，然后输出它的每一项数据" class="headerlink" title="看下面给定的一个map对象，然后输出它的每一项数据"></a>看下面给定的一个<code>map</code>对象，然后输出它的每一项数据</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'zhu'</span>, <span class="string">'18'</span>);</span><br><span class="line">map.set(<span class="string">'zhang'</span>, <span class="string">'20'</span>);</span><br><span class="line">map.set(<span class="string">'wang'</span>, <span class="string">'23'</span>);</span><br></pre></td></tr></table></figure><p>用<code>map</code>方法中的<code>forEach</code>循环遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val, key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h5><p>在上一步几个简单的问题中，我们的操作都是获得他们的每一项数据。</p><p>当然方法有很多种，实现方式也有很多，<code>for 循环</code>，<code>forEach</code>，<code>for in</code> 等</p><p>但是有没有发现一个问题，或者我们站在一个更高的维度去看待，其实这些方法都不能通用，也就是说上面的这几种集合数据不能使用统一的遍历方法来进行数据获取</p><h4 id="2-ES6-for-of循环"><a href="#2-ES6-for-of循环" class="headerlink" title="2. ES6 for...of循环"></a>2. ES6 <code>for...of</code>循环</h4><blockquote><p>这个可以对不同数据结构进行统一遍历的方式就是 <code>es6</code>的 <code>for of</code> 循环</p><p><code>for of</code> 循环 和 古老的<code>for 循环</code>很像呀。不就是个新增语法么</p></blockquote><h5 id="并不是所有的对象都能使用-for-of，只有实现了Iterator接口的对象才能够使用-for-of-来进行遍历取值"><a href="#并不是所有的对象都能使用-for-of，只有实现了Iterator接口的对象才能够使用-for-of-来进行遍历取值" class="headerlink" title="并不是所有的对象都能使用 for of，只有实现了Iterator接口的对象才能够使用 for of 来进行遍历取值"></a>并不是所有的对象都能使用 <code>for of</code>，只有实现了<code>Iterator</code>接口的对象才能够使用 <code>for of</code> 来进行遍历取值</h5><h4 id="3-Iterator-迭代器"><a href="#3-Iterator-迭代器" class="headerlink" title="3. Iterator 迭代器"></a>3. <code>Iterator</code> 迭代器</h4><blockquote><p><code>Iterator</code> 是一种接口，目的是为不同的数据结构提供统一的数据访问机制。也可以理解为 <code>Iterator</code> 接口主要为 <code>for of</code> 服务的，供<code>for...of</code>进行消费</p></blockquote><h5 id="既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？"><a href="#既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？" class="headerlink" title="既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？"></a>既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？</h5><blockquote><p>因为 <code>javascript</code> 语言里没有接口的概念，这里我们可以理解成它是一种特殊的对象 - 迭代器对象，返回此对象的方法叫做迭代器方法</p></blockquote><p>首先他作为一个对象，此对象具有一个<code>next</code>方法，每次调用 <code>next</code> 方法都会返回一个结果值。</p><p>这个结果值是一个 <code>object</code>，包含两个属性，<code>value</code> 和 <code>done</code>。</p><p><code>value</code>表示具体的返回值，<code>done</code> 是布尔类型的，表示集合是否遍历完成或者是否后续还有可用数据，没有可用数据则返回 <code>true</code>，否则返回 <code>false</code>。</p><p>另外内部会维护一个指针，用来指向当前集合的位置，每调用一次 <code>next</code> 方法，指针都会向后移动一个位置(可以想象成数组的索引)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIterator</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> done = (i &gt;= list.length);</span><br><span class="line">      <span class="keyword">let</span> value = !done ? list[i++] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = getIterator([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;value: "a", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;value: "b", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;value: "c", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure><p>上面代码便是根据迭代器的基本概念衍生出来的一个模拟实现</p><ul><li><code>getIterator</code>方法返回一个对象 - 可迭代对象</li><li>对象具有一个<code>next</code> 方法，<code>next</code> 方法内部通过闭包来保存指针 <code>i</code> 的值，每次调用 <code>next</code> 方法 <code>i</code> 的值都会<code>+1</code></li><li>然后根据 <code>i</code> 的值从数组内取出数据作为 <code>value</code>，然后通过索引判断得到 <code>done</code>的值</li><li>当 <code>i=3</code>的时候，超过数组的最大索引，无可用数据返回，此时done 为<code>true</code>，遍历完成</li></ul><h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p>到这里我们已经大概了解了 <code>Iterator</code>, 以及如何创建一个迭代器对象。但是它和 <code>for of</code> 有什么关系呢？</p><h4 id="4-for-of-运行机制"><a href="#4-for-of-运行机制" class="headerlink" title="4. for of 运行机制"></a>4. for of 运行机制</h4><blockquote><p>当 <code>for of</code>执行的时候，循环过程中引擎就会自动调用这个<code>对象上的迭代器方法</code>， 依次执行迭代器对象的 <code>next</code> 方法,将 <code>next</code> 返回值赋值给 <code>for of</code> 内的变量，从而得到具体的值</p></blockquote><h5 id="实现可迭代对象"><a href="#实现可迭代对象" class="headerlink" title="实现可迭代对象"></a>实现可迭代对象</h5><blockquote><p>对象上怎么会有迭代器方法呢？</p></blockquote><p><code>ES6</code>里规定，只要在对象的属性上部署了<code>Iterator</code>接口，具体形式为给对象添加<code>Symbol.iterator</code>属性，此属性指向一个迭代器方法，这个迭代器会返回一个特殊的对象 - 迭代器对象。</p><p>而部署这个属性并且实现了迭代器方法后的对象叫做<code>可迭代对象</code></p><p>此时，这个对象就是可迭代的，也就是可以被 <code>for of</code> 遍历</p><blockquote><p>Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值。</p></blockquote><p>例如：普通对象是不能被 <code>for of</code> 遍历的，直接使用会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错 obj is not iterable</span></span><br></pre></td></tr></table></figure><p>如何让一个对象变成可迭代对象，按照协议也就是规定来实现即可</p><h5 id="iterableObj-对象上部署-Symbol-iterator属性，然后为其创建一个迭代器方法，迭代器的规则上面我们已经说过啦"><a href="#iterableObj-对象上部署-Symbol-iterator属性，然后为其创建一个迭代器方法，迭代器的规则上面我们已经说过啦" class="headerlink" title="iterableObj 对象上部署 Symbol.iterator属性，然后为其创建一个迭代器方法，迭代器的规则上面我们已经说过啦"></a><code>iterableObj</code> 对象上部署 <code>Symbol.iterator</code>属性，然后为其创建一个迭代器方法，迭代器的规则上面我们已经说过啦</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObj = &#123;</span><br><span class="line">  items: [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> done = (i &gt;= self.items.length);</span><br><span class="line">        <span class="keyword">let</span> value = !done ? self.items[i++] : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          done: done,</span><br><span class="line">          value: value</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历它</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterableObj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">//100,200,300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个对象就是可迭代对象了，可以被 <code>for of</code> 消费了</p><h4 id="5-Iterator-原生应用场景"><a href="#5-Iterator-原生应用场景" class="headerlink" title="5. Iterator 原生应用场景"></a>5. <code>Iterator</code> 原生应用场景</h4><p>再回到最开始使用 <code>for of</code> 来进行遍历<strong>字符串、数组、map</strong>，我们并没有为他们部署<code>Iterator</code>接口，仍然可以使用 <code>for of</code> 遍历。</p><p>这是因为在 <code>ES6</code>中有些对象已经默认部署了此接口，不需要做任何处理，就可以使用 <code>for of</code> 来进行遍历取值。</p><ol><li><p>数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iteratorObj = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj); <span class="comment">// Object [Array Iterator] &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next()); <span class="comment">// &#123; value: 100, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next()); <span class="comment">// &#123; value: 200, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next()); <span class="comment">// &#123; value: 300, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><p>因为字符串本身的值是有序的，并且具有类数组的特性，支持通过索引访问，所以也默认部署了<code>iterator</code>接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strIteratorObj = str[<span class="built_in">Symbol</span>.iterator]();<span class="comment">//得到迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(strIteratorObj.next()); <span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(strIteratorObj.next()); <span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(strIteratorObj.next()); <span class="comment">// &#123; value: 'c', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(strIteratorObj.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>arguments</code>类数组</p><p>函数内的<code>arguments</code> 是一个类数组，他也支持 <code>for of</code>，因为他内部也部署了<code>Iterator</code> 接口</p><p>我们都知道对象是默认没有部署这个接口的，所以<code>arguments</code>这个属性没有在原型上，而在对象自身的属性上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> obj = <span class="built_in">arguments</span>[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// 得到可迭代对象</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.hasOwnProperty(<span class="built_in">Symbol</span>.iterator)); <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// [0, 1, 3]</span></span><br><span class="line">   <span class="built_in">console</span>.log(obj.next()); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>总结来说，已默认部署 Iterator 接口的对象主要包括数组、字符串、Set、Map 、类似数组的对象（比如arguments对象、DOM NodeList 对象）</p></li></ol><h4 id="6-Iterator-另外一个作用"><a href="#6-Iterator-另外一个作用" class="headerlink" title="6. Iterator 另外一个作用"></a>6. <code>Iterator 另外一个作用</code></h4><blockquote><p><code>Iterator</code>除了可以为不同的数据结构提供一种统一的数据访问方式，还有没有发现其他的作用？</p><p>那就是数据可定制性，因为我们可以随意的控制迭代器的 <code>value</code> 值</p></blockquote><p>例如：数组本身就是一个可迭代的，我们可以覆盖它的默认迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 100 200 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己实现</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> done = (i &gt;= self.length);</span><br><span class="line">      <span class="keyword">let</span> value = !done ? self[i++] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象为什么没有默认部署"><a href="#对象为什么没有默认部署" class="headerlink" title="对象为什么没有默认部署"></a>对象为什么没有默认部署</h5><blockquote><p>对象可能有各种属性，不像数组的值是有序的。</p><p>所以遍历的时候根本不知道如何确定他们的先后顺序，所以需要我们根据情况手动实现</p></blockquote><h4 id="7-扩展"><a href="#7-扩展" class="headerlink" title="7. 扩展"></a>7. 扩展</h4><h5 id="for-of-中断"><a href="#for-of-中断" class="headerlink" title="for of 中断"></a><code>for of</code> 中断</h5><p>普通的 <code>for</code> 循环是可以随时中断的，那 <code>for of</code> 是否可以呢？</p><p>答案是肯定的，<code>for of</code>机制兼顾了<code>for</code>和<code>forEach</code>。</p><p>迭代器除了必须<code>next</code> 方法外，还有两个可选的方法 <code>return</code>和<code>throw</code>方法</p><p>如果 <code>for of</code> 循环提前退出，则会自动调用 <code>return</code> 方法，需要注意的是 <code>return</code> 方法必须有返回值，且返回值必须是 一个<code>object</code>。</p><h4 id="8-解构赋值"><a href="#8-解构赋值" class="headerlink" title="8. 解构赋值"></a>8. 解构赋值</h4><blockquote><p>对可迭代对象进行解构赋值的时候，会默认调用<code>Symbol.iterator</code>方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'12345'</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b] = str;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'1'</span>, <span class="string">'11'</span>);</span><br><span class="line">map.set(<span class="string">'2'</span>, <span class="string">'12'</span>);</span><br><span class="line">map.set(<span class="string">'3'</span>, <span class="string">'13'</span>);</span><br><span class="line">map.set(<span class="string">'4'</span>, <span class="string">'14'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [d, e] = map;</span><br><span class="line"><span class="built_in">console</span>.log([...map]);</span><br><span class="line"><span class="built_in">console</span>.log(d, e); <span class="comment">// ["1", "11"] ["2", "12"]</span></span><br></pre></td></tr></table></figure><p><strong>同样如果对一个普通对象进行解构，则会报错。</strong></p><p><strong>因为普通对象不是可迭代对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [d,e]=&#123;<span class="attr">name</span>:<span class="string">'zhang'</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h5 id="从一个自定义的可迭代对象进行解构赋值"><a href="#从一个自定义的可迭代对象进行解构赋值" class="headerlink" title="从一个自定义的可迭代对象进行解构赋值"></a>从一个自定义的可迭代对象进行解构赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObj = &#123;</span><br><span class="line">  items: [<span class="string">'红'</span>, <span class="string">'绿'</span>, <span class="string">'蓝'</span>],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> done = (i &gt;= self.items.length);</span><br><span class="line">        <span class="keyword">let</span> value = !done ? self.items[i++] : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          done: done,</span><br><span class="line">          value: value</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [d, e] = iterableObj;</span><br><span class="line"><span class="built_in">console</span>.log(d, e); <span class="comment">//红 绿</span></span><br></pre></td></tr></table></figure><p><strong>解构赋值的变量的值就是迭代器对象的 next 方法的返回值，且是按顺序返回</strong></p><h4 id="9-扩展运算符"><a href="#9-扩展运算符" class="headerlink" title="9. 扩展运算符"></a>9. 扩展运算符</h4><blockquote><p>扩展运算符的执行(…)也会默认调用它的<code>Symbol.iterator</code>方法，可以将当前迭代对象转换为数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'1234'</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...str]); <span class="comment">//[1,2,3,4]  转换为数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//map 对象</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">]);</span><br><span class="line">[...map] <span class="comment">//[[1,2],[3,4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set 对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line">[...<span class="keyword">set</span>] //[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>普通对象是不可以用扩展运算符的</strong></p><h4 id="10-yield-关键字"><a href="#10-yield-关键字" class="headerlink" title="10. yield* 关键字"></a>10. <code>yield*</code> 关键字</h4><blockquote><p>yield*后面跟的是一个可遍历的结构，执行时也会调用迭代器函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="11-判断对象是否可迭代"><a href="#11-判断对象是否可迭代" class="headerlink" title="11. 判断对象是否可迭代"></a>11. 判断对象是否可迭代</h4><blockquote><p>既然可迭代对象的规则必须在对象上部署<code>Symbol.iterator</code>属性，那么我们基本上就可以通过此属来判断对象是否为可迭代对象，然后就可以知道是否能使用 <code>for of</code> 取值了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'abcdefg'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>())); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>())); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p><code>ES6</code>的出现带来了很多新的数据结构，比如 <code>Map</code> ,<code>Set</code> ，所以为了数据获取的方便，增加了一种统一获取数据的方式 <code>for of</code> 。 而 <code>for of</code> 执行的时候引擎会自动调用对象的迭代器来取值。</p><p>不是所有的对象都支持这种方式，必须是实现了<code>Iterator</code>接口的才可以，这样的对象我们称他们为可迭代对象。</p><p>迭代器实现方式根据可迭代协议，迭代器协议实现即可。</p><p>除了统一数据访问方式，还可以自定义得到的数据内容，随便怎样，只要是你需要的。</p><p>迭代器是一个方法， 用来返回迭代器对象。</p><p>可迭代对象是部署了 <code>Iterator</code> 接口的对象，同时拥有正确的迭代器方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6—Iterator的理解&quot;&gt;&lt;a href=&quot;#ES6—Iterator的理解&quot; class=&quot;headerlink&quot; title=&quot;ES6—Iterator的理解&quot;&gt;&lt;/a&gt;ES6—&lt;code&gt;Iterator&lt;/code&gt;的理解&lt;/h3&gt;&lt;blockqu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—Set和Map数据结构下</title>
    <link href="http://yoursite.com/2020/02/06/ES6%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/"/>
    <id>http://yoursite.com/2020/02/06/ES6%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8B/</id>
    <published>2020-02-06T08:52:51.512Z</published>
    <updated>2020-02-06T11:06:15.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6的Set和Map数据结构下"><a href="#ES6的Set和Map数据结构下" class="headerlink" title="ES6的Set和Map数据结构下"></a>ES6的Set和Map数据结构下</h3><h4 id="2-字典："><a href="#2-字典：" class="headerlink" title="2. 字典："></a>2. 字典：</h4><p>在数据结构还有一种结构叫做<strong>字典</strong>，它就是实现基于ES6中的Map类的结构</p><p>那么集合又和字典有什么区别呢：</p><ul><li>共同点：集合、字典可以存储不重复的值</li><li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li></ul><p>Map其实的主要用途也是用于存储数据的，相比于Object只提供“字符串—值”的对应，Map提供了“键—值”的对应。也就是说如果你需要“键值对”的数据结构，Map比Object更合适</p><p>下面来看一下基本使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  p: <span class="string">'Hello World'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(o)); <span class="comment">// content</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.has(o)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.delete(o)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.has(o)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>以上是Map的基本使用。</p><h5 id="Map语法"><a href="#Map语法" class="headerlink" title="Map语法"></a>Map语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([iterable])</span><br></pre></td></tr></table></figure><p><code>Iterable</code>参数可以是一个<code>数组</code>或者其他 <code>iterable</code>对象，其元素为键值对<strong><code>(两个元素的数组，例如: [[ 1, &#39;one&#39; ],[ 2, &#39;two&#39; ]])</code></strong>。 每个键值对都会添加到新的 Map。<code>null</code> 会被当做 <code>undefined。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[ <span class="number">1</span>, <span class="string">'one'</span> ],[ <span class="number">2</span>, <span class="string">'two'</span> ]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// Map &#123; 1 =&gt; 'one', 2 =&gt; 'two' &#125;</span></span><br></pre></td></tr></table></figure><p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 个  <code>for...of</code> 循环，在每次迭代后会返回一个形式为<code>[key，value]</code>的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[ <span class="number">1</span>, <span class="string">'one'</span> ],[ <span class="number">2</span>, <span class="string">'two'</span> ]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'key:'</span> + key + <span class="string">','</span> + <span class="string">'value:'</span> + value); <span class="comment">// key:1,value:one key:2,value:two</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Map的属性和方法"><a href="#Map的属性和方法" class="headerlink" title="Map的属性和方法"></a>Map的属性和方法</h5><p>属性：</p><ul><li>size：返回字典所包含的元素个数</li></ul><p>操作方法：</p><ul><li>set(key, val): 向字典中添加新元素</li><li>get(key):通过键值查找特定的数值并返回</li><li>has(key):如果键存在字典中返回true,否则false</li><li>delete(key): 通过键值从字典中移除对应的数据</li><li>clear():将这个字典中的所有元素删除</li></ul><p>遍历方法：</p><ul><li>keys():将字典中包含的所有键名以数组形式返回</li><li>values():将字典中包含的所有数值以数组形式返回</li><li>forEach()：遍历字典的所有成员</li></ul><h5 id="创建一个字典"><a href="#创建一个字典" class="headerlink" title="创建一个字典"></a>创建一个字典</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>创建好了字典这个骨架，那就开始添加一些方法了</p><h5 id="has方法"><a href="#has方法" class="headerlink" title="has方法"></a>has方法</h5><p>首先是has了，因为在set和get里都会用到，实现思路和之前写的集合也很类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="comment">// has(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>实现了has方法后，我们可以来判断字典中是否包含该属性了，继续来实现其他方法</p><h5 id="set和get方法"><a href="#set和get方法" class="headerlink" title="set和get方法"></a>set和get方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="comment">// has(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// set(key, val)方法</span></span><br><span class="line">  <span class="comment">// set相同key时，后面声明的会覆盖前面</span></span><br><span class="line">  <span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">    items[key] = val;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// get(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有key，如果有的话直接返回对应的值</span></span><br><span class="line">    <span class="comment">// 如果读取一个未知的键，则返回undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>set和get方法写好了，再接着搞delete和clear方法</p><h5 id="delete和clear方法"><a href="#delete和clear方法" class="headerlink" title="delete和clear方法"></a>delete和clear方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(key)) &#123;    <span class="comment">// 如果有key值</span></span><br><span class="line">      <span class="keyword">delete</span> items[key];  <span class="comment">// 直接删掉items上对应的属性</span></span><br><span class="line">      <span class="keyword">this</span>.size--;        <span class="comment">// 让size总数减1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clear()方法</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h5 id="遍历方法-keys-values-forEach"><a href="#遍历方法-keys-values-forEach" class="headerlink" title="遍历方法(keys(),values(),forEach())"></a>遍历方法(keys(),values(),forEach())</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys()方法</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// values()方法</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(items);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">Object</span>.values(items)[i];</span><br><span class="line">      fn.call(context, value, key, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h5 id="Map的完整代码"><a href="#Map的完整代码" class="headerlink" title="Map的完整代码"></a>Map的完整代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 记录数量</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// has(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// set(key, val)方法</span></span><br><span class="line">  <span class="comment">// set相同key时，后面声明的会覆盖前面</span></span><br><span class="line">  <span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">      items[key] = val;</span><br><span class="line">      <span class="keyword">this</span>.size++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// get(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有key，如果有的话直接返回对应的值</span></span><br><span class="line">    <span class="comment">// 如果读取一个未知的键，则返回undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// delete(key)方法</span></span><br><span class="line">  <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(key)) &#123;    <span class="comment">// 如果有key值</span></span><br><span class="line">      <span class="keyword">delete</span> items[key];  <span class="comment">// 直接删掉items上对应的属性</span></span><br><span class="line">      <span class="keyword">this</span>.size--;        <span class="comment">// 让size总数减1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clear()方法</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// keys()方法</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// values()方法</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(items);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">Object</span>.values(items)[i];</span><br><span class="line">      fn.call(context, value, key, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Map</span>;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Map</span> = <span class="built_in">require</span>(<span class="string">'./map'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'Jay'</span>, <span class="string">'Jay的值'</span>);</span><br><span class="line">map.set(<span class="string">'true'</span>, <span class="string">'真的'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'Jay'</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// [ 'Jay', 'true' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">// [ 'Jay的值', '真的' ]</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`value=<span class="subst">$&#123;value&#125;</span>,key=<span class="subst">$&#123;key&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// value=Jay的值,key=Jay value=真的,key=true</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// [ 'Jay' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">// [ 'Jay的值' ]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6的Set和Map数据结构下&quot;&gt;&lt;a href=&quot;#ES6的Set和Map数据结构下&quot; class=&quot;headerlink&quot; title=&quot;ES6的Set和Map数据结构下&quot;&gt;&lt;/a&gt;ES6的Set和Map数据结构下&lt;/h3&gt;&lt;h4 id=&quot;2-字典：&quot;&gt;&lt;a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—Set和Map数据结构上</title>
    <link href="http://yoursite.com/2020/02/06/ES6%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/"/>
    <id>http://yoursite.com/2020/02/06/ES6%E2%80%94Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A/</id>
    <published>2020-02-06T06:59:41.575Z</published>
    <updated>2020-02-06T08:52:11.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6的Set和Map数据结构上"><a href="#ES6的Set和Map数据结构上" class="headerlink" title="ES6的Set和Map数据结构上"></a>ES6的Set和Map数据结构上</h3><blockquote><p>Set和Map主要的应用场景在于<strong>数组去重</strong>和<strong>数据存储</strong></p><p>Set是一种叫做<strong>集合</strong>的数据结构，Map是一种叫做<strong>字典</strong>的数据结构</p></blockquote><h4 id="1-集合"><a href="#1-集合" class="headerlink" title="1. 集合"></a>1. 集合</h4><ul><li>集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组</li><li>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值</li><li>Set 本身是一个构造函数，用来生成 Set 数据结构</li><li>这里说的Set其实就是我们所要讲到的集合，先来看下基础用法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);   <span class="comment">// 2 3 5 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>];</span><br><span class="line">[...new <span class="built_in">Set</span>(array)]     <span class="comment">// [1, 2, 4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>首先来看一下ES6中Set类(数据结构)为基础实现的集合</p><h5 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h5><ul><li><p>Set的属性：</p><ul><li>size：返回集合所包含元素的数量</li></ul></li><li><p>Set的方法：</p><ul><li><p>操作方法</p><ul><li>add(value)：向集合添加一个新的项</li><li>delete(value)：从集合中移除一个值</li><li>has(value)：如果值在集合中存在，返回true,否则false</li><li>clear(): 移除集合里所有的项</li></ul></li><li><p>遍历方法</p><ul><li>keys()：返回一个包含集合中所有键的数组</li><li>values()：返回一个包含集合中所有值的数组</li><li>entries：返回一个包含集合中所有键值对的数组</li><li>forEach()：用于对集合成员执行某种操作，没有返回值</li></ul></li></ul></li></ul><h5 id="创建一个集合"><a href="#创建一个集合" class="headerlink" title="创建一个集合"></a>创建一个集合</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params">arr = []</span>) </span>&#123;    <span class="comment">// 可以传入数组</span></span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;  <span class="comment">// 记录集合中成员的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Set</span>;</span><br></pre></td></tr></table></figure><p>这里用<code>{}</code>对象来表示集合，也是因为对象不允许一个键指向两个不同的属性，保证了集合里的元素都是唯一的</p><p>接下来，就需要按照ES6中Set类的实现，添加一些集合的<strong>操作方法</strong>了</p><h5 id="has方法"><a href="#has方法" class="headerlink" title="has方法"></a>has方法</h5><p>首先要实现的是has方法，因为在add和delete等其他方法中都会被调用，下面来看一下它的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// has(val)方法</span></span><br><span class="line">    <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对象都有hasOwnProperty方法，判断是否拥有特定属性</span></span><br><span class="line">        <span class="keyword">return</span> items.hasOwnProperty(val);  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><p>接下来要实现add方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add(val)方法</span></span><br><span class="line"><span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">     items[val] = val;</span><br><span class="line">     <span class="keyword">this</span>.size++;    <span class="comment">// 累加集合成员数量</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于给定的val，可以检测是否存在于集合中</p><ul><li>如果不存在，就添加到集合中，返回true</li><li>如果存在，就直接返回false，不做任何操作</li></ul><h5 id="delete和clear方法"><a href="#delete和clear方法" class="headerlink" title="delete和clear方法"></a>delete和clear方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete(val)方法</span></span><br><span class="line"><span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> items[val];  <span class="comment">// 将items对象上的属性删掉</span></span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// clear方法</span></span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;     <span class="comment">// 直接将集合赋一个空对象即可</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在delete方法中，判断val是否存在于集合中，如果存在就直接从集合中删掉，返回true</p><p>以上完成的都是<strong>操作方法</strong>，下面我们再来实现一下<strong>遍历方法</strong></p><h5 id="keys和values方法"><a href="#keys和values方法" class="headerlink" title="keys和values方法"></a>keys和values方法</h5><p>因为通过ES6对Object的扩展可以轻松实现对应的方法，下面看一下具体实现，上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">Set</span> = <span class="built_in">require</span>(<span class="string">'./set'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(3);</span><br><span class="line"><span class="keyword">set</span>.add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>.keys()); //[ '1', '2', '3' ]</span><br><span class="line">console.log(<span class="keyword">set</span>.values()); //[ 1, 2, 3 ]</span><br><span class="line">console.log(<span class="keyword">set</span>.has(1)); //true</span><br><span class="line">console.log(<span class="keyword">set</span>.delete(1)); //true</span><br><span class="line">console.log(<span class="keyword">set</span>.size); //true</span><br></pre></td></tr></table></figure><p>这里我们看到和ES6中的Set有点区别，因为Object的这几个方法都是按照数值大小，从小到大遍历的数组，具体实现还是有些不同的</p><h5 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h5><p>ES6中Set结构的实例上带的forEach方法，其实和数组的forEach方法很相似，只不过Set结构的键名就是键值，所以第一个参数与第二个参数的值永远都是一样的</p><p>下面就按照实现数组的forEach方法，我们来完成Set的forEach方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      fn.call(context, item, item, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>使用forEach方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Set</span> = <span class="built_in">require</span>(<span class="string">'./set'</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(4);</span><br><span class="line"><span class="keyword">set</span>.add('3');</span><br><span class="line"><span class="keyword">set</span>.forEach((value, key) =&gt; console.log(key + ' : ' + value));  // 1:1, 3:3, 4:4</span><br><span class="line">let arr = <span class="keyword">set</span>.values();     // [ 1, 3, 4 ]</span><br></pre></td></tr></table></figure><p>基本上实现了Set结构的方法，不过，发现一个问题，那就是每次添加一个元素都要add这样写起来确实好麻烦，Set是可以接收一个数组作为参数的，那么把这个也实现一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params">arr = []</span>) </span>&#123; <span class="comment">// 可以传入一个数组</span></span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.size = <span class="number">0</span>; <span class="comment">//记录集合中成员的数量</span></span><br><span class="line">  <span class="comment">// has(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对象都有hasOwnProperty方法，判断是否拥有特定属性</span></span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// add(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">      items[val] = val;</span><br><span class="line">      <span class="keyword">this</span>.size++;    <span class="comment">// 累加集合成员数量</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// delete(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> items[val];  <span class="comment">// 将items对象上的属性删掉</span></span><br><span class="line">      <span class="keyword">this</span>.size--;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clear方法</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;     <span class="comment">// 直接将集合赋一个空对象即可</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// keys()方法</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);  <span class="comment">// 返回遍历集合的所有键名的数组</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// values()方法</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(items);  <span class="comment">// 返回遍历集合的所有键值的数组</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      fn.call(context, item, item, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">val, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.add(val);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Set</span>;</span><br></pre></td></tr></table></figure><p>再看看现在能不能支持传入数组了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Set</span> = <span class="built_in">require</span>(<span class="string">'./set'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).values();</span><br><span class="line"></span><br><span class="line">m = <span class="keyword">new</span> <span class="built_in">Set</span>(arr.map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">new</span> <span class="built_in">Set</span>(arr.filter(<span class="function"><span class="params">x</span> =&gt;</span> x&gt;<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.values());    <span class="comment">// [ 2, 4, 6 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(f.values());    <span class="comment">// [ 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>]).values();</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// [ 1, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure><h5 id="除此之外，Set还可以实现并集-union-交集-intersect-差集-difference"><a href="#除此之外，Set还可以实现并集-union-交集-intersect-差集-difference" class="headerlink" title="除此之外，Set还可以实现并集(union),交集(intersect),差集(difference)"></a>除此之外，Set还可以实现并集(union),交集(intersect),差集(difference)</h5><h5 id="union并集和intersect交集"><a href="#union并集和intersect交集" class="headerlink" title="union并集和intersect交集"></a>union并集和intersect交集</h5><ul><li>并集的数学概念，集合A和集合B的并集，表示为A∪B</li><li>交集的数学概念，集合A和集合B的交集，表示为A∩B</li></ul><p><img src="..%5Cimage%5CSet%5C%E4%BA%A4%E5%B9%B6.png" alt="交并"></p><p>先来实现union方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line">  <span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      union.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    values = other.values();    <span class="comment">// 将values重新赋值为新的集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      union.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> union;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 交集</span></span><br><span class="line">  <span class="keyword">this</span>.intersect = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (other.has(values[i])) &#123;     <span class="comment">// 查看是否也存在于other中</span></span><br><span class="line">        intersect.add(values[i]);   <span class="comment">// 存在的话就像intersect中添加元素</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersect;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>再看下difference差集的实现</p><ul><li><p>差集的数学概念，集合A和集合B的差集，表示为A-B</p><p><img src="..%5Cimage%5CSet%5C%E5%B7%AE%E9%9B%86.png" alt="差集"></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差集</span></span><br><span class="line">  <span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!other.has(values[i])) &#123;    <span class="comment">// 将不存在于other集合中的添加到新的集合中</span></span><br><span class="line">        difference.add(values[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h5 id="Set的完整实现"><a href="#Set的完整实现" class="headerlink" title="Set的完整实现"></a>Set的完整实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params">arr = []</span>) </span>&#123; <span class="comment">// 可以传入一个数组</span></span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.size = <span class="number">0</span>; <span class="comment">//记录集合中成员的数量</span></span><br><span class="line">  <span class="comment">// has(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对象都有hasOwnProperty方法，判断是否拥有特定属性</span></span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// add(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">      items[val] = val;</span><br><span class="line">      <span class="keyword">this</span>.size++;    <span class="comment">// 累加集合成员数量</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// delete(val)方法</span></span><br><span class="line">  <span class="keyword">this</span>.delete = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(val)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> items[val];  <span class="comment">// 将items对象上的属性删掉</span></span><br><span class="line">      <span class="keyword">this</span>.size--;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// clear方法</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = &#123;&#125;;     <span class="comment">// 直接将集合赋一个空对象即可</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// keys()方法</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);  <span class="comment">// 返回遍历集合的所有键名的数组</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// values()方法</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(items);  <span class="comment">// 返回遍历集合的所有键值的数组</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// forEach(fn, context)方法</span></span><br><span class="line">  <span class="keyword">this</span>.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context = this</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = <span class="built_in">Object</span>.keys(items)[i];</span><br><span class="line">      fn.call(context, item, item, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 并集</span></span><br><span class="line">  <span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      union.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    values = other.values();    <span class="comment">// 将values重新赋值为新的集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      union.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> union;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 交集</span></span><br><span class="line">  <span class="keyword">this</span>.intersect = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (other.has(values[i])) &#123;     <span class="comment">// 查看是否也存在于other中</span></span><br><span class="line">        intersect.add(values[i]);   <span class="comment">// 存在的话就像intersect中添加元素</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersect;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 差集</span></span><br><span class="line">  <span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!other.has(values[i])) &#123;    <span class="comment">// 将不存在于other集合中的添加到新的集合中</span></span><br><span class="line">        difference.add(values[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 子集</span></span><br><span class="line">  <span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt; other.size) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!other.has(values[i])) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">val, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.add(val);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Set</span>;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Set</span> = <span class="built_in">require</span>(<span class="string">'./set'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.values()); //[ 1, 2, 3 ]</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.keys());// [ '1', '2', '3' ]</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 3</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.delete(2);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.values()); // [1, 3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 0</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let a = [1, 2, 3];</span><br><span class="line">let b = new Set([4, 3, 2]);</span><br><span class="line">let union = new Set(a).union(b).values();</span><br><span class="line">console.log(union); // [ 1, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let c = new Set([4, 3, 2]);</span><br><span class="line">let intersect = new Set([1, 2, 3]).intersect(c).values();</span><br><span class="line">console.log(intersect); // [2, 3]</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let d = new Set([4, 3, 2]);</span><br><span class="line">let difference = new Set([1, 2, 3]).difference(d).values();</span><br><span class="line">console.log(difference); // [1]</span><br><span class="line"></span><br><span class="line">// 子集</span><br><span class="line">let e = new Set([1, 2, 3, 4]);</span><br><span class="line">let subset = new Set([1, 2, 3]).subset(e);</span><br><span class="line">console.log(subset); // true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ES6的Set和Map数据结构上&quot;&gt;&lt;a href=&quot;#ES6的Set和Map数据结构上&quot; class=&quot;headerlink&quot; title=&quot;ES6的Set和Map数据结构上&quot;&gt;&lt;/a&gt;ES6的Set和Map数据结构上&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;S
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—深浅拷贝</title>
    <link href="http://yoursite.com/2020/02/06/JavaScript%E2%80%94%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/02/06/JavaScript%E2%80%94%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-02-06T06:28:24.796Z</published>
    <updated>2020-02-07T06:06:39.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript深浅拷贝原理与实现"><a href="#JavaScript深浅拷贝原理与实现" class="headerlink" title="JavaScript深浅拷贝原理与实现"></a>JavaScript深浅拷贝原理与实现</h3><blockquote><p>深浅拷贝在我们开发项目中经常使用</p><ul><li>浅拷贝：拷贝的对象的指针，修改内容互相影响</li><li>深拷贝：整个对象拷贝到另一个内存中，修改内容不互相影响</li></ul></blockquote><h5 id="首先明确一下深浅拷贝的定义："><a href="#首先明确一下深浅拷贝的定义：" class="headerlink" title="首先明确一下深浅拷贝的定义："></a>首先明确一下深浅拷贝的定义：</h5><ol><li><p>浅拷贝：</p><p><img src="..%5Cimage%5C%E6%8B%B7%E8%B4%9D%5C%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="浅拷贝"></p></li></ol><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><ol start="2"><li><p>深拷贝：</p><p><img src="..%5Cimage%5C%E6%8B%B7%E8%B4%9D%5C%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt="深拷贝"></p></li></ol><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><h4 id="1-数组的拷贝"><a href="#1-数组的拷贝" class="headerlink" title="1. 数组的拷贝"></a>1. 数组的拷贝</h4><p>如果是数组，我们可以利用数组的一些方法比如：<code>slice</code>、<code>concat</code>返回一个新数组的特性来实现拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'old'</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> new_arr = arr.concat();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">// [ 'old', 1, true, null, undefined ]</span></span><br><span class="line"></span><br><span class="line">new_arr[<span class="number">0</span>] = <span class="string">'new'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["old", 1, true, null, undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr) <span class="comment">// ["new", 1, true, null, undefined]</span></span><br></pre></td></tr></table></figure><p><code>slice</code>的做法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'old'</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// let new_arr = arr.concat();</span></span><br><span class="line"><span class="keyword">var</span> new_arr = arr.slice();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">// [ 'old', 1, true, null, undefined ]</span></span><br><span class="line"></span><br><span class="line">new_arr[<span class="number">0</span>] = <span class="string">'new'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["old", 1, true, null, undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr) <span class="comment">// ["new", 1, true, null, undefined]</span></span><br></pre></td></tr></table></figure><p>但是如果嵌套了对象或数组的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">old</span>: <span class="string">'old'</span>&#125;, [<span class="string">'old'</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> new_arr = arr.concat();</span><br><span class="line"><span class="built_in">console</span>.log(new_arr); <span class="comment">// [ &#123; old: 'old' &#125;, [ 'old' ] ]</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>][<span class="string">'old'</span>] = <span class="string">'new'</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">'new'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [&#123;old: 'new'&#125;, ['new']]</span></span><br><span class="line"><span class="built_in">console</span>.log(new_arr) <span class="comment">// [&#123;old: 'new'&#125;, ['new']]</span></span><br></pre></td></tr></table></figure><p>会发现，无论是新数组还是旧数组都发生了变化，也就是说使用<code>concat</code>方法，克隆的并不彻底。</p><p>如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。</p><p>我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。</p><p><strong>所以我们可以看出使用 <code>concat</code> 和 <code>slice</code> 是一种浅拷贝</strong></p><h4 id="2-JSON实现深拷贝"><a href="#2-JSON实现深拷贝" class="headerlink" title="2. JSON实现深拷贝"></a>2. <code>JSON</code>实现深拷贝</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line"></span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 0, 1, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [ 4, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><p>对比之前赋值的结果，我们发现原来的数组arr并没有被改变，可以说两者是相互独立的 很显然，这就是一个深拷贝的例子</p><blockquote><p>原理： <code>JSON.parse()</code>方法用于将一个 <code>JSON</code> 字符串转换为对象。 <code>JSON.stringify()</code> 方法用于将 JavaScript 值（通常为对象或数组）转换为 <code>JSON</code>字符串。 在<code>JSON.stringify()</code>完成后，对象就转为了字符串，也就可以说实实在在的复制了一个值，不存在引用之说。 再利用<code>JSON.parse()</code>转为对象，这样达到深拷贝的目的</p></blockquote><h5 id="JSON实现深拷贝的缺陷"><a href="#JSON实现深拷贝的缺陷" class="headerlink" title="JSON实现深拷贝的缺陷"></a><code>JSON</code>实现深拷贝的缺陷</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    nul: <span class="literal">null</span>,</span><br><span class="line">    und: <span class="literal">undefined</span>,</span><br><span class="line">    sym: <span class="built_in">Symbol</span>(<span class="string">'sym'</span>),</span><br><span class="line">    str: <span class="string">'str'</span>,</span><br><span class="line">    bol: <span class="literal">true</span>,</span><br><span class="line">    num: <span class="number">45</span>,</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">    reg: <span class="regexp">/[0-9]/</span>,</span><br><span class="line">    dat: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  nul: <span class="literal">null</span>,</span><br><span class="line">  str: <span class="string">'str'</span>,</span><br><span class="line">  bol: <span class="literal">true</span>,</span><br><span class="line">  num: <span class="number">45</span>,</span><br><span class="line">  arr: [ <span class="number">1</span>, <span class="number">4</span> ],</span><br><span class="line">  reg: &#123;&#125;,</span><br><span class="line">  dat: <span class="string">'2020-02-07T04:56:23.428Z'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现有些属性被忽略了：</p><ul><li>undefined</li><li>symbol</li><li>function</li></ul><p>这也可以看出<code>JSON</code>实现深拷贝的不足之处</p><h4 id="3-ES6新特性实现浅拷贝"><a href="#3-ES6新特性实现浅拷贝" class="headerlink" title="3. ES6新特性实现浅拷贝"></a>3. <code>ES6</code>新特性实现浅拷贝</h4><h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a><code>Object.assign()</code></h5><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 <code>Object.assign(target, ...sources)</code>  target目标对象。 sources源对象。 返回的是目标对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'1'</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    bb: <span class="string">'2'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line">newObj.a = <span class="string">'11'</span>;</span><br><span class="line">newObj.b.bb = <span class="string">'22'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: '1', b: &#123; bb: '22' &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">// &#123; a: '11', b: &#123; bb: '22' &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到<code>a1</code>的值被改变，而b的值没有被改变，说明了：</p><p><strong><code>Obejct.assign()</code>只能对一层进行深拷贝 如果拷贝的层数超过了一层的话，那么就会进行浅拷贝</strong></p><h5 id="展开运算符实现拷贝"><a href="#展开运算符实现拷贝" class="headerlink" title="展开运算符实现拷贝(...)"></a>展开运算符实现拷贝<code>(...)</code></h5><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'1'</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        bb: <span class="string">'2'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...obj&#125;</span><br><span class="line">newObj.a = <span class="string">'11'</span></span><br><span class="line">newObj.b.bb = <span class="string">'22'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: '1', b: &#123; bb: '22' &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">// &#123; a: '11', b: &#123; bb: '22' &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>扩展运算符只能对一层进行深拷贝 如果拷贝的层数超过了一层的话，那么就会进行浅拷贝</p><p><strong>原理： 对于引用类型，赋值操作符只是把存放在栈内容中的指针赋值给另外一个变量。 所以在赋值完成后，在栈内存就有两个指针指向堆内存同一个数据。 也就可以说两个变量在共用着同一个数据，这就是浅拷贝。</strong></p><h4 id="4-深浅拷贝实现"><a href="#4-深浅拷贝实现" class="headerlink" title="4. 深浅拷贝实现"></a>4. 深浅拷贝实现</h4><h5 id="对于浅拷贝："><a href="#对于浅拷贝：" class="headerlink" title="对于浅拷贝："></a>对于浅拷贝：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        cloneTarget[key] = target[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性依次添加到新对象上，返回。</p><p>如果是深拷贝的话，考虑到我们要拷贝的对象是不知道有多少层深度的，我们可以用递归来解决问题，稍微改写上面的代码：</p><ul><li>如果是原始类型，无需继续拷贝，直接返回</li><li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行<strong>深拷贝后</strong>依次添加到新对象上。</li></ul><p><strong>很容易理解，如果有更深层次的对象可以继续递归直到属性为原始类型，这样我们就完成了一个最简单的深拷贝：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> cloneTarget = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">          cloneTarget[key] = deepCopy(target[key]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'1'</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    bb: <span class="string">'2'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(deepCopy(obj));</span><br></pre></td></tr></table></figure><p>这是一个最基础版本的深拷贝，但是显然，他还有非常多的缺陷，比如，还没有考虑数组。</p><h5 id="考虑数组"><a href="#考虑数组" class="headerlink" title="考虑数组:"></a>考虑数组:</h5><p>在上面的版本中，我们的初始化结果只考虑了普通的<code>object</code>，下面我们只需要把初始化代码稍微一变，就可以兼容数组了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      cloneTarget[key] = deepCopy(target[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'1'</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    bb: <span class="string">'2'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  c: [<span class="number">33</span>, [<span class="number">44</span>, <span class="number">55</span>]]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(deepCopy(obj));</span><br><span class="line"><span class="comment">// &#123; a: '1', b: &#123; bb: '2' &#125;, c: [ 33, [ 44, 55 ] ] &#125;</span></span><br></pre></td></tr></table></figure><h5 id="循环引用的时候："><a href="#循环引用的时候：" class="headerlink" title="循环引用的时候："></a>循环引用的时候：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      cloneTarget[key] = deepCopy(target[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  field1: <span class="number">1</span>,</span><br><span class="line">  field2: <span class="literal">undefined</span>,</span><br><span class="line">  field3: &#123;</span><br><span class="line">      child: <span class="string">'child'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target.target = target;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(deepCopy(target));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">报错</span><br><span class="line"><span class="built_in">RangeError</span>: Maximum call stack size exceeded 栈溢出</span><br></pre></td></tr></table></figure><p>很明显，因为递归进入死循环导致栈内存溢出了。</p><p>原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接的引用了自身的情况：</p><p><strong>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</strong></p><p>这个存储空间，需要可以存储<code>key-value</code>形式的数据，且<code>key</code>可以是一个引用类型，我们可以选择<code>Map</code>这种数据结构：</p><ul><li>检查<code>map</code>中有无克隆过的对象</li><li>有-直接返回</li><li>没有-将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li><li>继续克隆</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      cloneTarget[key] = deepCopy(target[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  field1: <span class="number">1</span>,</span><br><span class="line">  field2: <span class="literal">undefined</span>,</span><br><span class="line">  field3: &#123;</span><br><span class="line">    child: <span class="string">'child'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target.target = target;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(deepCopy(target));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  field1: <span class="number">1</span>,</span><br><span class="line">  field2: <span class="literal">undefined</span>,</span><br><span class="line">  field3: &#123; <span class="attr">child</span>: <span class="string">'child'</span> &#125;,</span><br><span class="line">  field4: [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span> ],</span><br><span class="line">  target: [Circular] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="合理的判断引用类型："><a href="#合理的判断引用类型：" class="headerlink" title="合理的判断引用类型："></a>合理的判断引用类型：</h5><p>首先，判断是否为引用类型，我们还需要考虑<code>function</code>和<code>null</code>两种特殊的数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> target;</span><br><span class="line">    <span class="keyword">return</span> target !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JavaScript深浅拷贝原理与实现&quot;&gt;&lt;a href=&quot;#JavaScript深浅拷贝原理与实现&quot; class=&quot;headerlink&quot; title=&quot;JavaScript深浅拷贝原理与实现&quot;&gt;&lt;/a&gt;JavaScript深浅拷贝原理与实现&lt;/h3&gt;&lt;bloc
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—遍历对象属性的几种方式</title>
    <link href="http://yoursite.com/2020/02/06/ES6%E2%80%94%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/06/ES6%E2%80%94%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-02-06T04:38:25.871Z</published>
    <updated>2020-02-06T11:07:37.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript遍历对象的几种方式"><a href="#JavaScript遍历对象的几种方式" class="headerlink" title="JavaScript遍历对象的几种方式"></a>JavaScript遍历对象的几种方式</h3><h4 id="1-自身可枚举属性"><a href="#1-自身可枚举属性" class="headerlink" title="1. 自身可枚举属性"></a>1. 自身可枚举属性</h4><blockquote><p><code>Object.keys()</code>方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和<code>for...in</code>循环遍历该对象时返回的顺序一致。如果对象的键-值都不可枚举，那么将返回由键组成的数组。</p></blockquote><p>这是合理的，因为大多数时候只需要关注对象自身的属性。</p><h5 id="来看看一个对象拥有自身和继承属性的例子，Object-keys-只返回自己的属性键"><a href="#来看看一个对象拥有自身和继承属性的例子，Object-keys-只返回自己的属性键" class="headerlink" title="来看看一个对象拥有自身和继承属性的例子，Object.keys()只返回自己的属性键"></a>来看看一个对象拥有自身和继承属性的例子，<code>Object.keys()</code>只返回自己的属性键</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleColors = &#123;</span><br><span class="line">   colorA: <span class="string">'white'</span>,</span><br><span class="line">   colorB: <span class="string">'black'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> natureColors = &#123;</span><br><span class="line">   colorC: <span class="string">'green'</span>,</span><br><span class="line">   colorD: <span class="string">'yellow'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(natureColors, simpleColors);</span><br><span class="line"><span class="built_in">console</span>.dir(natureColors);<span class="comment">//simpleColors对象在natureColors原型上</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(natureColors)); <span class="comment">//["colorC", "colorD"]</span></span><br><span class="line"><span class="built_in">console</span>.log(natureColors[<span class="string">'colorA'</span>]); <span class="comment">//white</span></span><br><span class="line"><span class="built_in">console</span>.log(natureColors[<span class="string">'colorB'</span>]); <span class="comment">//black</span></span><br></pre></td></tr></table></figure><p><code>Object.setPrototype()</code>方法设置一个指定的对象的原型到另一个对象或null</p><p><code>Object.keys(natureColors)</code>返回<code>natureColors</code>对象自身可枚举属性键:<code>[&#39;colorC&#39;, &#39;colorD&#39;]</code>。<code>natureColors</code>包含从<code>simpleColors</code>原型对象继承的属性，但是<code>Object.keys()</code>函数会跳过它们。<code>Object.keys()</code>函数会跳过它们。<code>Object.value和Object.entries()</code>也都是返回一个给定对象自身可枚举属性的键值对数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleColors = &#123;</span><br><span class="line">      colorA: <span class="string">'white'</span>,</span><br><span class="line">      colorB: <span class="string">'black'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> natureColors = &#123;</span><br><span class="line">      colorC: <span class="string">'green'</span>,</span><br><span class="line">      colorD: <span class="string">'yellow'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(natureColors, simpleColors);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(natureColors)); <span class="comment">//["colorC", "colorD"]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(natureColors)); <span class="comment">//["green", "yellow"]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(natureColors)); <span class="comment">//[Array(2), Array(2)]</span></span><br></pre></td></tr></table></figure><p>现在注意与<code>for...in</code>语句的区别，<code>for...in</code>不仅可以循环枚举自身属性还可以枚举原型链中的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleColors = &#123;</span><br><span class="line">      colorA: <span class="string">'white'</span>,</span><br><span class="line">      colorB: <span class="string">'black'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> natureColors = &#123;</span><br><span class="line">      colorC: <span class="string">'green'</span>,</span><br><span class="line">      colorD: <span class="string">'yellow'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(natureColors, simpleColors);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> enumerableKeys = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> natureColors) &#123;</span><br><span class="line">      enumerableKeys.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(enumerableKeys); <span class="comment">// ["colorC", "colorD", "colorA", "colorB"]</span></span><br></pre></td></tr></table></figure><p><code>enumerableKeys</code>数组包含<code>natureColors</code>自身属性键：<code>colorC</code>、<code>colorD</code>。</p><p>另外<code>for...in</code>也遍历了从<code>simpleColors</code>原型对象继承的属性</p><h4 id="2-Object-values-返回属性值"><a href="#2-Object-values-返回属性值" class="headerlink" title="2. Object.values()返回属性值"></a>2. <code>Object.values()</code>返回属性值</h4><blockquote><p><code>Object.values()</code>方法返回一个给定对象自身的所有可枚举属性值的数组，值顺序与使用<code>foe..in</code>循环的循序相同（区别在于<code>for...in</code>循环枚举原型链中的属性）。</p></blockquote><p>使用<code>Object.keys()</code>收集keys，然后通过key去对象取对应的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meals = &#123;</span><br><span class="line">      mealA: <span class="string">'Breakfast'</span>,</span><br><span class="line">      mealB: <span class="string">'Lunch'</span>,</span><br><span class="line">      mealC: <span class="string">'Dinner'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(meals)) &#123;</span><br><span class="line">      <span class="keyword">let</span> mealName = meals[key];</span><br><span class="line">      <span class="built_in">console</span>.log(mealName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>meal</code>是一个普通对象。使用<code>Object.keys(meals)</code>和枚举的<code>for...of</code>循环获取对象键值。但是<code>let mealName = meals[key];</code>没有多大的必要，可以进一步优化代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meals = &#123;</span><br><span class="line">      mealA: <span class="string">'Breakfast'</span>,</span><br><span class="line">      mealB: <span class="string">'Lunch'</span>,</span><br><span class="line">      mealC: <span class="string">'Dinner'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> mealName <span class="keyword">of</span> <span class="built_in">Object</span>.values(meals)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(mealName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为<code>Object.values(meals)</code>返回数组中的对象属性值，所以可以直接在 <code>for..of</code>中简化。<code>mealName</code>直接在循环中赋值。</p><h4 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3.Object.entries()"></a>3.<code>Object.entries()</code></h4><blockquote><p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 <code>for...in</code>循环遍历该对象时返回的顺序一致（区别在于 <code>for...in</code>循环也枚举原型链中的属性）</p></blockquote><p><code>Object.entries()</code> 返回键值对数组，如 <code>[[key1,value1],[key2,value2],...,[keyN,valueN]]</code></p><h5 id="可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示："><a href="#可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示：" class="headerlink" title="可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示："></a>可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meals = &#123;</span><br><span class="line">      mealA: <span class="string">'Breakfast'</span>,</span><br><span class="line">      mealB: <span class="string">'Lunch'</span>,</span><br><span class="line">      mealC: <span class="string">'Dinner'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(meals)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key + <span class="string">':'</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 'mealA:Breakfast' 'mealB:Lunch' 'mealC:Dinner'</span></span><br></pre></td></tr></table></figure><p>如上所示，因为 <code>Object.entries()</code>返回一个与数组解构赋值兼容的集合，因此不需要为赋值或声明添加额外的行</p><h5 id="当普通对象要转换成-Map-时Object-entries-就很有用，因为-Object-entries-返回的格式与-Map构造函数接受的格式完全相同：-key-value-。"><a href="#当普通对象要转换成-Map-时Object-entries-就很有用，因为-Object-entries-返回的格式与-Map构造函数接受的格式完全相同：-key-value-。" class="headerlink" title="当普通对象要转换成 Map 时Object.entries()就很有用，因为 Object.entries()返回的格式与 Map构造函数接受的格式完全相同：(key,value)。"></a>当普通对象要转换成 <code>Map</code> 时<code>Object.entries()</code>就很有用，因为 <code>Object.entries()</code>返回的格式与 <code>Map</code>构造函数接受的格式完全相同：<code>(key,value)</code>。</h5><p>使用常规的 Map构造函数可以将一个二维键值对数组转换成一个 Map对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greetings = &#123;</span><br><span class="line">      morning: <span class="string">'Good morning'</span>,</span><br><span class="line">      midday: <span class="string">'Good day'</span>,</span><br><span class="line">      evening: <span class="string">'Good evening'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> greetingsMap = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(greetings));</span><br><span class="line">    <span class="built_in">console</span>.log(greetingsMap); <span class="comment">// &#123;"morning" =&gt; "Good morning", "midday" =&gt; "Good day", "evening" =&gt; "Good evening"&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log([...greetingsMap]); <span class="comment">// =&gt; Object.entries(greetings)</span></span><br><span class="line">    <span class="built_in">console</span>.log(greetingsMap.get(<span class="string">'morning'</span>)); <span class="comment">// Good morning</span></span><br><span class="line">    <span class="built_in">console</span>.log(greetingsMap.get(<span class="string">'midday'</span>)); <span class="comment">// Good day</span></span><br><span class="line">    <span class="built_in">console</span>.log(greetingsMap.get(<span class="string">'evening'</span>)); <span class="comment">// Good evening</span></span><br></pre></td></tr></table></figure><p><code>Map</code> 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值</p><p>有趣的是， Map提供了与 <code>Object.values()</code>和 <code>Object.entries()</code> 等效的方法（只是它们返回<code>Iterators</code>），以便为 <code>Map</code>实例提取属性值或键值对：</p><ul><li><code>Map.prototype.values()</code> 等价于 <code>Object.values()</code></li><li><code>Map.prototype.entries()</code> 等价于 <code>Object.entries()</code></li></ul><p><code>map</code>是普通对象的改进版本，可以获取 <code>map</code> 的大小(对于普通对象，必须手动获取)，并使用任意对象类型作为键(普通对象使用字符串基元类型作为键)。</p><h5 id="让我们看看返回-values（）和-entries（）的-map的方法"><a href="#让我们看看返回-values（）和-entries（）的-map的方法" class="headerlink" title="让我们看看返回 .values（）和 .entries（）的 map的方法:"></a>让我们看看返回 .values（）和 .entries（）的 map的方法:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[...greetingsMap.values()];</span><br><span class="line"><span class="comment">// =&gt; ['Good morning', 'Good day', 'Good evening']</span></span><br><span class="line">[...greetingsMap.entries()];</span><br><span class="line"><span class="comment">// =&gt; [ ['morning', 'Good morning'], ['midday', 'Good day'],</span></span><br><span class="line"><span class="comment">//      ['evening', 'Good evening'] ]</span></span><br></pre></td></tr></table></figure><p>注意： <strong><code>greetingsMap.values()</code>和 <code>greetingsMap.entries()</code>返回迭代器对象。若要将结果放入数组，扩展运算符 <code>…</code>是必要的</strong></p><h4 id="4-对象属性的顺序"><a href="#4-对象属性的顺序" class="headerlink" title="4. 对象属性的顺序"></a>4. 对象属性的顺序</h4><p><code>JS</code>对象是简单的键值映射，因此，对象中属性的顺序是微不足道的， 在大多数情况下，不应该依赖它。</p><p>在<code>ES5</code>和早期标准中，根本没有指定属性的顺序。</p><p>然而，从<code>ES6</code>开始，属性的顺序是基于一个特殊的规则的，除非特指按照时间排序。通过两个新方法 <code>Object.getOwnPropertyNames</code>和 <code>Reflect.ownKeys</code>来编写示例讲解这一属性排序规则。</p><ol><li>数字：当属性的类型时数字类型时，会按照数字的从大到小的顺序进行排序；</li><li>字符串：当属性的类型是字符串时，会按照时间的先后顺序进行排序；</li><li><code>Symbol</code>：当属性的类型是<code>Symbol</code>时，会按照时间的先后顺序进行排序。</li></ol><p>如果需要有序集合，建议将数据存储到数组或 <code>Set</code>中</p><p><strong>总结</strong></p><p><code>Object.values()</code> 和 <code>Object.entries()</code> 是为<code>JS</code>开发人员提供新的标准化辅助函数的另一个改进步骤。</p><p><code>Object.entries()</code>最适用于数组解构赋值，其方式是将键和值轻松分配给不同的变量。此函数还可以轻松地将纯<code>JS对象</code>属性映射到 Map对象中</p><p>注意：<strong><code>Object.values()</code>和<code>Object.entries()</code>返回数据的顺序是不确定的，所以不要依赖该方式。</strong></p><h4 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h4><h5 id="JS对象的可枚举属性和不可枚举属性"><a href="#JS对象的可枚举属性和不可枚举属性" class="headerlink" title="JS对象的可枚举属性和不可枚举属性"></a><code>JS</code>对象的可枚举属性和不可枚举属性</h5><blockquote><p>对象的每一个属性都有一个描述对象，用来描述和控制该属性的行为，用<code>Object.getOwnPropertyDescriptor</code>方法来获取该描述对象（用<code>Object.defineProperty</code>方法来设置）。</p></blockquote><p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">start</span>: <span class="string">'123'</span> &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'start'</span>))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出内容：</span></span><br><span class="line">     configurable: <span class="literal">true</span></span><br><span class="line">     enumerable: <span class="literal">true</span></span><br><span class="line">     value: <span class="string">"123"</span></span><br><span class="line">     writable: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h5><ol><li><code>configurable</code>：表示能否通过<code>delete</code>删除此属性，能否修改属性的特性，或能否修改把属性修改为访问器属性，如果直接使用字面量定义对象，默认值为true</li><li><code>enumerable</code>: 表示该属性是否可枚举，即是否通过for-in循环或<code>Object.keys()</code>返回属性，如果直接使用字面量定义对象，默认值为true</li><li><code>writable</code>: 能否修改属性的值，如果直接使用字面量定义对象，默认值为true</li><li><code>value</code>: 该属性对应的值，默认为undefined</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            value: <span class="string">'祖宗'</span>,</span><br><span class="line">            enumerable: <span class="literal">false</span>,  <span class="comment">//不可枚举</span></span><br><span class="line">        &#125;,</span><br><span class="line">        age: &#123;</span><br><span class="line">            value: <span class="number">88</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,   <span class="comment">//可枚举</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"key:"</span> + key + <span class="string">','</span> + <span class="string">'value:'</span> + obj[key]) <span class="comment">//key: value, value: 88</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="目前-有四个操作会忽略enumerable为false的属性。"><a href="#目前-有四个操作会忽略enumerable为false的属性。" class="headerlink" title="目前,有四个操作会忽略enumerable为false的属性。"></a>目前,有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</h5><ol><li><code>for…in循环</code>：只遍历对象自身的和继承的可枚举的属性</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性</li><li><code>Object.assign()</code>： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JavaScript遍历对象的几种方式&quot;&gt;&lt;a href=&quot;#JavaScript遍历对象的几种方式&quot; class=&quot;headerlink&quot; title=&quot;JavaScript遍历对象的几种方式&quot;&gt;&lt;/a&gt;JavaScript遍历对象的几种方式&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—async与await</title>
    <link href="http://yoursite.com/2020/02/05/ES6%E2%80%94async%E4%B8%8Eawait/"/>
    <id>http://yoursite.com/2020/02/05/ES6%E2%80%94async%E4%B8%8Eawait/</id>
    <published>2020-02-05T15:11:02.040Z</published>
    <updated>2020-02-05T16:21:55.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="async-await的使用"><a href="#async-await的使用" class="headerlink" title="async/await的使用"></a><code>async</code>/<code>await</code>的使用</h3><h4 id="1-async-await的具体使用规则"><a href="#1-async-await的具体使用规则" class="headerlink" title="1. async/await的具体使用规则"></a>1. <code>async</code>/<code>await</code>的具体使用规则</h4><p>在我们处理异步的时候，比起回调函数，<code>Promise</code>的then方法会显得较为简洁和清晰，但是在处理多个<strong>彼此之间相互依赖的请求的时候</strong>，就会显的有些累赘。这时候，用<code>async</code>和<code>await</code>更加优雅</p><h5 id="async-await使用规则一：凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象"><a href="#async-await使用规则一：凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象" class="headerlink" title="async/await使用规则一：凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象"></a><strong><code>async/await</code>使用规则一：凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = test()</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//test()返回Promise对象</span></span><br></pre></td></tr></table></figure><h5 id="async-await使用规则二：await必须在async函数里使用，不能单独使用"><a href="#async-await使用规则二：await必须在async函数里使用，不能单独使用" class="headerlink" title="async/await使用规则二：await必须在async函数里使用，不能单独使用"></a><strong><code>async/await</code>使用规则二：await必须在async函数里使用，不能单独使用</strong></h5><p>错误的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>正确的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(result); <span class="comment">// success</span></span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br></pre></td></tr></table></figure><p><strong><code>async/await</code>使用规则三：await后面需要跟Promise对象，不然就没有意义，而且await后面的Promise对象不必写then，因为await的作用之一就是获取后面Promise对象成功状态传递出来的参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">'success'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">await</span> fn() <span class="comment">//因为fn会返回一个Promise对象</span></span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">//这里会打出Promise成功后传递过来的'success'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><h4 id="2-async-await的错误处理方式一"><a href="#2-async-await的错误处理方式一" class="headerlink" title="2. async/await的错误处理方式一"></a>2. <code>async</code>/<code>await</code>的错误处理方式一</h4><blockquote><p>关于错误处理，如规则三所说，await可以直接获取到后面Promise成功状态传递的参数，但是却捕捉不到失败状态。在这里，我们通过给包裹await的async函数添加then/catch方法来解决，因为根据规则一，async函数本身就会返回一个Promise对象</p></blockquote><p>包含错误处理的完整的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promiseDemo = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">        <span class="keyword">if</span> (random &gt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">            resolve(<span class="string">'success'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'failed'</span>)</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> promiseDemo</span><br><span class="line">    <span class="keyword">return</span> result  <span class="comment">//这里的result是promiseDemo成功状态的值，如果失败了，代码就直接跳到下面的catch了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response) </span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：<strong>一是async函数需要主动return一下，如果Promise的状态是成功的，那么return的这个值就会被下面的then方法捕捉到；二是，如果async函数有任何错误，都被catch捕捉到！</strong></p><h4 id="3-async-await的错误处理方式二"><a href="#3-async-await的错误处理方式二" class="headerlink" title="3.async/await的错误处理方式二"></a>3.<code>async</code>/<code>await</code>的错误处理方式二</h4><blockquote><p>使用<code>try{}catch(e){}</code>来捕获promise错误的时候</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseDemo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">          <span class="keyword">if</span>(random &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            resolve(<span class="string">'success'</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'failed'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> promiseDemo();</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e + <span class="string">'错误'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test();</span><br></pre></td></tr></table></figure><h4 id="4-同步和异步"><a href="#4-同步和异步" class="headerlink" title="4. 同步和异步"></a>4. 同步和异步</h4><blockquote><p>在async函数中使用await，那么await这里的代码就会变成同步的了，意思就是说只有等await后面的Promise执行完成得到结果才会继续下去，await就是等待，这样虽然避免了异步，但是它也会阻塞代码，所以使用的时候要考虑周全</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>成功`</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> p1 = <span class="keyword">await</span> fn(<span class="string">'小红'</span>);</span><br><span class="line">      <span class="keyword">let</span> p2 = <span class="keyword">await</span> fn(<span class="string">'小明'</span>);</span><br><span class="line">      <span class="keyword">let</span> p3 = <span class="keyword">await</span> fn(<span class="string">'小华'</span>);</span><br><span class="line">      <span class="keyword">return</span> [p1, p2, p3];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>成功`</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'xxxxxxxxxxxxxxxxxxx'</span>);</span><br><span class="line">      <span class="keyword">let</span> p1 = <span class="keyword">await</span> fn(<span class="string">'小红'</span>);</span><br><span class="line">      <span class="keyword">let</span> p2 = <span class="keyword">await</span> fn(<span class="string">'小明'</span>);</span><br><span class="line">      <span class="keyword">let</span> p3 = <span class="keyword">await</span> fn(<span class="string">'小华'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log([p1,p2,p3]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    test();</span><br></pre></td></tr></table></figure><p>这样写虽然是可以的，但是这里await会阻塞代码，每个await都必须等后面的fn()执行完成才会执行下一行代码，所以test函数执行需要3秒。如果不是遇到特定的场景，最好还是不要这样用。</p><h4 id="5-一个适合使用async-await的业务场景"><a href="#5-一个适合使用async-await的业务场景" class="headerlink" title="5. 一个适合使用async/await的业务场景"></a>5. 一个适合使用<code>async</code>/<code>await</code>的业务场景</h4><blockquote><p>在前端编程中，我们偶尔会遇到这样一个场景：我们需要发送多个请求，而<strong>后面请求的发送总是需要依赖上一个请求返回的数据</strong>。对于这个问题，我们既可以用的Promise的链式调用来解决，也可以用<code>async/await</code>来解决，然而后者会更简洁些</p></blockquote><p>使用promise链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(time)</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(<span class="number">500</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(result + <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(result + <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用<code>async/await</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(time)</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="keyword">await</span> request(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="keyword">await</span> request(p1 + <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="keyword">await</span> request(p2 + <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> p3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getResult().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相对于使用then不停地进行链式调用， 使用<code>async/await</code>会显的更加易读一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;async-await的使用&quot;&gt;&lt;a href=&quot;#async-await的使用&quot; class=&quot;headerlink&quot; title=&quot;async/await的使用&quot;&gt;&lt;/a&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;的使用&lt;/h3
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ES6—promise使用</title>
    <link href="http://yoursite.com/2020/02/05/ES6%E2%80%94promise%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/05/ES6%E2%80%94promise%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-05T14:01:09.685Z</published>
    <updated>2020-02-05T15:09:39.077Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Promise的使用"><a href="#Promise的使用" class="headerlink" title="Promise的使用"></a>Promise的使用</h3><blockquote><p>一个 Promise 就是一个代表了异步操作最终完成或者失败的对象。这是MDN上关于Promise的解释。在前端开发中，Promise经常被拿来用于处理异步和回调的问题，来规避回调地狱和更好排布异步相关的代码</p></blockquote><h4 id="1-Promise的三种状态"><a href="#1-Promise的三种状态" class="headerlink" title="1. Promise的三种状态"></a>1. Promise的三种状态</h4><p>从字面的意思理解，Promise即是<strong>承诺</strong>，那承诺的结果就会有成功和失败两种。而且，我们许下承诺之后不会立即得到结果，在获得成功或是失败的结果之前，我们还需要一点时间来履行这个承诺。Promise的构造其实像极了我们生活中的承诺。</p><p><img src="..%5Cimage%5Cpromise%5Cpending.png" alt="pending"></p><p>以上是<code>Promise</code>的结构图。其中<code>Promise</code>存在三种状态，一种是pending状态、一种是成功时的<code>Fullfilled</code>状态、一种是失败时的<code>Rejected</code>状态。</p><h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> love = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> happy = <span class="built_in">Math</span>.random() &gt;= <span class="number">0.3</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(happy) &#123;</span><br><span class="line">          resolve(<span class="string">'marry'</span>); <span class="comment">//成功</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="string">'break'</span>); <span class="comment">//失败</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;<span class="comment">//成功的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(result); </span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;<span class="comment">// 失败的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>注意：<strong>Promise在经过pending状态达到成功或失败状态时就会凝固，即到达成功状态后再也不会失败，失败以后也不会回到成功状态。</strong>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> love = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">'break'</span>)</span><br><span class="line">      resolve(<span class="string">'marry'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e) <span class="comment">// break</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="2-Promise的then与catch的几种写法"><a href="#2-Promise的then与catch的几种写法" class="headerlink" title="2. Promise的then与catch的几种写法"></a>2. Promise的then与catch的几种写法</h4><ol><li><p>第一种，最常见的就是上面的写法, 使用then来捕捉resolve状态，使用catch来捕捉reject状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;<span class="comment">//成功的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(result); </span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;<span class="comment">// 失败的回调</span></span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>第二种，不写catch, 把用来捕捉reject状态的函数也写到then里，但是效果和上面一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;, result =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>第三种，分开写，也是可以的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;     <span class="comment">//只捕捉和处理成功状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">love.catch(<span class="function"><span class="params">result</span> =&gt;</span> &#123;    <span class="comment">//只捕捉和处理失败状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-快速构建一个成功或是失败状态的Promise"><a href="#3-快速构建一个成功或是失败状态的Promise" class="headerlink" title="3. 快速构建一个成功或是失败状态的Promise"></a>3. 快速构建一个成功或是失败状态的Promise</h4><h5 id="Promise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是Promise-resolve-用于构建成功状态的Promise-另一个是Promise-reject-，用于构建失败状态的Promise"><a href="#Promise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是Promise-resolve-用于构建成功状态的Promise-另一个是Promise-reject-，用于构建失败状态的Promise" class="headerlink" title="Promise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是Promise.resolve(), 用于构建成功状态的Promise;另一个是Promise.reject()，用于构建失败状态的Promise"></a>Promise自带了两种方法，我们可以利用它们快速构建一个Promise，一个是<code>Promise.resolve()</code>, 用于构建成功状态的Promise;另一个是<code>Promise.reject()</code>，用于构建失败状态的Promise</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">    p1.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result); <span class="comment">// success</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">'failed'</span>);</span><br><span class="line">    p2.catch(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result); <span class="comment">// failed</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="4-使用Promise-all-来处理前端场景"><a href="#4-使用Promise-all-来处理前端场景" class="headerlink" title="4. 使用Promise.all()来处理前端场景"></a>4. 使用<code>Promise.all()</code>来处理前端场景</h4><p>在前端的开发实践中，我们有时会遇到需要发送多个请求并根据请求顺序返回数据的需求，比如，我们要发送a、b、c三个请求，这三个请求返回的数据分别为a1、a2、a3，而我们想要a1、a2、a3按照我们希望的顺序返回。那么，使用<code>Promise.all()</code>方法可以完美的解决这一问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟异步请求的函数</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="function">(<span class="params">name, time</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">          <span class="keyword">if</span> (random &gt;= <span class="number">0.2</span>) &#123;</span><br><span class="line">            resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>成功了`</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">`<span class="subst">$&#123;name&#125;</span>失败了`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, time)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建三个Promise实例</span></span><br><span class="line">    <span class="keyword">let</span> a = request(<span class="string">'小明'</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">let</span> b = request(<span class="string">'小红'</span>, <span class="number">500</span>)</span><br><span class="line">    <span class="keyword">let</span> c = request(<span class="string">'小华'</span>, <span class="number">1500</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Promise.all(), 注意它接收的是一个数组作为参数 </span></span><br><span class="line">    <span class="built_in">Promise</span>.all([c, a, b]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">//["小华成功了", "小明成功了", "小红成功了"]</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>把上面的代码复制下来放到浏览器的调试控制台里多执行几次（第二次执行需要刷新）会发生什么事情呢？你可能猜到了：<strong>如果三个请求都成功的话，那么这三个请求所返回的数据就是按照发送请求的顺序排列的，即[“小华成功了”, “小明成功了”, “小红成功了”]，而且还是以数组形式返回的；而当其中有请求失败了的话，就只会返回最先失败的结果。</strong></p><p>当然，除了这个场景以外，<code>Promise.all()</code>方法还能用于其它地方。比如说，一个页面上有两个请求，只有拿到了这两个请求的数据，页面才会展示，在这之前会显示一个loading加载图。使用<code>Promise.all()</code>也是可以非常简洁的解决这个问题</p><h4 id="5-Promise-race-的使用"><a href="#5-Promise-race-的使用" class="headerlink" title="5. Promise.race()的使用"></a>5. <code>Promise.race()</code>的使用</h4><h5 id="顾名思义，Promse-race就是赛跑的意思，意思就是说，Promise-race-p1-p2-p3-里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态"><a href="#顾名思义，Promse-race就是赛跑的意思，意思就是说，Promise-race-p1-p2-p3-里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态" class="headerlink" title="顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态"></a>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success1'</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'success2'</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// success2</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-Promise的链式调用"><a href="#5-Promise的链式调用" class="headerlink" title="5. Promise的链式调用"></a>5. <code>Promise</code>的链式调用</h4><h5 id="上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。"><a href="#上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。" class="headerlink" title="上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。"></a>上面说过的then方法，在每次使用后依然会继续返回一个Promise对象。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>);</span><br><span class="line">    <span class="keyword">let</span> response = p.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result); <span class="comment">//success</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(response); <span class="comment">//Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>因为then之后返回的还是一个Promise对象，那我们就可以继续then，只不过后面then拿到的参数是上一个then里return的内容，而这个return的内容既可以是普通的字符串、数字等（最后都会被封装成Promise）也可以是自己写的一个Promise对象。</p><h5 id="Promise链式调用的代码："><a href="#Promise链式调用的代码：" class="headerlink" title="Promise链式调用的代码："></a><code>Promise</code>链式调用的代码：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> love = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> happy = <span class="built_in">Math</span>.random() &gt;= <span class="number">0.3</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (happy) &#123;</span><br><span class="line">          resolve(<span class="string">'marry'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="string">'break'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> haveChild = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'孩子生了！'</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    love.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">//marry</span></span><br><span class="line">      <span class="keyword">return</span> haveChild <span class="comment">// 这里返回一个Promise对象,它的resolve会被下一个then捕捉</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">//孩子生了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'最后，他们白头偕老！'</span> <span class="comment">//这里返回的字符串会传给下一个then</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">// 最后，他们白头偕老</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error) <span class="comment">//break</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>注意：链式调用的最一定要加上一个catch来捕捉链条中可能出现的错误。</p><h4 id="6-Promise链式调用可以处理的一个业务场景"><a href="#6-Promise链式调用可以处理的一个业务场景" class="headerlink" title="6. Promise链式调用可以处理的一个业务场景"></a>6. Promise链式调用可以处理的一个业务场景</h4><h5 id="当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，Promise的链式操作就可以派上用场了"><a href="#当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，Promise的链式操作就可以派上用场了" class="headerlink" title="当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，Promise的链式操作就可以派上用场了"></a>当我们需要发送多个请求，而后一个请求总是依赖前一个请求的结果时，<code>Promise的链式操作</code>就可以派上用场了</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = axios.get(url)  <span class="comment">//result是Promise对象</span></span><br><span class="line">    result.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(url0).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request(response.data.link)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Promise的使用&quot;&gt;&lt;a href=&quot;#Promise的使用&quot; class=&quot;headerlink&quot; title=&quot;Promise的使用&quot;&gt;&lt;/a&gt;Promise的使用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个 Promise 就是一个代表了异步操作最终完
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript—数组方法及数组去重</title>
    <link href="http://yoursite.com/2020/02/05/JavaScript%E2%80%94%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%8A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>http://yoursite.com/2020/02/05/JavaScript%E2%80%94%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%8A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
    <published>2020-02-05T10:25:49.344Z</published>
    <updated>2020-02-05T11:15:41.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数组的遍历方法"><a href="#1-数组的遍历方法" class="headerlink" title="1. 数组的遍历方法"></a>1. 数组的遍历方法</h3><ol><li><p><code>Array.forEach()</code></p><blockquote><p>遍历数组，和普通的for循环使用类似</p></blockquote></li><li><p><code>Array.entries()</code></p><blockquote><p>返回一个Array Iterator对象，该对象包含数组中每一个索引的键值对</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> eArr = arr.entries();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [1, "b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(eArr.next().value); <span class="comment">// [2, "c"]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.every()</code></p><blockquote><p>every()是对数组中每一项运行给定函数，如果该函数对<strong>每一项</strong>返回true,则返回true</p></blockquote></li><li><p><code>Array.some()</code></p><blockquote><p>some()是对数组中每一项运行给定函数，如果该函数对<strong>任一项</strong>返回true,则返回true</p></blockquote></li><li><p><code>Array.filter</code></p><blockquote><p>filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组</p></blockquote></li><li><p><code>Array.map()</code></p><blockquote><p>遍历数组每一项，并且返回一个新数组</p></blockquote></li><li><p><code>Array.find()</code></p><blockquote><p>find()方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">//4</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.findIndex()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.reduce((prev,cur,index,array){},init)</code></p><blockquote><p>该方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值</p><p> <strong>array</strong> 表示原数组；<br> <strong>prev</strong> 表示上一次调用回调时的返回值，或者初始值 init;<br> <strong>cur</strong> 表示当前正在处理的数组元素；<br> <strong>index</strong> 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；<br> <strong>init</strong> 表示初始值</p></blockquote></li></ol><h3 id="2-数组去重的几种方法"><a href="#2-数组去重的几种方法" class="headerlink" title="2. 数组去重的几种方法"></a>2. 数组去重的几种方法</h3><ol><li><p>定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> repeat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArr.length; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (arr[i] === newArr[j]) &#123;</span><br><span class="line">            repeat = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!repeat) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> formArr = arr.sort();</span><br><span class="line">      <span class="keyword">var</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; formArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(formArr[i] !== formArr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">          newArr.push(formArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique2([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用对象属性存在的特性，如果没有该属性则存入新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> newArr = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">          obj[arr[i]] = <span class="number">1</span></span><br><span class="line">          newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// console.log(obj);</span></span><br><span class="line">      <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique3([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组的<code>indexOf</code>下标属性来查询。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique4</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newArr.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique4([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique5 = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(arr[i])) &#123;</span><br><span class="line">          newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique5([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的 filter 和 includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique6</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      newArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newArr.includes(item) ? <span class="string">''</span> : newArr.push(item)</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique6([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的 forEach 和 includes方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique7</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newArr = [];</span><br><span class="line">      arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!newArr.includes(item)) &#123;</span><br><span class="line">          newArr.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique7([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>利用数组原型对象上的reduce和include方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique8 = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> newArr = arr.reduce(<span class="function">(<span class="params">all, item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!all.includes(item)) &#123;</span><br><span class="line">          all.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all;</span><br><span class="line">      &#125;, [])</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(unique8([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li><li><p>ES6 set方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique9</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique9([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">unique10</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(unique10([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-数组的遍历方法&quot;&gt;&lt;a href=&quot;#1-数组的遍历方法&quot; class=&quot;headerlink&quot; title=&quot;1. 数组的遍历方法&quot;&gt;&lt;/a&gt;1. 数组的遍历方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Array.forEach()&lt;/code&gt;&lt;/p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—性能优化1</title>
    <link href="http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%961/"/>
    <id>http://yoursite.com/2020/02/05/React%E5%AD%A6%E4%B9%A0%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%961/</id>
    <published>2020-02-05T05:01:51.113Z</published>
    <updated>2020-02-05T07:17:50.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React性能优化1"><a href="#React性能优化1" class="headerlink" title="React性能优化1"></a>React性能优化1</h3><blockquote><h4 id="react凭借virtual-DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。"><a href="#react凭借virtual-DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。" class="headerlink" title="react凭借virtual DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。"></a>react凭借virtual DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能。</h4></blockquote><h4 id="1-使用React-Memo-来缓存组件"><a href="#1-使用React-Memo-来缓存组件" class="headerlink" title="1. 使用React.Memo()来缓存组件"></a>1. 使用<code>React.Memo()</code>来缓存组件</h4><blockquote><p>父组件的每次状态更新，都会导致子组件重新渲染，即使传入子组件的状态没有变化，当类组件的输入属性相同时可以使用<code>pureComponent</code>或<code>shouldComponentUdate</code>来避免组件的渲染，函数组件中我们可以使用<code>React.memo</code>来缓存组件，这样只有当传入组件的状态值发生变化时才会重新渲染。如果传入相同的值，则返回缓存的组件。示例如下:</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(props) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;&#123;props.value&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="React-memo（浅比较）"><a href="#React-memo（浅比较）" class="headerlink" title="React.memo（浅比较）"></a><code>React.memo（浅比较）</code></h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> AreEqual <span class="keyword">from</span> <span class="string">'./component/AreEqual'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      val: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      val: <span class="keyword">this</span>.state.val</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;AreEqual &#123;...this.state&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果把nextProps传入render方法的返回结果与将</span></span><br><span class="line"><span class="comment">   * preProps传入render方法的返回结果一致则返回true</span></span><br><span class="line"><span class="comment">   * 否则返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (prevProps.val === nextProps.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AreEqual</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"渲染了"</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; val &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;val&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React.memo()两个参数 第一个是纯函数，第二个是比较函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(AreEqual, areEqual);</span><br></pre></td></tr></table></figure><h4 id="2-React-PureComponent"><a href="#2-React-PureComponent" class="headerlink" title="2. React.PureComponent"></a>2. <code>React.PureComponent</code></h4><blockquote><p>作用：</p><ol><li><code>React.PureComponent</code>和<code>React.Component</code>类似，都是定义一个组件类。</li><li>不同的是<code>React.Component</code>没有实现<code>shouldComponentUpdate()</code>，而<code>React.PureComponent</code>通过props和state的浅比较实现了。</li><li><code>React.PureComponent</code>是作用在类中，<code>React.memo</code>是作用在函数中</li></ol></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Children name=&#123;'这是React.pureComponent的使用方法'&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-使用useMemo缓存大量的计算"><a href="#3-使用useMemo缓存大量的计算" class="headerlink" title="3. 使用useMemo缓存大量的计算"></a>3. 使用<code>useMemo</code>缓存大量的计算</h4><blockquote><p>有时渲染是不可避免的，但如果您的组件是一个功能组件，重新渲染会导致每次都调用大型计算函数，这是非常消耗性能的，我们可以使用新的<code>useMemo</code>钩子来“记忆”这个计算函数的计算结果。这样只有传入的参数发生变化后，该计算函数才会重新调用计算新的结果。<br>通过这种方式，您可以使用从先前渲染计算的结果来挽救昂贵的计算耗时。总体目标是减少JavaScript在呈现组件期间必须执行的工作量，以便主线程被阻塞的时间更短。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免这样做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> someProp = heavyCalculation(props.item);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AnotherComponent</span> <span class="attr">someProp</span>=<span class="string">&#123;someProp&#125;</span> /&gt;</span> </span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">  </span></span><br><span class="line"><span class="xml">// 只有 `props.item` 改变时someProp的值才会被重新计算</span></span><br><span class="line"><span class="xml">function Component(props) &#123;</span></span><br><span class="line"><span class="xml">  const someProp = useMemo(() =&gt; heavyCalculation(props.item), [props.item]);</span></span><br><span class="line">  return &lt;AnotherComponent someProp=&#123;someProp&#125; /&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-使用React-PureComponent-shouldComponentUpdate"><a href="#4-使用React-PureComponent-shouldComponentUpdate" class="headerlink" title="4.使用React.PureComponent, shouldComponentUpdate"></a>4.使用<code>React.PureComponent</code>, <code>shouldComponentUpdate</code></h4><blockquote><p>父组件状态的每次更新，都会导致子组件的重新渲染，即使是传入相同props。但是这里的重新渲染不是说会更新DOM,而是每次都会调用diif算法来判断是否需要更新DOM。这对于大型组件例如组件树来说是非常消耗性能的。<br>在这里我们就可以使用<code>React.PureComponent</code> ,<code>shouldComponentUpdate</code>生命周期来确保只有当组件props状态改变时才会重新渲染。如下例子:</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ParentComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SomeComponent someProp=&#123;props.somePropValue&#125; /&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;AnotherComponent someOtherProp=&#123;props.someOtherPropValue&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>div&gt;</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">SomeComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;props.someProp&#125;&lt;<span class="regexp">/div&gt;  </span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 只要props.somePropValue 发生变化，不论props.someOtherPropValue是否发生变化该组件都会发生变化</span></span><br><span class="line"><span class="regexp">export default function AnotherComponent(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;&#123;props.someOtherProp&#125;&lt;/</span>div&gt;  </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>React.PureComponent</code>、<code>shouldComponentUpdate</code>性能优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.someOtherProp&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props !== nextProps</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.someOtherProp&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>PureComponent</code>会进行浅比较来判断组件是否应该重新渲染，对于传入的基本类型props，只要值相同，浅比较就会认为相同，对于传入的引用类型props，浅比较只会认为传入的props是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是不同的props。<br>需要注意的是在对于那些可以忽略渲染时间的组件或者是状态一直变化的组件则要谨慎使用<code>PureComponent</code>，因为进行浅比较也会花费时间，这种优化更适用于大型的展示组件上。大型组件也可以拆分成多个小组件，并使用memo来包裹小组件，也可以提升性能。</p></blockquote><h5 id="补充：PureComponent浅比较部分核心源码"><a href="#补充：PureComponent浅比较部分核心源码" class="headerlink" title="补充：PureComponent浅比较部分核心源码"></a>补充：<code>PureComponent</code>浅比较部分核心源码</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span> (<span class="params">objA: mixed, objB: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的 is 相当于 === 的功能，只是对 + 0 和 - 0，以及 NaN 和 NaN 的情况进行了特殊处理</span></span><br><span class="line">  <span class="comment">// 第一关：基础数据类型直接比较出结果</span></span><br><span class="line">  <span class="keyword">if</span> (is (objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二关：只要有一个不是对象数据类型就返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">'object'</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三关：在这里已经可以保证两个都是对象数据类型，比较两者的属性数量</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys (objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys (objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第四关：比较两者的属性是否相等，值是否相等</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.call (objB, keysA [i]) ||</span><br><span class="line">      !is (objA [keysA [i]], objB [keysA [i]])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意：比较终究是浅比较，当出现嵌套情况就会失灵"><a href="#注意：比较终究是浅比较，当出现嵌套情况就会失灵" class="headerlink" title="注意：比较终究是浅比较，当出现嵌套情况就会失灵"></a>注意：比较终究是浅比较，当出现嵌套情况就会失灵</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state: &#123;<span class="attr">a</span> : [<span class="string">"1"</span>]&#125; -&gt; state: &#123;<span class="attr">a</span>: [<span class="string">"1"</span>, <span class="string">"2"</span>]&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式最大的弊端是由于 <code>JS</code> 引用赋值的原因，这种方式仅仅适用于无状态组件或者状态数据非常简单的组件，对于大量的应用组件无能为力</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React性能优化1&quot;&gt;&lt;a href=&quot;#React性能优化1&quot; class=&quot;headerlink&quot; title=&quot;React性能优化1&quot;&gt;&lt;/a&gt;React性能优化1&lt;/h3&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;react凭借virtual-DOM和d
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React与Vue比较2</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%832/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%832/</id>
    <published>2020-02-04T08:57:36.458Z</published>
    <updated>2020-02-08T11:39:50.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React与Vue的对比中"><a href="#React与Vue的对比中" class="headerlink" title="React与Vue的对比中"></a>React与Vue的对比中</h2><h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1.核心思想"></a>1.核心思想</h4><blockquote><h5 id="vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。"><a href="#vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。" class="headerlink" title="vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。"></a>vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。</h5></blockquote><ol><li><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><h5 id="vue的整体思想仍然式拥抱html-结构-css-表现-js-行为-的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用-v-if、v-show、v-for等指令-，在组件数据上，vue2-0通过Object-defineProperty对数据做到了更细致的监听，精准实现组件级别的更新"><a href="#vue的整体思想仍然式拥抱html-结构-css-表现-js-行为-的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用-v-if、v-show、v-for等指令-，在组件数据上，vue2-0通过Object-defineProperty对数据做到了更细致的监听，精准实现组件级别的更新" class="headerlink" title="vue的整体思想仍然式拥抱html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等指令)，在组件数据上，vue2.0通过Object.defineProperty对数据做到了更细致的监听，精准实现组件级别的更新"></a>vue的整体思想仍然式拥抱html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等指令)，在组件数据上，vue2.0通过<code>Object.defineProperty</code>对数据做到了更细致的监听，精准实现组件级别的更新</h5></li><li><h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><h5 id="react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染"><a href="#react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染" class="headerlink" title="react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染"></a>react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过<code>shouldComponentUpdate</code>或者<code>PureComponent</code>避免不必要的重新渲染</h5></li></ol><h4 id="2-组件形式"><a href="#2-组件形式" class="headerlink" title="2. 组件形式"></a>2. 组件形式</h4><blockquote><p>vue组件定义使用xx.vue文件来表示，vue组件将html、css、js组合到一起，模板部分使用<code>双括号</code>渲染数据，形式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模板(html)</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据管理(js)</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;NewComponent&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;xx&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 样式(css)</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>react推荐使用jsx或者js文件来表示组件，react支持class组件和function组件两种形式，react使用<code>{}</code>包裹变量</p></blockquote><ol><li><h5 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'xx'</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.state.name&#125;    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li><li><p>函数组件</p><p>hooks的出现赋予了function组件管理state的能力</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;name&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-数据管理（props、data、state）"><a href="#3-数据管理（props、data、state）" class="headerlink" title="3.数据管理（props、data、state）"></a>3.数据管理（props、data、state）</h4><blockquote><p>组件数据来自父组件的数据props与自身的数据</p><p>vue与react中的props都是单向数据流的，父级props的更新会向下流动到子组件中，props用来接收父组件的数据</p></blockquote><h5 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h5><ol><li><h6 id="props"><a href="#props" class="headerlink" title="props"></a>props</h6><blockquote><p>vue中的props支持传递静态、动态props</p></blockquote><h5 id="静态："><a href="#静态：" class="headerlink" title="静态："></a>静态：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">new</span>-component title=<span class="string">"study vue"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">new-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="动态："><a href="#动态：" class="headerlink" title="动态："></a>动态：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">new</span>-component :title=<span class="string">"title"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">new-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><h6 id="data"><a href="#data" class="headerlink" title="data"></a>data</h6><blockquote><p>vue中使用data来管理组件的数据，vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)。一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p></blockquote><p>注意：当一个组件被定义，data必须声明为返回一个初始数据对象的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'NewComponent'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'xxx'</span>,</span><br><span class="line">      age: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要在组件内部修改数据时，可以直接通过vue实例修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'new Name'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="react-1"><a href="#react-1" class="headerlink" title="react"></a>react</h5><ol><li><h6 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h6><blockquote><p>react中的props也与vue一样可以传递静态或动态props，静态props一般传递字符串。</p><p>函数组件和class组件都可以使用props，函数组件使用props参数获取父组件传下来的props。</p><p>函数组件获取props：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;</span><br></pre></td></tr></table></figure><p>class组件使用<code>this.props</code>获取组件<code>props</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name &#125; &#x3D; this.props;</span><br><span class="line">    return &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>动态props：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Welcome name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h6 id="state"><a href="#state" class="headerlink" title="state"></a>state</h6><blockquote><p>react中使用state来管理组件内的数据，hooks的出现使得函数组件也具备管理state的能力</p></blockquote><h5 id="class组件state"><a href="#class组件state" class="headerlink" title="class组件state"></a>class组件state</h5><p>class组件在构造函数（constructor）中定义组件内数据（state），修改数据必须通过setState修改，不能直接修改state，这点非常重要。</p><p>class组件使用state：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'xx'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.changeName = <span class="keyword">this</span>.changeName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="string">'new name'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">this</span>.state.name &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于class组建的setState有以下两点说明：</p><ul><li>1.setState更新是异步的，但是<strong>在setTimeout和原生事件中是同步的</strong>。</li><li>2.setState更新的是组件的部分数据，react会自动将数据合并。</li></ul><p>当需要使用上一个state值时，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h5 id="函数组件useState"><a href="#函数组件useState" class="headerlink" title="函数组件useState"></a>函数组件useState</h5><p>react 16.8之前函数组件只是纯的渲染组件，hooks的出现赋予了函数组件管理state的能力。</p><p>useState返回一个state，以及更新state的函数。如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于setState有以下三点说明：</p><ul><li>1.与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。</li><li>2.只能在函数最顶层调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>3.只能在 React 的函数组件或自定义hook中调用 Hook。不要在其他 JavaScript 函数中调用。</li></ul></blockquote></li></ol><h4 id="4-组件数据交互"><a href="#4-组件数据交互" class="headerlink" title="4.组件数据交互"></a>4.组件数据交互</h4><blockquote><p>组件数据交互是指父子组件、兄弟组件、跨层组件之间传递数据。 兄弟组件之间可以通过事件总线或者通过父组件传递数据</p></blockquote><h5 id="4-1-父子组件数据交互-props-自定义事件-vs-props-回调"><a href="#4-1-父子组件数据交互-props-自定义事件-vs-props-回调" class="headerlink" title="4.1 父子组件数据交互(props+自定义事件 vs props+回调)"></a>4.1 父子组件数据交互(props+自定义事件 vs props+回调)</h5><p>对于父子组件数据交互，vue中使用prop+自定义事件实现，react通过props+回调</p><h5 id="vue-2"><a href="#vue-2" class="headerlink" title="vue"></a>vue</h5><p>vue中父组件通过props传递数据给子组件，子组件使用<code>$emit</code>触发自定义事件，父组件中监听子组件的自定义事件获取子组件传递来的数据。</p><p>子组件使用<code>$emit</code>传递自定义事件<code>myEvent</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;changeName&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;NewComponent&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;xxx&#39;,</span><br><span class="line">      age: 12</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeName() &#123;</span><br><span class="line">      this.name &#x3D; &#39;new Name&#39;;</span><br><span class="line">      this.$emit(&#39;myEvent&#39;, this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>父组件使用<code>@myEvent</code>监听自定义事件，回调函数参数是子组件传回的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;new-component @myEvent&#x3D;&quot;getName&quot;&gt;&lt;&#x2F;new-component&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import NewComponent from &#39;.&#x2F;NewComponent&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    NewComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getName(name) &#123;</span><br><span class="line">      console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="react-2"><a href="#react-2" class="headerlink" title="react"></a>react</h4><p>react中父组件使用props传递数据和回调函数给子组件，子组件通过props传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据。</p><p>子组件通过props接收父组件传下来的回调事件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; myEvent &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setName(<span class="string">'new name'</span>);</span><br><span class="line">    myEvent(<span class="string">'new name'</span>);<span class="comment">//回调</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件通过回调事件获取子组件传递的参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">myEvent</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2跨组件数据交互-provide-inject-vs-Context"><a href="#4-2跨组件数据交互-provide-inject-vs-Context" class="headerlink" title="4.2跨组件数据交互(provide/inject vs Context)"></a>4.2跨组件数据交互(provide/inject vs Context)</h5><blockquote><p>vue和react都支持跨组件传递数据，vue中主要通过<code>provide / inject</code>实现，react中主要通过<code>Context</code>实现。</p></blockquote><h5 id="vue-3"><a href="#vue-3" class="headerlink" title="vue"></a>vue</h5><p>vue中通过<code>provide / inject</code>在祖先组件向所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p><p>祖先组件中定义provide选项，provide选项应该是一个对象或返回一个对象的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;new-component @myEvent&#x3D;&quot;getName&quot;&gt;&lt;&#x2F;new-component&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import NewComponent from &#39;.&#x2F;NewComponent&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123; &#x2F;&#x2F; 定义provide选项</span><br><span class="line">    message: &#39;This is a big news&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    NewComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getName(name) &#123;</span><br><span class="line">      console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件通过inject选项获取祖先组件的provide选项值，inject选项应该是一个字符串数组或者对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Children&#39;,</span><br><span class="line">  inject: [&#39;message&#39;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote><h5 id="react-3"><a href="#react-3" class="headerlink" title="react"></a>react</h5><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><p>在父组件创建一个Context对象，通过<code>Context.provider</code>的value属性向消费组件传值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Context对象</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext(&#123; <span class="attr">theme</span>: <span class="string">'black'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Context.provider向消费组件传值</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">theme:</span> '<span class="attr">white</span>' &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Children</span> <span class="attr">myEvent</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费组件获取Context有2种方式：</p><p>（1）class组件通过contextType获取最近Context上的那个值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepChildren1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextType = MyContext;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.theme&#125;123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）函数式组件通过<code>Context.Consumer</code>订阅到Context的变更。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepChildren</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;</span></span><br><span class="line"><span class="xml">      (value) =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value.theme&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">MyContext.Consumer</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Context需要注意：</p><blockquote><p>当Provider的父组件进行重渲染时，consumers组件会重新渲染，并且没有办法避免，应该尽量避免使用Context。</p></blockquote><h4 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h4><blockquote><p>组件的生命周期一般包括：初始化、挂载、更新、卸载四大阶段，接下来分别看下vue和react的生命周期</p></blockquote><h5 id="vue-4"><a href="#vue-4" class="headerlink" title="vue"></a>vue</h5><p>vue生命周期图示:</p><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Cvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue生命周期"></p><p>vue生命周期包含:</p><ul><li>beforeCreate<br> 实例组件刚创建，元素DOM和数据都还没有初始化，暂时不能在这个周期里面进行任何操作。</li><li>created<br> 数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。调用后台接口获取数据可以在这个阶段完成。</li><li>beforeMount<br> DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示<code>双括号</code>，虚拟DOM结构已经生成。</li><li>mounted<br> 数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。这个周期适合执行初始化需要操作DOM的方法。</li><li>beforeUpdate<br> 页面数据改变了都会触发，在更新前触发，此时的数据还是未更新前的数据，没有数据改变则不执行。</li><li>updated<br> 页面数据改变都会触发，在更新完成之后触发，此时的数据是更新后的数据。</li></ul><blockquote><p>注意：在这里操作数据很容易引起卡死。</p></blockquote><ul><li>beforeDestroy<br> 组件销毁之前执行，在这个周期里仍然可以访问data和method，多组件间通信需要发布信息时可以在该阶段完成。</li><li>destroyed<br> 当离开组件对应页面时组件销毁时触发，主要用于取消一些副作用（取消事件监听、取消定时器、取消不必要的请求等）</li></ul><h5 id="react-4"><a href="#react-4" class="headerlink" title="react"></a>react</h5><h5 id="16-3以前的生命周期"><a href="#16-3以前的生命周期" class="headerlink" title="16.3以前的生命周期"></a>16.3以前的生命周期</h5><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Creact%E8%80%81%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react老版生命周期"></p><p>（1）初始化</p><ul><li>constructor<br> 是class组件的默认方法，常用来初始化state或者设置属性等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props); <span class="comment">// 声明constructor时必须调用super方法</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          count: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）挂载阶段</p><ul><li>componentWillMount()<br>组件挂载之前调用，并且只会调用一次。</li><li>render<br>render是一个React组件必须定义的生命周期函数，用来渲染DOM。 并必须 return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。</li></ul><blockquote><p>不要在render里面修改state,会引起死循环导致卡死。</p></blockquote><ul><li>componentDidMount()<br>组件挂在完成之后调用，在这个阶段可以获取真实dom元素，常用来发起异步请求获取数据。</li></ul><p>（3）更新阶段</p><p>当通过setState修改state或父组件重新render引起props更新，都会引起子组件的重新render。</p><ul><li>componentWillReceiveProps(nextProps)<br>props发生变化以及父组件重新渲染时都会触发该生命周期函数。在该阶段可以通过参数nextProps获取变化后的props参数， 通过this.props访问之前的props。该生命周期内可以进行setState。</li><li>shouldComponentUpdate(nextProps,nextState)<br>组件每次setState或者父组件重新render都会引起子组件render，可以使用该钩子比较nextProps，nextState及当前组件的this.props，this.state的状态用来判断是否需要重新渲染。默认返回true，需要重新render，返回false则不触发渲染。</li></ul><blockquote><p>一般我们通过该钩子来优化性能，避免子组件不必要的渲染。</p></blockquote><ul><li>componentWillUpdate(nextProps, nextState)<br>当组件收到新的 props 或 state 时，会在渲染之前调用。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</li></ul><blockquote><p>注意：不能在此方法中调用<code>this.setState</code></p></blockquote><ul><li>componentDidUpdate(prevProps, prevState) 此方法在组件更新后被调用。首次渲染不会执行此方法。当组件更新后，可以在此处对DOM进行操作。</li></ul><blockquote><p>注意：可以在<code>componentDidUpdate()</code>中直接调用<code>setState()</code>，但是它必需被包裹在一个条件语句里，否则会导致死循环。</p></blockquote><p>（4）卸载阶段</p><ul><li>componentWillUnmount()<br>会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在<code>componentDidMount()</code> 中创建的订阅等。</li></ul><blockquote><p>注意：componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。</p></blockquote><h5 id="16-4之后"><a href="#16-4之后" class="headerlink" title="16.4之后"></a>16.4之后</h5><p>react 16.0之后移除的生命周期函数：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul><p>但是为了向下兼容，react并未删除这三个生命周期，新增以 <code>UNSAFE_</code> 前缀为别名的三个函数 <code>UNSAFE_componentWillMount()</code>、<code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code>。</p><p>新增的生命周期函数：</p><ul><li>static getDerivedStateFromProps(nextProps, prevState)</li><li>getSnapshotBeforeUpdate(prevProps, prevState)</li></ul><p>生命周期如下：</p><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Creact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react生命周期"></p><blockquote><p>总结：<br>初始化阶段保持不变 </p><p>挂载阶段: getDerivedStateFromProps =&gt; render =&gt; componentDidMount </p><p>更新阶段: getDerivedStateFromProps =&gt; shoudeComponentUpdate =&gt; render =&gt; getSnapshotBeforeUpdate  =&gt; componentDidUpdate </p><p>卸载阶段保持不变</p></blockquote><h5 id="getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。"><a href="#getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。" class="headerlink" title="getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。"></a>getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。</h5><p>（1）static getDerivedStateFromProps(props, state)</p><p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p><blockquote><p>当state的值在任何时候都取决于props的时候适用该方法。</p></blockquote><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.type !== prevState.type) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            type: nextProps.type,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>（2）getSnapshotBeforeUpdate(prevProps, prevState)</p><p>getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。应返回 snapshot 的值（或 null）。</p><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// 我们是否在 list 中添加新的 items ？</span></span><br><span class="line">    <span class="comment">// 捕获滚动位置以便我们稍后调整滚动位置。</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span></span><br><span class="line">    <span class="comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span></span><br><span class="line">    <span class="comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React与Vue的对比中&quot;&gt;&lt;a href=&quot;#React与Vue的对比中&quot; class=&quot;headerlink&quot; title=&quot;React与Vue的对比中&quot;&gt;&lt;/a&gt;React与Vue的对比中&lt;/h2&gt;&lt;h4 id=&quot;1-核心思想&quot;&gt;&lt;a href=&quot;#1-核
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—setState</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94setState/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94setState/</id>
    <published>2020-02-04T07:11:17.734Z</published>
    <updated>2020-02-04T08:36:34.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React中的state"><a href="#React中的state" class="headerlink" title="React中的state"></a>React中的state</h3><h4 id="1-不能直接修改-state"><a href="#1-不能直接修改-state" class="headerlink" title="1. 不能直接修改 state"></a>1. 不能直接修改 <code>state</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-state中数据的修改"><a href="#2-state中数据的修改" class="headerlink" title="2.state中数据的修改"></a>2.<code>state</code>中数据的修改</h4><ul><li>通过<code>setState</code>修改<code>state</code>中的数据</li></ul><blockquote><h6 id="setState中的关键点"><a href="#setState中的关键点" class="headerlink" title="setState中的关键点"></a><code>setState</code>中的关键点</h6></blockquote><ol><li><p><code>setState</code>不会立刻改变<code>React</code>组件中<code>state</code>的值 </p></li><li><p><code>setState</code>通过引发一次组件的更新过程来引发重新绘制</p><p>重绘指的就是引起<code>React</code>的更新生命周期函数4个函数：</p><ul><li><code>shouldComponentUpdate</code>（被调用时<code>this.state</code>没有更新；如果返回了<code>false</code>，生命周期被中断，虽然不调用之后的函数了，但是<code>state</code>仍然会被更新）</li><li><code>componentWillUpdate</code>（被调用时<code>this.state</code>没有更新）</li><li><code>render</code>（被调用时<code>this.state</code>得到更新）</li><li><code>componentDidUpdate</code></li></ul></li><li><p>多次<code>setState</code>函数调用产生的效果会合并。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'Pororo'</span>&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">age</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'Pororo'</span>，age: <span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面两块代码的效果是一样的。<strong>如果每次调用都引发一次生命周期更新，那性能就会消耗很大了。</strong>所以，<code>React</code>会将多个<code>this.setState</code>产生的修改<strong>放进一个队列里，</strong>等差不多的时候就会引发一次生命周期更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Eg</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">      index: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// react生命周期</span></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第一次输出</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第二次输出</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第三次输出</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第四次输出</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">     <span class="comment">// 通过 addEventListener 监听的会同步执行setState()</span></span><br><span class="line">    <span class="keyword">this</span>.refs.button.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index) <span class="comment">// 同步时输出 1 异步时（通过react事件机制定义的事件处理函数）输出 0</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index) <span class="comment">// 同步时输出 2 异步时（通过react事件机制定义的事件处理函数）输出 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>value: &#123;this.state.value&#125; index: &#123;this.state.index&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        &lt;button ref=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><h5 id="前两次setState："><a href="#前两次setState：" class="headerlink" title="前两次setState："></a>前两次<code>setState</code>：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步</span></span><br><span class="line"> <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">// 第一次输出0</span></span><br><span class="line">         <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">// 第二次输出0</span></span><br></pre></td></tr></table></figure><p>由于<code>setState</code>不会立即改变React组件中<code>state</code>的值，所以两次<code>setState</code>中<code>this.state.value</code>都是同一个值0，故而，这两次输出都是0。因而value只被加1。</p><p>既然这样，那么是不是可以直接操作<code>this.state</code>呢？比如：<code>this.state.value=this.state.value+1;</code>这样的确可以修改<code>this.state.value</code>的状态但是却不可以引发重复渲染。所以，就必须通过React设定的<code>setState</code>函数去改变<code>this.state</code>，从而引发重新渲染。</p><h5 id="setTimeout里面的两次setState"><a href="#setTimeout里面的两次setState" class="headerlink" title="setTimeout里面的两次setState:"></a><code>setTimeout</code>里面的两次<code>setState</code>:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第三次输出2</span></span><br><span class="line">           <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第四次输出3</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在<code>React</code>中，<strong>如果是由React引发的事件处理（比如：<code>onClick</code>引发的事件处理），调用<code>setState</code>不会同步更新<code>this.state</code>，除此之外的<code>setState</code>调用会同步执行t<code>his.setState</code>。</strong> “除此之外”指的是：绕过React通过<code>addEventListener</code>直接添加的事件处理函数和<code>setTimeout/setInterval</code>产生的异步调用。</p><p><img src="..%5Cimage%5CsetState%5CsetState.png" alt="setState"></p><blockquote><p>每次setState产生新的state会依次被存入一个队列，然后会根据<strong>isBathingUpdates</strong>变量判断是直接更新this.state还是放进dirtyComponent里回头再说。isBatchingUpdates默认是false，也就表示setState会同步更新this.state。但是，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，造成的后果就是由React控制的事件处理过程setState不会同步更新this.state。</p></blockquote></li></ol><h4 id="3-同步更新state的办法—函数式setState"><a href="#3-同步更新state的办法—函数式setState" class="headerlink" title="3.同步更新state的办法—函数式setState"></a>3.同步更新state的办法—函数式setState</h4><p>如果this.setState的参数不是一个对象而是一个函数时，这个函数会接收到两个参数，第一个是当前的state值，第二个是当前的props，这个函数应该返回一个对象，这个对象代表想要对this.state的更改，换句话说，之前你想给this.setState传递什么对象参数，在这种函数里就返回什么对象。不过，计算这个对象的方法有些改变，不再依赖于this.state，而是依赖于输入参数state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementMultiple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如当前this.state.count的值是0，第一次调用this.setState(increment)，传给increment的state参数是0，第二次调用时，state参数是1，第三次调用时参数是2，最终incrementMultiple让this.state.count变成了3。</p><p>对于多次调用函数式setState的情况，React会保证调用每次increment时，state都已经合并了之前的状态修改结果。</p><h4 id="4-把两种setState的用法混用"><a href="#4-把两种setState的用法混用" class="headerlink" title="4.把两种setState的用法混用"></a>4.把两种setState的用法混用</h4><h5 id="把incrementMultiple改成这样"><a href="#把incrementMultiple改成这样" class="headerlink" title="把incrementMultiple改成这样"></a>把incrementMultiple改成这样</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementMultiple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在几个函数式setState调用中插入一个传统式setState调用，最后得到的结果是让this.state.count增加了2，而不是增加4。</p><p>这是因为React会依次合并所有setState产生的效果，虽然前两个函数式setState调用产生的效果是count加2，但是中间出现一个传统式setState调用，一下子强行把积攒的效果清空，用count加1取代。</p><p>所以，传统式setState与函数式setState一定不要混用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React中的state&quot;&gt;&lt;a href=&quot;#React中的state&quot; class=&quot;headerlink&quot; title=&quot;React中的state&quot;&gt;&lt;/a&gt;React中的state&lt;/h3&gt;&lt;h4 id=&quot;1-不能直接修改-state&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
