<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wait1997</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-05T04:56:17.749Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaoxiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React学习—React与Vue比较2</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%832/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%832/</id>
    <published>2020-02-04T08:57:36.458Z</published>
    <updated>2020-02-05T04:56:17.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React与Vue的对比中"><a href="#React与Vue的对比中" class="headerlink" title="React与Vue的对比中"></a>React与Vue的对比中</h2><h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1.核心思想"></a>1.核心思想</h4><blockquote><h5 id="vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。"><a href="#vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。" class="headerlink" title="vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。"></a>vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。</h5></blockquote><ol><li><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><h5 id="vue的整体思想仍然式拥抱html-结构-css-表现-js-行为-的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用-v-if、v-show、v-for等指令-，在组件数据上，vue2-0通过Object-defineProperty对数据做到了更细致的监听，精准实现组件级别的更新"><a href="#vue的整体思想仍然式拥抱html-结构-css-表现-js-行为-的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用-v-if、v-show、v-for等指令-，在组件数据上，vue2-0通过Object-defineProperty对数据做到了更细致的监听，精准实现组件级别的更新" class="headerlink" title="vue的整体思想仍然式拥抱html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等指令)，在组件数据上，vue2.0通过Object.defineProperty对数据做到了更细致的监听，精准实现组件级别的更新"></a>vue的整体思想仍然式拥抱html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等指令)，在组件数据上，vue2.0通过<code>Object.defineProperty</code>对数据做到了更细致的监听，精准实现组件级别的更新</h5></li><li><h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><h5 id="react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染"><a href="#react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染" class="headerlink" title="react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过shouldComponentUpdate或者PureComponent避免不必要的重新渲染"></a>react整体上是函数式的思想，组件使用jsx语法，将html与css都融入javascript，jsx语法相对来说更加灵活。class组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过<code>shouldComponentUpdate</code>或者<code>PureComponent</code>避免不必要的重新渲染</h5></li></ol><h4 id="2-组件形式"><a href="#2-组件形式" class="headerlink" title="2. 组件形式"></a>2. 组件形式</h4><blockquote><p>vue组件定义使用xx.vue文件来表示，vue组件将html、css、js组合到一起，模板部分使用<code>双括号</code>渲染数据，形式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模板(html)</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据管理(js)</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;NewComponent&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;xx&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 样式(css)</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>react推荐使用jsx或者js文件来表示组件，react支持class组件和function组件两种形式，react使用<code>{}</code>包裹变量</p></blockquote><ol><li><h5 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'xx'</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.state.name&#125;    </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li><li><p>函数组件</p><p>hooks的出现赋予了function组件管理state的能力</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;name&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-数据管理（props、data、state）"><a href="#3-数据管理（props、data、state）" class="headerlink" title="3.数据管理（props、data、state）"></a>3.数据管理（props、data、state）</h4><blockquote><p>组件数据来自父组件的数据props与自身的数据</p><p>vue与react中的props都是单向数据流的，父级props的更新会向下流动到子组件中，props用来接收父组件的数据</p></blockquote><h5 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h5><ol><li><h6 id="props"><a href="#props" class="headerlink" title="props"></a>props</h6><blockquote><p>vue中的props支持传递静态、动态props</p></blockquote><h5 id="静态："><a href="#静态：" class="headerlink" title="静态："></a>静态：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">new</span>-component title=<span class="string">"study vue"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">new-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="动态："><a href="#动态：" class="headerlink" title="动态："></a>动态：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">new</span>-component :title=<span class="string">"title"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">new-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><h6 id="data"><a href="#data" class="headerlink" title="data"></a>data</h6><blockquote><p>vue中使用data来管理组件的数据，vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)。一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p></blockquote><p>注意：当一个组件被定义，data必须声明为返回一个初始数据对象的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'NewComponent'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'xxx'</span>,</span><br><span class="line">      age: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要在组件内部修改数据时，可以直接通过vue实例修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'new Name'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="react-1"><a href="#react-1" class="headerlink" title="react"></a>react</h5><ol><li><h6 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h6><blockquote><p>react中的props也与vue一样可以传递静态或动态props，静态props一般传递字符串。</p><p>函数组件和class组件都可以使用props，函数组件使用props参数获取父组件传下来的props。</p><p>函数组件获取props：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;</span><br></pre></td></tr></table></figure><p>class组件使用<code>this.props</code>获取组件<code>props</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; name &#125; &#x3D; this.props;</span><br><span class="line">    return &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>动态props：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Welcome name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h6 id="state"><a href="#state" class="headerlink" title="state"></a>state</h6><blockquote><p>react中使用state来管理组件内的数据，hooks的出现使得函数组件也具备管理state的能力</p></blockquote><h5 id="class组件state"><a href="#class组件state" class="headerlink" title="class组件state"></a>class组件state</h5><p>class组件在构造函数（constructor）中定义组件内数据（state），修改数据必须通过setState修改，不能直接修改state，这点非常重要。</p><p>class组件使用state：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'xx'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.changeName = <span class="keyword">this</span>.changeName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeName() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="string">'new name'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">this</span>.state.name &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于class组建的setState有以下两点说明：</p><ul><li>1.setState更新是异步的，但是<strong>在setTimeout和原生事件中是同步的</strong>。</li><li>2.setState更新的是组件的部分数据，react会自动将数据合并。</li></ul><p>当需要使用上一个state值时，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h5 id="函数组件useState"><a href="#函数组件useState" class="headerlink" title="函数组件useState"></a>函数组件useState</h5><p>react 16.8之前函数组件只是纯的渲染组件，hooks的出现赋予了函数组件管理state的能力。</p><p>useState返回一个state，以及更新state的函数。如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于setState有以下三点说明：</p><ul><li>1.与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。</li><li>2.只能在函数最顶层调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>3.只能在 React 的函数组件或自定义hook中调用 Hook。不要在其他 JavaScript 函数中调用。</li></ul></blockquote></li></ol><h4 id="4-组件数据交互"><a href="#4-组件数据交互" class="headerlink" title="4.组件数据交互"></a>4.组件数据交互</h4><blockquote><p>组件数据交互是指父子组件、兄弟组件、跨层组件之间传递数据。 兄弟组件之间可以通过事件总线或者通过父组件传递数据</p></blockquote><h5 id="4-1-父子组件数据交互-props-自定义事件-vs-props-回调"><a href="#4-1-父子组件数据交互-props-自定义事件-vs-props-回调" class="headerlink" title="4.1 父子组件数据交互(props+自定义事件 vs props+回调)"></a>4.1 父子组件数据交互(props+自定义事件 vs props+回调)</h5><p>对于父子组件数据交互，vue中使用prop+自定义事件实现，react通过props+回调</p><h5 id="vue-2"><a href="#vue-2" class="headerlink" title="vue"></a>vue</h5><p>vue中父组件通过props传递数据给子组件，子组件使用<code>$emit</code>触发自定义事件，父组件中监听子组件的自定义事件获取子组件传递来的数据。</p><p>子组件使用<code>$emit</code>传递自定义事件<code>myEvent</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;changeName&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;NewComponent&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;xxx&#39;,</span><br><span class="line">      age: 12</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeName() &#123;</span><br><span class="line">      this.name &#x3D; &#39;new Name&#39;;</span><br><span class="line">      this.$emit(&#39;myEvent&#39;, this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>父组件使用<code>@myEvent</code>监听自定义事件，回调函数参数是子组件传回的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;new-component @myEvent&#x3D;&quot;getName&quot;&gt;&lt;&#x2F;new-component&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import NewComponent from &#39;.&#x2F;NewComponent&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    NewComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getName(name) &#123;</span><br><span class="line">      console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="react-2"><a href="#react-2" class="headerlink" title="react"></a>react</h4><p>react中父组件使用props传递数据和回调函数给子组件，子组件通过props传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据。</p><p>子组件通过props接收父组件传下来的回调事件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; myEvent &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'xxx'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setName(<span class="string">'new name'</span>);</span><br><span class="line">    myEvent(<span class="string">'new name'</span>);<span class="comment">//回调</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件通过回调事件获取子组件传递的参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">myEvent</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2跨组件数据交互-provide-inject-vs-Context"><a href="#4-2跨组件数据交互-provide-inject-vs-Context" class="headerlink" title="4.2跨组件数据交互(provide/inject vs Context)"></a>4.2跨组件数据交互(provide/inject vs Context)</h5><blockquote><p>vue和react都支持跨组件传递数据，vue中主要通过<code>provide / inject</code>实现，react中主要通过<code>Context</code>实现。</p></blockquote><h5 id="vue-3"><a href="#vue-3" class="headerlink" title="vue"></a>vue</h5><p>vue中通过<code>provide / inject</code>在祖先组件向所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p><p>祖先组件中定义provide选项，provide选项应该是一个对象或返回一个对象的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;new-component @myEvent&#x3D;&quot;getName&quot;&gt;&lt;&#x2F;new-component&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import NewComponent from &#39;.&#x2F;NewComponent&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123; &#x2F;&#x2F; 定义provide选项</span><br><span class="line">    message: &#39;This is a big news&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    NewComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getName(name) &#123;</span><br><span class="line">      console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件通过inject选项获取祖先组件的provide选项值，inject选项应该是一个字符串数组或者对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Children&#39;,</span><br><span class="line">  inject: [&#39;message&#39;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote><h5 id="react-3"><a href="#react-3" class="headerlink" title="react"></a>react</h5><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><p>在父组件创建一个Context对象，通过<code>Context.provider</code>的value属性向消费组件传值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Context对象</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext(&#123; <span class="attr">theme</span>: <span class="string">'black'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Context.provider向消费组件传值</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">theme:</span> '<span class="attr">white</span>' &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Children</span> <span class="attr">myEvent</span>=<span class="string">&#123;changeName&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费组件获取Context有2种方式：</p><p>（1）class组件通过contextType获取最近Context上的那个值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepChildren1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextType = MyContext;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.theme&#125;123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）函数式组件通过<code>Context.Consumer</code>订阅到Context的变更。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepChildren</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;</span></span><br><span class="line"><span class="xml">      (value) =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value.theme&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">MyContext.Consumer</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Context需要注意：</p><blockquote><p>当Provider的父组件进行重渲染时，consumers组件会重新渲染，并且没有办法避免，应该尽量避免使用Context。</p></blockquote><h4 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h4><blockquote><p>组件的生命周期一般包括：初始化、挂载、更新、卸载四大阶段，接下来分别看下vue和react的生命周期</p></blockquote><h5 id="vue-4"><a href="#vue-4" class="headerlink" title="vue"></a>vue</h5><p>vue生命周期图示:</p><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Cvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue生命周期"></p><p>vue生命周期包含:</p><ul><li>beforeCreate<br> 实例组件刚创建，元素DOM和数据都还没有初始化，暂时不能在这个周期里面进行任何操作。</li><li>created<br> 数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。调用后台接口获取数据可以在这个阶段完成。</li><li>beforeMount<br> DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示<code>双括号</code>，虚拟DOM结构已经生成。</li><li>mounted<br> 数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。这个周期适合执行初始化需要操作DOM的方法。</li><li>beforeUpdate<br> 页面数据改变了都会触发，在更新前触发，此时的数据还是未更新前的数据，没有数据改变则不执行。</li><li>updated<br> 页面数据改变都会触发，在更新完成之后触发，此时的数据是更新后的数据。</li></ul><blockquote><p>注意：在这里操作数据很容易引起卡死。</p></blockquote><ul><li>beforeDestroy<br> 组件销毁之前执行，在这个周期里仍然可以访问data和method，多组件间通信需要发布信息时可以在该阶段完成。</li><li>destroyed<br> 当离开组件对应页面时组件销毁时触发，主要用于取消一些副作用（取消事件监听、取消定时器、取消不必要的请求等）</li></ul><h5 id="react-4"><a href="#react-4" class="headerlink" title="react"></a>react</h5><h5 id="16-3以前的生命周期"><a href="#16-3以前的生命周期" class="headerlink" title="16.3以前的生命周期"></a>16.3以前的生命周期</h5><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Creact%E8%80%81%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react老版生命周期"></p><p>（1）初始化</p><ul><li>constructor<br> 是class组件的默认方法，常用来初始化state或者设置属性等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props); <span class="comment">// 声明constructor时必须调用super方法</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          count: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）挂载阶段</p><ul><li>componentWillMount()<br>组件挂载之前调用，并且只会调用一次。</li><li>render<br>render是一个React组件必须定义的生命周期函数，用来渲染DOM。 并必须 return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。</li></ul><blockquote><p>不要在render里面修改state,会引起死循环导致卡死。</p></blockquote><ul><li>componentDidMount()<br>组件挂在完成之后调用，在这个阶段可以获取真实dom元素，常用来发起异步请求获取数据。</li></ul><p>（3）更新阶段</p><p>当通过setState修改state或父组件重新render引起props更新，都会引起子组件的重新render。</p><ul><li>componentWillReceiveProps(nextProps)<br>props发生变化以及父组件重新渲染时都会触发该生命周期函数。在该阶段可以通过参数nextProps获取变化后的props参数， 通过this.props访问之前的props。该生命周期内可以进行setState。</li><li>shouldComponentUpdate(nextProps,nextState)<br>组件每次setState或者父组件重新render都会引起子组件render，可以使用该钩子比较nextProps，nextState及当前组件的this.props，this.state的状态用来判断是否需要重新渲染。默认返回true，需要重新render，返回false则不触发渲染。</li></ul><blockquote><p>一般我们通过该钩子来优化性能，避免子组件不必要的渲染。</p></blockquote><ul><li>componentWillUpdate(nextProps, nextState)<br>当组件收到新的 props 或 state 时，会在渲染之前调用。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</li></ul><blockquote><p>注意：不能在此方法中调用<code>this.setState</code></p></blockquote><ul><li>componentDidUpdate(prevProps, prevState) 此方法在组件更新后被调用。首次渲染不会执行此方法。当组件更新后，可以在此处对DOM进行操作。</li></ul><blockquote><p>注意：可以在<code>componentDidUpdate()</code>中直接调用<code>setState()</code>，但是它必需被包裹在一个条件语句里，否则会导致死循环。</p></blockquote><p>（4）卸载阶段</p><ul><li>componentWillUnmount()<br>会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在<code>componentDidMount()</code> 中创建的订阅等。</li></ul><blockquote><p>注意：componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。</p></blockquote><h5 id="16-4之后"><a href="#16-4之后" class="headerlink" title="16.4之后"></a>16.4之后</h5><p>react 16.0之后移除的生命周期函数：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul><p>但是为了向下兼容，react并未删除这三个生命周期，新增以 <code>UNSAFE_</code> 前缀为别名的三个函数 <code>UNSAFE_componentWillMount()</code>、<code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code>。</p><p>新增的生命周期函数：</p><ul><li>static getDerivedStateFromProps(nextProps, prevState)</li><li>getSnapshotBeforeUpdate(prevProps, prevState)</li></ul><p>生命周期如下：</p><p><img src="..%5Cimage%5CVue_React%E5%AF%B9%E6%AF%94%5Creact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="react生命周期"></p><blockquote><p>总结：<br>初始化阶段保持不变 </p><p>挂载阶段: getDerivedStateFromProps =&gt; render =&gt; componentDidMount </p><p>更新阶段: getDerivedStateFromProps =&gt; shoudeComponentUpdate =&gt; render =&gt; getSnapshotBeforeUpdate  =&gt; componentDidUpdate </p><p>卸载阶段保持不变</p></blockquote><h5 id="getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。"><a href="#getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。" class="headerlink" title="getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。"></a>getDerivedStateFromProps、getSnapshotBeforeUpdate两个方法。</h5><p>（1）static getDerivedStateFromProps(props, state)</p><p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p><blockquote><p>当state的值在任何时候都取决于props的时候适用该方法。</p></blockquote><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.type !== prevState.type) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            type: nextProps.type,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>（2）getSnapshotBeforeUpdate(prevProps, prevState)</p><p>getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。应返回 snapshot 的值（或 null）。</p><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// 我们是否在 list 中添加新的 items ？</span></span><br><span class="line">    <span class="comment">// 捕获滚动位置以便我们稍后调整滚动位置。</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span></span><br><span class="line">    <span class="comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span></span><br><span class="line">    <span class="comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React与Vue的对比中&quot;&gt;&lt;a href=&quot;#React与Vue的对比中&quot; class=&quot;headerlink&quot; title=&quot;React与Vue的对比中&quot;&gt;&lt;/a&gt;React与Vue的对比中&lt;/h2&gt;&lt;h4 id=&quot;1-核心思想&quot;&gt;&lt;a href=&quot;#1-核
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—setState</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94setState/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94setState/</id>
    <published>2020-02-04T07:11:17.734Z</published>
    <updated>2020-02-04T08:36:34.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React中的state"><a href="#React中的state" class="headerlink" title="React中的state"></a>React中的state</h3><h4 id="1-不能直接修改-state"><a href="#1-不能直接修改-state" class="headerlink" title="1. 不能直接修改 state"></a>1. 不能直接修改 <code>state</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-state中数据的修改"><a href="#2-state中数据的修改" class="headerlink" title="2.state中数据的修改"></a>2.<code>state</code>中数据的修改</h4><ul><li>通过<code>setState</code>修改<code>state</code>中的数据</li></ul><blockquote><h6 id="setState中的关键点"><a href="#setState中的关键点" class="headerlink" title="setState中的关键点"></a><code>setState</code>中的关键点</h6></blockquote><ol><li><p><code>setState</code>不会立刻改变<code>React</code>组件中<code>state</code>的值 </p></li><li><p><code>setState</code>通过引发一次组件的更新过程来引发重新绘制</p><p>重绘指的就是引起<code>React</code>的更新生命周期函数4个函数：</p><ul><li><code>shouldComponentUpdate</code>（被调用时<code>this.state</code>没有更新；如果返回了<code>false</code>，生命周期被中断，虽然不调用之后的函数了，但是<code>state</code>仍然会被更新）</li><li><code>componentWillUpdate</code>（被调用时<code>this.state</code>没有更新）</li><li><code>render</code>（被调用时<code>this.state</code>得到更新）</li><li><code>componentDidUpdate</code></li></ul></li><li><p>多次<code>setState</code>函数调用产生的效果会合并。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'Pororo'</span>&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">age</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">'Pororo'</span>，age: <span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面两块代码的效果是一样的。<strong>如果每次调用都引发一次生命周期更新，那性能就会消耗很大了。</strong>所以，<code>React</code>会将多个<code>this.setState</code>产生的修改<strong>放进一个队列里，</strong>等差不多的时候就会引发一次生命周期更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Eg</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="number">0</span>,</span><br><span class="line">      index: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// react生命周期</span></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第一次输出</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第二次输出</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第三次输出</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第四次输出</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">     <span class="comment">// 通过 addEventListener 监听的会同步执行setState()</span></span><br><span class="line">    <span class="keyword">this</span>.refs.button.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index) <span class="comment">// 同步时输出 1 异步时（通过react事件机制定义的事件处理函数）输出 0</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index) <span class="comment">// 同步时输出 2 异步时（通过react事件机制定义的事件处理函数）输出 0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>value: &#123;this.state.value&#125; index: &#123;this.state.index&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        &lt;button ref=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><h5 id="前两次setState："><a href="#前两次setState：" class="headerlink" title="前两次setState："></a>前两次<code>setState</code>：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步</span></span><br><span class="line"> <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">// 第一次输出0</span></span><br><span class="line">         <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">// 第二次输出0</span></span><br></pre></td></tr></table></figure><p>由于<code>setState</code>不会立即改变React组件中<code>state</code>的值，所以两次<code>setState</code>中<code>this.state.value</code>都是同一个值0，故而，这两次输出都是0。因而value只被加1。</p><p>既然这样，那么是不是可以直接操作<code>this.state</code>呢？比如：<code>this.state.value=this.state.value+1;</code>这样的确可以修改<code>this.state.value</code>的状态但是却不可以引发重复渲染。所以，就必须通过React设定的<code>setState</code>函数去改变<code>this.state</code>，从而引发重新渲染。</p><h5 id="setTimeout里面的两次setState"><a href="#setTimeout里面的两次setState" class="headerlink" title="setTimeout里面的两次setState:"></a><code>setTimeout</code>里面的两次<code>setState</code>:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第三次输出2</span></span><br><span class="line">           <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value) <span class="comment">// 第四次输出3</span></span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在<code>React</code>中，<strong>如果是由React引发的事件处理（比如：<code>onClick</code>引发的事件处理），调用<code>setState</code>不会同步更新<code>this.state</code>，除此之外的<code>setState</code>调用会同步执行t<code>his.setState</code>。</strong> “除此之外”指的是：绕过React通过<code>addEventListener</code>直接添加的事件处理函数和<code>setTimeout/setInterval</code>产生的异步调用。</p><p><img src="..%5Cimage%5CsetState%5CsetState.png" alt="setState"></p><blockquote><p>每次setState产生新的state会依次被存入一个队列，然后会根据<strong>isBathingUpdates</strong>变量判断是直接更新this.state还是放进dirtyComponent里回头再说。isBatchingUpdates默认是false，也就表示setState会同步更新this.state。但是，当React在调用事件处理函数之前就会调用batchedUpdates，这个函数会把isBatchingUpdates修改为true，造成的后果就是由React控制的事件处理过程setState不会同步更新this.state。</p></blockquote></li></ol><h4 id="3-同步更新state的办法—函数式setState"><a href="#3-同步更新state的办法—函数式setState" class="headerlink" title="3.同步更新state的办法—函数式setState"></a>3.同步更新state的办法—函数式setState</h4><p>如果this.setState的参数不是一个对象而是一个函数时，这个函数会接收到两个参数，第一个是当前的state值，第二个是当前的props，这个函数应该返回一个对象，这个对象代表想要对this.state的更改，换句话说，之前你想给this.setState传递什么对象参数，在这种函数里就返回什么对象。不过，计算这个对象的方法有些改变，不再依赖于this.state，而是依赖于输入参数state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">state, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementMultiple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如当前this.state.count的值是0，第一次调用this.setState(increment)，传给increment的state参数是0，第二次调用时，state参数是1，第三次调用时参数是2，最终incrementMultiple让this.state.count变成了3。</p><p>对于多次调用函数式setState的情况，React会保证调用每次increment时，state都已经合并了之前的状态修改结果。</p><h4 id="4-把两种setState的用法混用"><a href="#4-把两种setState的用法混用" class="headerlink" title="4.把两种setState的用法混用"></a>4.把两种setState的用法混用</h4><h5 id="把incrementMultiple改成这样"><a href="#把incrementMultiple改成这样" class="headerlink" title="把incrementMultiple改成这样"></a>把incrementMultiple改成这样</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementMultiple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">this</span>.setState(increment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在几个函数式setState调用中插入一个传统式setState调用，最后得到的结果是让this.state.count增加了2，而不是增加4。</p><p>这是因为React会依次合并所有setState产生的效果，虽然前两个函数式setState调用产生的效果是count加2，但是中间出现一个传统式setState调用，一下子强行把积攒的效果清空，用count加1取代。</p><p>所以，传统式setState与函数式setState一定不要混用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React中的state&quot;&gt;&lt;a href=&quot;#React中的state&quot; class=&quot;headerlink&quot; title=&quot;React中的state&quot;&gt;&lt;/a&gt;React中的state&lt;/h3&gt;&lt;h4 id=&quot;1-不能直接修改-state&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React与Vue比较1</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%831/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94React%E4%B8%8EVue%E6%AF%94%E8%BE%831/</id>
    <published>2020-02-04T06:58:44.103Z</published>
    <updated>2020-02-04T07:05:31.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React与Vue的对比上"><a href="#React与Vue的对比上" class="headerlink" title="React与Vue的对比上"></a>React与Vue的对比上</h2><h5 id="1、监听数据变化的实现原理不同"><a href="#1、监听数据变化的实现原理不同" class="headerlink" title="1、监听数据变化的实现原理不同"></a><strong>1、监听数据变化的实现原理不同</strong></h5><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li><li>React 默认是通过比较引用地址的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染</li></ul><p>为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。所以应该说没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。</p><p>因为一般都会用一个数据层的框架比如 Vuex 和 Redux，所以这部分不作过多解释，在最后的 vuex 和 redux的区别 中也会讲到。</p><h5 id="2、数据流的不同"><a href="#2、数据流的不同" class="headerlink" title="2、数据流的不同"></a><strong>2、数据流的不同</strong></h5><p>大家都知道Vue中默认是支持双向绑定的。在Vue1.0中我们可以实现两种双向绑定：</p><ol><li>父子组件之间，props 可以双向绑定</li><li>组件与DOM之间可以通过 v-model 双向绑定</li></ol><p>在 Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且 Vue2.x 已经不鼓励组件对自己的 props 进行任何修改了。所以现在我们只有 组件 &lt;––&gt; DOM 之间的双向绑定这一种。</p><p>然而 React 从诞生之初就不支持双向绑定，React一直提倡的是单向数据流，他称之为 onChange/setState()模式。</p><p>不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。</p><h5 id="3、模板渲染方式的不同"><a href="#3、模板渲染方式的不同" class="headerlink" title="3、模板渲染方式的不同"></a><strong>3、模板渲染方式的不同</strong></h5><p>在表层上， 模板的语法不同</p><ul><li>React 是通过JSX渲染模板</li><li>而Vue是通过一种拓展的HTML语法进行渲染</li></ul><p>但其实这只是表面现象，毕竟React并不必须依赖JSX。</p><p>在深层上，模板的原理不同，这才是他们的本质区别：</p><ul><li>React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的</li><li>Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现</li></ul><h5 id="4、Vuex-和-Redux-的区别"><a href="#4、Vuex-和-Redux-的区别" class="headerlink" title="4、Vuex 和 Redux 的区别"></a><strong>4、Vuex 和 Redux 的区别</strong></h5><p>从表面上来说，store 注入和使用方式有一些区别。</p><p>在 Vuex 中，$store 被直接注入到了组件实例中，因此可以比较灵活的使用：</p><ul><li>使用 dispatch 和 commit 提交更新</li><li>通过 mapState 或者直接通过 this.$store 来读取数据</li></ul><p>在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。</p><p>另外 Vuex 更加灵活一些，组件中既可以 dispatch action 也可以 commit updates，而 Redux 中只能进行 dispatch，并不能直接调用 reducer 进行修改。</p><p>从实现原理上来说，最大的区别是两点：</p><ul><li>Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改</li><li>Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React与Vue的对比上&quot;&gt;&lt;a href=&quot;#React与Vue的对比上&quot; class=&quot;headerlink&quot; title=&quot;React与Vue的对比上&quot;&gt;&lt;/a&gt;React与Vue的对比上&lt;/h2&gt;&lt;h5 id=&quot;1、监听数据变化的实现原理不同&quot;&gt;&lt;a h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—Create-React-App</title>
    <link href="http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94Create-React-App/"/>
    <id>http://yoursite.com/2020/02/04/React%E5%AD%A6%E4%B9%A0%E2%80%94Create-React-App/</id>
    <published>2020-02-04T06:37:18.660Z</published>
    <updated>2020-02-04T06:43:01.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-create-react-app-创建及使用"><a href="#1-create-react-app-创建及使用" class="headerlink" title="1. create-react-app 创建及使用"></a>1. <code>create-react-app</code> 创建及使用</h2><blockquote><h5 id="Create-React-App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用"><a href="#Create-React-App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用" class="headerlink" title="Create React App是FaceBook的React团队官方出的一个构建React单页面应用的脚手架工具。它本身集成了Webpack，并配置了一系列内置的loader和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用"></a><code>Create React App</code>是<strong>FaceBook</strong>的React团队官方出的一个构建<code>React</code>单页面应用的脚手架工具。它本身集成了<code>Webpack</code>，并配置了一系列内置的<code>loader</code>和默认的npm的脚本，可以很轻松的实现零配置就可以快速开发React的应用</h5></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全局安装</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建一个my-app的项目(my-app 是你的项目的名称)</span></span><br><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动编译当前的React项目，并自动打开 http://localhost:3000/</span></span><br><span class="line">npm start</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">yard start</span><br></pre></td></tr></table></figure><h5 id="注意：如果你不能确保最新版本，可以尝试卸载：npm-uninstall-g-create-react-app然后全局安装"><a href="#注意：如果你不能确保最新版本，可以尝试卸载：npm-uninstall-g-create-react-app然后全局安装" class="headerlink" title="注意：如果你不能确保最新版本，可以尝试卸载：npm uninstall -g create-react-app然后全局安装"></a>注意：如果你不能确保最新版本，可以尝试卸载：<code>npm uninstall -g create-react-app</code>然后全局安装</h5><h4 id="1-1-项目目录（默认）："><a href="#1-1-项目目录（默认）：" class="headerlink" title="1.1 项目目录（默认）："></a>1.1 项目目录（默认）：</h4><p><img src="../image%5Ccreate-react-app%5Creact%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%AE%E5%BD%95.png" alt="react初始化目录"></p><h5 id="对于要创建的项目，这些文件必须以明确的文件名存在："><a href="#对于要创建的项目，这些文件必须以明确的文件名存在：" class="headerlink" title="对于要创建的项目，这些文件必须以明确的文件名存在："></a>对于要创建的项目，这些文件必须以明确的文件名存在：</h5><ul><li><code>public/index.html</code> 是页面模板;</li><li><code>src/index.js</code> 是 JavaScript 入口点。</li><li>在 <code>src</code> 中创建子目录。 为了加快重新构建的速度，<code>Webpack</code>只处理 <code>src</code> 中的文件。 你需要<strong>将任何 JS 和 CSS 文件放在 <code>src</code> 中</strong>，否则 <code>Webpack</code>将发现不了它们 </li></ul><blockquote><h5 id="在package-json中：-只有三个依赖，分别是react，react-dom-react-scripts-依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令-都是通过调用react-scripts这个依赖下面的命令进行启动的-creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来，-如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件"><a href="#在package-json中：-只有三个依赖，分别是react，react-dom-react-scripts-依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令-都是通过调用react-scripts这个依赖下面的命令进行启动的-creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来，-如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件" class="headerlink" title="在package.json中： 只有三个依赖，分别是react，react-dom,react-scripts,依赖为什么这么少，是因为像webpack，babel等等都是被creat-react-app封装到了react-scripts这个项目当中，包括基本启动命令 都是通过调用react-scripts这个依赖下面的命令进行启动的, creat-react-app搭建出来的项目默认支持这4种命令，start以开发模式启动项目，build将整个项目进行构建，test进行测试，eject会将原本creat-react-app对webpack，babel等相关配置的封装弹射出来， 如果我们要将creat-react-app配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过eject命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件"></a>在<code>package.json</code>中： 只有三个依赖，分别是<code>react，react-dom,react-scripts</code>,依赖为什么这么少，是因为像<code>webpack，babel</code>等等都是被<code>creat-react-app</code>封装到了react-scripts这个项目当中，包括基本启动命令 都是通过调用<code>react-scripts</code>这个依赖下面的命令进行启动的, <code>creat-react-app</code>搭建出来的项目默认支持这4种命令，<code>start</code>以开发模式启动项目，<code>build</code>将整个项目进行构建，<code>test</code>进行测试，<code>eject</code>会将原本<code>creat-react-app</code>对webpack，babel等相关配置的封装弹射出来， 如果我们要将<code>creat-react-app</code>配置文件进行修改，现有目录下是没有地方修改的，此时，我们就可以通过<code>eject</code>命令将原本被封装到脚手架当中的命令弹射出来，然后就可以在项目的目录下看到很多配置文件</h5></blockquote><h5 id="1-1-1-可用的Scripts"><a href="#1-1-1-可用的Scripts" class="headerlink" title="1.1.1 可用的Scripts"></a>1.1.1 可用的Scripts</h5><ul><li><p><code>npm start</code></p><p>在开发模式下运行应用程序 </p></li><li><p><code>npm test</code></p><p>以交互式监视模式启动测试运行器 </p></li><li><p><code>npm run build</code></p><p>将生产应用程序构建到 <code>build</code> 文件夹 </p></li><li><p><code>npm run eject</code></p></li></ul><h4 id="1-2在create-react-app中使用css-module两种方式"><a href="#1-2在create-react-app中使用css-module两种方式" class="headerlink" title="1.2在create-react-app中使用css module两种方式"></a>1.2在<code>create-react-app</code>中使用<code>css module</code>两种方式</h4><h5 id="1-2-1-使用-css-module-的第一种方式"><a href="#1-2-1-使用-css-module-的第一种方式" class="headerlink" title="1.2.1 使用 css module 的第一种方式"></a>1.2.1 使用 <code>css module</code> 的第一种方式</h5><blockquote><h6 id="create-react-app-中内置了使用-CSS-Modules-的配置，当前方式就是使用-create-react-app内置的用法"><a href="#create-react-app-中内置了使用-CSS-Modules-的配置，当前方式就是使用-create-react-app内置的用法" class="headerlink" title="create-react-app 中内置了使用 CSS Modules 的配置，当前方式就是使用 create-react-app内置的用法"></a><code>create-react-app</code> 中内置了使用 <code>CSS Modules</code> 的配置，当前方式就是使用 <code>create-react-app</code>内置的用法</h6></blockquote><h5 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h5><blockquote><h6 id="将所有的-css-scss等样式文件都修改成-module-css-module-scss-等。即可使用-CSS-Modules的方式进行引入使用了"><a href="#将所有的-css-scss等样式文件都修改成-module-css-module-scss-等。即可使用-CSS-Modules的方式进行引入使用了" class="headerlink" title="将所有的 .css/.scss等样式文件都修改成 .module.css/.module.scss 等。即可使用 CSS Modules的方式进行引入使用了"></a>将所有的 <code>.css/.scss</code>等样式文件都修改成 <code>.module.css/.module.scss</code> 等。即可使用 <code>CSS Modules</code>的方式进行引入使用了</h6></blockquote><h5 id="用法：编写一个css文件：union-module-css"><a href="#用法：编写一个css文件：union-module-css" class="headerlink" title="用法：编写一个css文件：union.module.css"></a>用法：编写一个css文件：<code>union.module.css</code></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在编写一个普通的-css-文件：common-css"><a href="#在编写一个普通的-css-文件：common-css" class="headerlink" title="在编写一个普通的 css 文件：common.css"></a>在编写一个普通的 css 文件：<code>common.css</code></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在App-jsx-文件中使用-CSS-Modules的方式进行引用：union-module-css"><a href="#在App-jsx-文件中使用-CSS-Modules的方式进行引用：union-module-css" class="headerlink" title="在App. jsx 文件中使用 CSS Modules的方式进行引用：union.module.css"></a>在<code>App. jsx</code> 文件中使用 <code>CSS Modules</code>的方式进行引用：<code>union.module.css</code></h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> union <span class="keyword">from</span> <span class="string">'./css/union.module.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./css/common.css'</span></span><br><span class="line"><span class="built_in">console</span>.log(union)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p className=&#123;union.error&#125;&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="在浏览器中查看效果"><a href="#在浏览器中查看效果" class="headerlink" title="在浏览器中查看效果:"></a>在浏览器中查看效果:</h4><blockquote><p>此时 App组件的背景颜色是红色，但是字体颜色却不是红色，因为使用了 <code>Css Modules</code> 之后，普通的 css 样式就不起效果了，需要用全局的方式编写才可以(:global)。 最后添加到元素上的样式结果为：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"union_error_3UaRT"</span>&gt;</span>悲催的一天开始了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用scss的效果和css效果一样-但是使用scsss时需要安装："><a href="#使用scss的效果和css效果一样-但是使用scsss时需要安装：" class="headerlink" title="使用scss的效果和css效果一样,但是使用scsss时需要安装："></a>使用<code>scss</code>的效果和<code>css</code>效果一样,但是使用<code>scsss</code>时需要安装：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i node-sass -D // 因为create-react-app中没有内置</span><br></pre></td></tr></table></figure><h5 id="然后就可以使用-scss的文件编译了"><a href="#然后就可以使用-scss的文件编译了" class="headerlink" title="然后就可以使用.scss的文件编译了"></a>然后就可以使用<code>.scss</code>的文件编译了</h5><h5 id="1-2-2-使用-css-Module的第二种方式"><a href="#1-2-2-使用-css-Module的第二种方式" class="headerlink" title="1.2.2 使用 css Module的第二种方式"></a>1.2.2 使用 <code>css Module</code>的第二种方式</h5><h5 id="方式：-1"><a href="#方式：-1" class="headerlink" title="方式："></a>方式：</h5><blockquote><h6 id="在命令行运行-npm-run-eject-命令-此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆"><a href="#在命令行运行-npm-run-eject-命令-此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆" class="headerlink" title="在命令行运行 npm run eject 命令,  此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆"></a>在命令行运行 <code>npm run eject</code> 命令,  此命令会将脚手架中隐藏的配置都展示出来，此过程不可逆</h6></blockquote><blockquote><h6 id="运行完成之后，打开-config-目录下的webpack-config-js-文件，找到-test-cssRegex-这一行"><a href="#运行完成之后，打开-config-目录下的webpack-config-js-文件，找到-test-cssRegex-这一行" class="headerlink" title="运行完成之后，打开 config 目录下的webpack.config.js 文件，找到 test: cssRegex 这一行"></a>运行完成之后，打开 config 目录下的<code>webpack.config.js</code> 文件，找到 <code>test: cssRegex</code> 这一行</h6></blockquote><blockquote><h6 id="在-use-属性执行的方法中添加-modules-true，如下图："><a href="#在-use-属性执行的方法中添加-modules-true，如下图：" class="headerlink" title="在 use 属性执行的方法中添加 modules: true，如下图："></a>在 use 属性执行的方法中添加 <code>modules: true</code>，如下图：</h6></blockquote><p><img src="../image%5Ccreate-react-app%5Ccss_modules.png" alt="css_modules"></p><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><blockquote><h6 id="和第一种方式的用法一致，只是不需要在-css-文件后面加-module-后缀了"><a href="#和第一种方式的用法一致，只是不需要在-css-文件后面加-module-后缀了" class="headerlink" title="和第一种方式的用法一致，只是不需要在 css 文件后面加 .module 后缀了"></a>和第一种方式的用法一致，只是不需要在 css 文件后面加 .module 后缀了</h6></blockquote><h5 id="在浏览器中查看效果-1"><a href="#在浏览器中查看效果-1" class="headerlink" title="在浏览器中查看效果:"></a>在浏览器中查看效果:</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class="_2elxDxwd6P93-x9qDZkogR"&gt;悲催的一天开始了&lt;/p&gt;</span><br></pre></td></tr></table></figure><hr><blockquote><h6 id="如想使用第二种方式对-sass-和-less-也使用-CSS-Modules-的方式进行引用，则类似的在-sass-和-less-解析配置上也添加modules-true-即可。"><a href="#如想使用第二种方式对-sass-和-less-也使用-CSS-Modules-的方式进行引用，则类似的在-sass-和-less-解析配置上也添加modules-true-即可。" class="headerlink" title="如想使用第二种方式对 sass 和 less 也使用 CSS Modules 的方式进行引用，则类似的在 sass 和 less 解析配置上也添加modules: true 即可。"></a><strong>如想使用第二种方式对 sass 和 less 也使用 CSS Modules 的方式进行引用，则类似的在 sass 和 less 解析配置上也添加<code>modules: true</code> 即可。</strong></h6></blockquote><hr><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><h6 id="默认-create-react-app-脚手架不能直接使用-sass-和-less-直接编写-css，需要先进行相应配置"><a href="#默认-create-react-app-脚手架不能直接使用-sass-和-less-直接编写-css，需要先进行相应配置" class="headerlink" title="默认 create-react-app 脚手架不能直接使用 sass 和 less 直接编写 css，需要先进行相应配置"></a>默认 <code>create-react-app</code> 脚手架不能直接使用 sass 和 less 直接编写 css，需要先进行相应配置</h6></blockquote><h4 id="1-3-在-Create-React-App-中启用-Sass-和-Less"><a href="#1-3-在-Create-React-App-中启用-Sass-和-Less" class="headerlink" title="1.3 在 Create-React-App 中启用 Sass 和 Less"></a>1.3 在 <code>Create-React-App</code> 中启用 Sass 和 Less</h4><h5 id="1-3-1-启用-sass-语法编写-css"><a href="#1-3-1-启用-sass-语法编写-css" class="headerlink" title="1.3.1 启用 sass 语法编写 css"></a>1.3.1 启用 sass 语法编写 css</h5><blockquote><p> <code>create-react-app</code>脚手架中已经添加了 sass-loader 的支持，所以只需要安装 <code>node-sass</code>插件即可 </p></blockquote><h5 id="安装：node-sass插件"><a href="#安装：node-sass插件" class="headerlink" title="安装：node-sass插件"></a>安装：node-sass插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install node-sass --save</span><br><span class="line"><span class="meta">#</span><span class="bash">or</span></span><br><span class="line">yarn add node-sass</span><br></pre></td></tr></table></figure><h5 id="用法：编写-sass文件：-App-scss"><a href="#用法：编写-sass文件：-App-scss" class="headerlink" title="用法：编写 sass文件： App.scss"></a>用法：编写 sass文件： App.scss</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.App</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: hotpink;</span><br><span class="line">  <span class="selector-class">.common</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在js文件中直接使用："><a href="#在js文件中直接使用：" class="headerlink" title="在js文件中直接使用："></a>在js文件中直接使用：</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./components/User'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.scss'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p className=<span class="string">"common"</span>&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;User /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">因为此时scss中没有开启模块化 所以在全局中引用该样式属性都会被使用该类的样式</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h5 id="1-3-2-启用-less-语法编写-css"><a href="#1-3-2-启用-less-语法编写-css" class="headerlink" title="1.3.2 启用 less 语法编写 css"></a>1.3.2 启用 less 语法编写 css</h5><blockquote><p> 由于 <code>create-react-app</code>脚手架中并没有配置关于 less 文件的解析，所以我们需要自己进行配置。需要安装的插件 <code>less</code>， <code>less-loader</code> </p></blockquote><h5 id="安装：less-、less-loader"><a href="#安装：less-、less-loader" class="headerlink" title="安装：less 、less-loader"></a>安装：less 、less-loader</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i less -S</span><br><span class="line">npm i less-loader -S</span><br></pre></td></tr></table></figure><h5 id="打开web-config-js文件-找到-style-files-regexes-注释位置，仿照其解析-sass-的规则，在下面添加两行代码"><a href="#打开web-config-js文件-找到-style-files-regexes-注释位置，仿照其解析-sass-的规则，在下面添加两行代码" class="headerlink" title="打开web.config.js文件  找到 // style files regexes 注释位置，仿照其解析 sass 的规则，在下面添加两行代码"></a>打开<code>web.config.js</code>文件  找到 <code>// style files regexes</code> 注释位置，仿照其解析 sass 的规则，在下面添加两行代码</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 添加 less 解析规则</span><br><span class="line">const lessRegex = /\.less$/;</span><br><span class="line">const lessModuleRegex = /\.module\.less$/;</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less.png" alt="less"></p><h5 id="找到-rules-属性配置，在其中添加-less-解析配置"><a href="#找到-rules-属性配置，在其中添加-less-解析配置" class="headerlink" title="找到 rules 属性配置，在其中添加 less 解析配置"></a>找到 rules 属性配置，在其中添加 less 解析配置</h5><blockquote><blockquote><h6 id="注意：-这里有一个需要注意的地方，下面的这些-less-配置规则放在-sass-的解析规则下面即可，如果放在了-file-loader-的解析规则下面，less-文件解析不会生效。"><a href="#注意：-这里有一个需要注意的地方，下面的这些-less-配置规则放在-sass-的解析规则下面即可，如果放在了-file-loader-的解析规则下面，less-文件解析不会生效。" class="headerlink" title="注意： 这里有一个需要注意的地方，下面的这些 less 配置规则放在 sass 的解析规则下面即可，如果放在了 file-loader 的解析规则下面，less 文件解析不会生效。"></a><strong>注意：</strong> 这里有一个需要注意的地方，下面的这些 <code>less</code> 配置规则放在 <code>sass</code> 的解析规则下面即可，如果放在了 <code>file-loader</code> 的解析规则下面，<code>less</code> 文件解析不会生效。</h6></blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less 解析配置</span></span><br><span class="line">&#123;</span><br><span class="line">    test: lessRegex,</span><br><span class="line">    exclude: lessModuleRegex,</span><br><span class="line">    use: getStyleLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'less-loader'</span></span><br><span class="line">    ),</span><br><span class="line">    sideEffects: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: lessModuleRegex,</span><br><span class="line">    use: getStyleLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">            modules: <span class="literal">true</span>,</span><br><span class="line">            getLocalIdent: getCSSModuleLocalIdent,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'less-loader'</span></span><br><span class="line">    )</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less_module.png" alt="less_module"></p><h5 id="用法-编写-less-文件：App-less"><a href="#用法-编写-less-文件：App-less" class="headerlink" title="用法: 编写 less 文件：App.less"></a>用法: 编写 less 文件：<code>App.less</code></h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.App</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00a4ff</span>;</span><br><span class="line">  <span class="selector-class">.common</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">color</span>: hotpink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在js文件中直接使用：改写App-js"><a href="#在js文件中直接使用：改写App-js" class="headerlink" title="在js文件中直接使用：改写App.js"></a>在js文件中直接使用：改写App.js</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./components/User'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.less'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p className=<span class="string">"common"</span>&gt;悲催的一天开始了&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;User /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="注意：刚刚启用的scss、less是没有启动模块化的，在web-config-js中启动模块化"><a href="#注意：刚刚启用的scss、less是没有启动模块化的，在web-config-js中启动模块化" class="headerlink" title="注意：刚刚启用的scss、less是没有启动模块化的，在web.config.js中启动模块化"></a>注意：刚刚启用的scss、less是没有启动模块化的，在<code>web.config.js</code>中启动模块化</h4><h4 id="然后在css中不要启动模块化-确保引入第三方插件时能够正常使用"><a href="#然后在css中不要启动模块化-确保引入第三方插件时能够正常使用" class="headerlink" title="然后在css中不要启动模块化,确保引入第三方插件时能够正常使用"></a>然后在css中不要启动模块化,确保引入第三方插件时能够正常使用</h4></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less 解析配置</span></span><br><span class="line">            &#123;</span><br><span class="line">              test: lessRegex,</span><br><span class="line">              exclude: lessModuleRegex,</span><br><span class="line">              use: getStyleLoaders(</span><br><span class="line">                &#123;</span><br><span class="line">                  importLoaders: <span class="number">2</span>,</span><br><span class="line">                  modules: <span class="literal">true</span>,</span><br><span class="line">                  localIdentName: <span class="string">'[name]__[local]-[hash:base64:5]'</span>,</span><br><span class="line">                  sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'less-loader'</span></span><br><span class="line">              ),</span><br><span class="line">              sideEffects: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure><p><img src="../image/create-react-app/less%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%9D%97%E5%8C%96.png" alt="less启动模块化"></p><h4 id="1-4-添加图片、字体图标、文件"><a href="#1-4-添加图片、字体图标、文件" class="headerlink" title="1.4 添加图片、字体图标、文件"></a>1.4 添加图片、字体图标、文件</h4><h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><blockquote><h6 id="在js文件中使用"><a href="#在js文件中使用" class="headerlink" title="在js文件中使用:"></a>在<code>js</code>文件中使用:</h6></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引用</span><br><span class="line">// 例如</span><br><span class="line">import logo from './logo.png'</span><br><span class="line"></span><br><span class="line">// &lt;img src=&#123;logo&#125; alt="Logo" /&gt;</span><br></pre></td></tr></table></figure><blockquote><h6 id="在css文件中使用："><a href="#在css文件中使用：" class="headerlink" title="在css文件中使用："></a>在<code>css</code>文件中使用：</h6></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 例如</span><br><span class="line"><span class="selector-class">.Logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(./logo.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><blockquote><h5 id="在index-js或者App根组件中直接引入iconfont-css"><a href="#在index-js或者App根组件中直接引入iconfont-css" class="headerlink" title="在index.js或者App根组件中直接引入iconfont.css"></a>在<code>index.js或者App根组件</code>中直接引入<code>iconfont.css</code></h5></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 例如</span><br><span class="line">import './style/iconfont.css'</span><br><span class="line"></span><br><span class="line">//引用</span><br><span class="line">&lt;p className="icon-fenxiang"&gt;子组件&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="2-配置代理"><a href="#2-配置代理" class="headerlink" title="2.配置代理"></a>2.配置代理</h2><p><strong>环境变量：</strong></p><blockquote><p>在根目录直接新建文件：<br><code>.env.production</code><br>就是生产环境的变量 </p><p> 变量规则：<br>必须是 <code>REACT_APP_</code>开头的 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REACT_APP_ROOT='/api'</span><br></pre></td></tr></table></figure><blockquote><p> 读取不变还是 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let root = process.env.REACT_APP_ROOT</span><br></pre></td></tr></table></figure><blockquote><p><strong>设置代理</strong></p><p>在src 根目录新建：<code>setupProxy.js</code><br>配置还是一样的</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(proxy(<span class="string">'/api'</span>, &#123;</span><br><span class="line">    target: <span class="string">'http://192.168.152.55:6666'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">"^/api"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>react会自动加载这个文件 *</em></p><h2 id="3-Redux使用"><a href="#3-Redux使用" class="headerlink" title="3. Redux使用"></a>3. <code>Redux</code>使用</h2><h4 id="3-1-Redux介绍"><a href="#3-1-Redux介绍" class="headerlink" title="3.1 Redux介绍"></a>3.1 <code>Redux</code>介绍</h4><p> <code>Redux</code>是一个用来管理管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂，JavaScript需要管理比任何时候都要多的<code>state</code>（状态），Redux就是降低管理难度的 </p><p><img src="../image/create-react-app/redux_flow.png" alt="redux_flow"></p><h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux -S</span><br></pre></td></tr></table></figure><h4 id="项目src下新建TodoList-jsx："><a href="#项目src下新建TodoList-jsx：" class="headerlink" title="项目src下新建TodoList.jsx："></a>项目src下新建<code>TodoList.jsx</code>：</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span>  <span class="comment">// src下的创建的store文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; changeInputAction, addItemAction, deleteItemAction, getList &#125; <span class="keyword">from</span> <span class="string">'./store/actionCreators'</span></span><br><span class="line"><span class="keyword">import</span> TodoListUI <span class="keyword">from</span> <span class="string">'./TodoListUI'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// store.getState() 会拿到store中存储的值</span></span><br><span class="line">    <span class="keyword">this</span>.state = store.getState()</span><br><span class="line">    <span class="keyword">this</span>.changeInputValue = <span class="keyword">this</span>.changeInputValue.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.storeChange = <span class="keyword">this</span>.storeChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.clickBtn = <span class="keyword">this</span>.clickBtn.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.deleteItem = <span class="keyword">this</span>.deleteItem.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 订阅Redux的状态</span></span><br><span class="line">    store.subscribe(<span class="keyword">this</span>.storeChange)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">TodoListUI</span></span></span></span><br><span class="line"><span class="xml">      inputValue=&#123;this.state.inputValue&#125;</span></span><br><span class="line"><span class="xml">      list=&#123;this.state.list&#125;</span></span><br><span class="line"><span class="xml">      changeInputValue=&#123;this.changeInputValue&#125;</span></span><br><span class="line"><span class="xml">      clickBtn=&#123;this.clickBtn&#125;</span></span><br><span class="line"><span class="xml">      deleteItem=&#123;this.deleteItem&#125;</span></span><br><span class="line"><span class="xml">    /&gt;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  componentDidMount() &#123;</span></span><br><span class="line"><span class="xml">    axios.get('http://localhost:3000/List.json')</span></span><br><span class="line"><span class="xml">    .then(res =&gt; &#123;</span></span><br><span class="line"><span class="xml">      // console.log(res.data)</span></span><br><span class="line"><span class="xml">      const action = getList(res.data.data)</span></span><br><span class="line"><span class="xml">      store.dispatch(action)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  changeInputValue(e) &#123;</span></span><br><span class="line"><span class="xml">    const action = changeInputAction(e.target.value)</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  clickBtn() &#123;</span></span><br><span class="line"><span class="xml">    const action = addItemAction()</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  deleteItem(index) &#123;</span></span><br><span class="line"><span class="xml">    const action = deleteItemAction(index)</span></span><br><span class="line"><span class="xml">    store.dispatch(action)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 订阅Redux的状态</span></span><br><span class="line"><span class="xml">  storeChange() &#123;</span></span><br><span class="line"><span class="xml">    this.setState(store.getState())</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default TodoList;</span></span><br></pre></td></tr></table></figure><h4 id="项目src下新建TodoListUI-jsx"><a href="#项目src下新建TodoListUI-jsx" class="headerlink" title="项目src下新建TodoListUI.jsx"></a>项目src下新建<code>TodoListUI.jsx</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Input, Button, List &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TodoListUI = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(props)</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Input</span><br><span class="line">        placeholder=&#123;props.inputValue&#125;</span><br><span class="line">        style=&#123;&#123; width: '250px', marginRight: '10px' &#125;&#125;</span><br><span class="line">        onChange=&#123;props.changeInputValue&#125;</span><br><span class="line">        value=&#123;props.inputValue&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        type="primary"</span><br><span class="line">        onClick=&#123;props.clickBtn&#125;&gt;增加&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div style=&#123;&#123; margin: '10px', width: '300px' &#125;&#125;&gt;</span><br><span class="line">      &lt;List</span><br><span class="line">        bordered</span><br><span class="line">        dataSource=&#123;props.list&#125;</span><br><span class="line">        renderItem=&#123;(item, index) =&gt; (&lt;List.Item onClick=&#123;() =&gt; &#123; props.deleteItem(index) &#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default TodoListUI;</span><br></pre></td></tr></table></figure><h4 id="项目src下新建store文件夹，然后创建index-js"><a href="#项目src下新建store文件夹，然后创建index-js" class="headerlink" title="项目src下新建store文件夹，然后创建index.js"></a>项目src下新建store文件夹，然后创建<code>index.js</code></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入createStore方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据存储仓库</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    reducer,</span><br><span class="line">    <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h4 id="在创建reducer-jsx-reducer配合index-js使用"><a href="#在创建reducer-jsx-reducer配合index-js使用" class="headerlink" title="在创建reducer.jsx(reducer配合index.js使用)"></a>在创建<code>reducer.jsx</code>(reducer配合<code>index.js</code>使用)</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;CHANGE_INPUT, ADD_ITEM, DELETE_ITEM, GET_LIST&#125; <span class="keyword">from</span> <span class="string">'./actionType'</span></span><br><span class="line"><span class="comment">// 默认数据</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  inputValue: <span class="string">'Write SomeThing...'</span>,</span><br><span class="line">  list: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reducer里只能接收state，不能改变state</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123; <span class="comment">// 就是一个方法函数</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * state: 指的是原始仓库里的状态</span></span><br><span class="line"><span class="comment">   * action: 指的是action新传递的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(action.type === CHANGE_INPUT) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.inputValue = action.value</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === ADD_ITEM) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.list.unshift(newState.inputValue)</span><br><span class="line">    newState.inputValue = <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === DELETE_ITEM) &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)) <span class="comment">// 深度拷贝</span></span><br><span class="line">    newState.list.splice(action.index,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === GET_LIST) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(action)</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state))</span><br><span class="line">    newState.list = action.list.list</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public文件夹下创建List-json"><a href="#public文件夹下创建List-json" class="headerlink" title="public文件夹下创建List.json"></a>public文件夹下创建<code>List.json</code></h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当作axios请求的数据</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"list"</span>: [</span><br><span class="line">      <span class="string">"早上起不来，起床困难族"</span>,</span><br><span class="line">      <span class="string">"中午没精神,没办法,我太难了"</span>,</span><br><span class="line">      <span class="string">"别说了,晚上加班搞工作、学习、学习使我快乐"</span>,</span><br><span class="line">      <span class="string">"我要加班、我要加班、我要加班、重要的事情说三遍!!!"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redux的三个小坑"><a href="#Redux的三个小坑" class="headerlink" title="Redux的三个小坑"></a><code>Redux</code>的三个小坑</h4><blockquote><h5 id="1-store-必须是唯一的，多个store是坚决不被允许的，只能有一个store空间"><a href="#1-store-必须是唯一的，多个store是坚决不被允许的，只能有一个store空间" class="headerlink" title="1. store 必须是唯一的，多个store是坚决不被允许的，只能有一个store空间"></a>1. <code>store</code> 必须是唯一的，多个<code>store</code>是坚决不被允许的，只能有一个<code>store</code>空间</h5><h5 id="2-只有store能改变自己的内容，Reducer不能改变"><a href="#2-只有store能改变自己的内容，Reducer不能改变" class="headerlink" title="2. 只有store能改变自己的内容，Reducer不能改变"></a>2. 只有<code>store</code>能改变自己的内容，<code>Reducer</code>不能改变</h5><h5 id="3-Reducer必须是纯函数"><a href="#3-Reducer必须是纯函数" class="headerlink" title="3. Reducer必须是纯函数"></a>3. <code>Reducer</code>必须是纯函数</h5></blockquote><h5 id="纯函数的定义是："><a href="#纯函数的定义是：" class="headerlink" title="纯函数的定义是："></a>纯函数的定义是：</h5><blockquote><p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-create-react-app-创建及使用&quot;&gt;&lt;a href=&quot;#1-create-react-app-创建及使用&quot; class=&quot;headerlink&quot; title=&quot;1. create-react-app 创建及使用&quot;&gt;&lt;/a&gt;1. &lt;code&gt;crea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React学习—React Router4</title>
    <link href="http://yoursite.com/2020/02/03/React%E5%AD%A6%E4%B9%A0%E2%80%94React%20Router4/"/>
    <id>http://yoursite.com/2020/02/03/React%E5%AD%A6%E4%B9%A0%E2%80%94React%20Router4/</id>
    <published>2020-02-03T15:58:29.374Z</published>
    <updated>2020-02-04T06:19:12.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-React-Router-4"><a href="#1-React-Router-4" class="headerlink" title="1. React Router 4"></a>1. React Router 4</h3><ul><li><code>react-router</code> React Router核心</li><li><code>react-router-dom</code> 用于DOM绑定的React Router</li><li><code>react-router-native</code>用于React Native 的 React Router</li><li><code>react-router-redux</code> React Router和 Redux 的集成</li><li><code>react-router-config</code>用于配置静态路由</li></ul><blockquote><p>因此，在实际的 web 项目开发中，<code>react-router</code> 和 <code>react-router-dom</code> 不必同时引用。在 <code>react-router-dom</code> 中包含<code>BrowserRouter</code> 类似  的 DOM 类组件，所以只需要引入 <code>react-router-dom</code>包就可以了</p></blockquote><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Link, Switch&#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br></pre></td></tr></table></figure><h3 id="2-页面中多个模块同时渲染问题"><a href="#2-页面中多个模块同时渲染问题" class="headerlink" title="2. 页面中多个模块同时渲染问题"></a>2. 页面中多个模块同时渲染问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>当访问 <code>path=&quot;/card&quot;</code> 的页面时，<code>path=&quot;/&quot;</code> 的页面也会被渲染出来。匹配 <code>path=&quot;/card&quot;</code> 的路由会匹配 <code>path=&quot;/&quot;</code> 的路由。那么这个问题怎么解决呢？有以下两种方法</p></blockquote><ol><li><p>使用 <code>&lt;Router&gt;</code>的<code>exact</code>关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/"</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>使用独立路由：<code>&lt;switch&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route, Switch, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/"</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/card"</span> component=&#123;Card&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Switch&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h5 id="首先需要了解下-lt-Router-gt-。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进-lt-Router-gt-组件中，比如："><a href="#首先需要了解下-lt-Router-gt-。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进-lt-Router-gt-组件中，比如：" class="headerlink" title="首先需要了解下&lt;Router&gt;。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进&lt;Router&gt;组件中，比如："></a>首先需要了解下<code>&lt;Router&gt;</code>。它是所有路由组件共用的底层接口，你可以将各种组件及标签放进<code>&lt;Router&gt;</code>组件中，比如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr/</span>&gt;</span><br><span class="line">        &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Router&gt;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：<Router>下值允许存在一个子元素，如存在多个则会报错。所以上面的代码中，需要使用<code>&lt;div&gt;</code>包裹起来</p></blockquote><h5 id="在实际的项目中，我们一般不会直接使用-lt-Router-gt-而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的-lt-BrowserRouter-gt-以及其他常用的高级路由。"><a href="#在实际的项目中，我们一般不会直接使用-lt-Router-gt-而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的-lt-BrowserRouter-gt-以及其他常用的高级路由。" class="headerlink" title="在实际的项目中，我们一般不会直接使用&lt;Router&gt;,而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的&lt;BrowserRouter&gt;以及其他常用的高级路由。"></a>在实际的项目中，我们一般不会直接使用<code>&lt;Router&gt;</code>,而是使用如下的更高级的路由。在这里将介绍到第一个问题中用到的<code>&lt;BrowserRouter&gt;</code>以及其他常用的高级路由。</h5><ol><li><p><code>&lt;BrowserRouter&gt;</code></p><p>使用 HTML5 提供的<code>history API (</code>pushState<code>,</code>replaceState<code>和</code>popstate<code>事件)</code>来保持 UI 和 url 的同步。下面介绍一下该路由组件中的 5 个属性：</p><ul><li><p><code>basename:string</code></p><p>当前位置的基准 <code>url</code> 。如果你的页面部署在服务器的二级（子）目录，你需要将 <code>basename</code> 设置到此子目录。 正确的 <code>url</code> 格式是前面有一个前导斜杠，但不能有尾部斜杠。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter basename=<span class="string">"/calendar"</span>/&gt;</span><br><span class="line">&lt;Link to=<span class="string">"/today"</span>/&gt; <span class="comment">// 渲染为 &lt;a href="/calendar/today"&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>getUserConfirmation: func</code></p><p>当导航需要确认时执行的函数。默认使用 <code>window.confirm</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的确认函数</span></span><br><span class="line"><span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> allowTransition = <span class="built_in">window</span>.confirm(message)</span><br><span class="line">  callback(allowTransition)</span><br><span class="line">&#125;</span><br><span class="line">&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>forceRefresh: bool</code></p><p>当设置为 <code>true</code> 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 <code>true</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> supportsHistory = <span class="string">'pushState'</span> <span class="keyword">in</span> <span class="built_in">window</span>.history</span><br><span class="line">&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>keyLength: number</code></p><p><code>location.key</code> 的长度，默认是 6。点击同一个链接时，每次该路由下的 <code>location.key</code> 都会改变，可以通过 <code>key</code> 的变化来刷新页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter keyLength=&#123;<span class="number">12</span>&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>children: node</code></p><p>渲染单一子组件（元素）。</p></li></ul></li><li><p><code>&lt;HashRouter&gt;</code></p><p>HashRouter 是一种特定的 <code>&lt;Router&gt;</code> ， HashRouter 使用 url 的 <code>hash</code> (例如： window.location.hash ) 来保持 UI 和 url 的同步。由于使用 hash 的方式记录导航历史不支持 <code>location.key</code> 和 <code>location.state</code> ，该技术仅用于支持传统的浏览器。</p></li></ol><h5 id="介绍完-，当然也要说下-，我们使用最频繁的组件，主要职责是当页面的访问地址与-Route-上的-path-匹配时渲染出对应的-UI-界面。"><a href="#介绍完-，当然也要说下-，我们使用最频繁的组件，主要职责是当页面的访问地址与-Route-上的-path-匹配时渲染出对应的-UI-界面。" class="headerlink" title="介绍完 ，当然也要说下 ，我们使用最频繁的组件，主要职责是当页面的访问地址与 Route 上的 path 匹配时渲染出对应的 UI 界面。"></a>介绍完 <code>，当然也要说下</code> ，我们使用最频繁的组件，主要职责是当页面的访问地址与 <code>Route</code> 上的 <code>path</code> 匹配时渲染出对应的 UI 界面。</h5><h5 id="lt-Route-gt-属性值主要有："><a href="#lt-Route-gt-属性值主要有：" class="headerlink" title="&lt;Route&gt; 属性值主要有："></a><code>&lt;Route&gt;</code> 属性值主要有：</h5><ul><li>path: string</li></ul><p>可以被 <code>path-to-regexp</code> 解析的有效 url 路径。如果没有 <code>path</code>，路由将总是被匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/users/:id"</span> component=&#123;User&#125;/&gt;</span><br></pre></td></tr></table></figure><ul><li>exact: bool</li></ul><p>为 <code>true</code> 时，则要求路径与 <code>location.pathname</code> 必须完全匹配。通过下表解释一下：</p><p><img src="https://jdc.jd.com/wp-content/uploads/2018/07/3.png" alt="img"></p><ul><li>strict: bool</li></ul><p>为 <code>true</code> 时，有结尾斜线的路径只能匹配有斜线的 <code>location.pathname</code> 。见下表：</p><p><img src="https://jdc.jd.com/wp-content/uploads/2018/07/4.png" alt="img"></p><p>第二个属性值 <code>exact</code> 就是我们用来解决多个模块同时渲染问题的，默认值为 <code>true</code> 。</p><p>在这里简要提下<code>&lt;Route&gt;</code>渲染的三种方法：</p><ul><li><code>&lt;Route component&gt;</code> 当访问地址和路由匹配时，一个 <code>React component</code> 将会被渲染</li><li><code>&lt;Route render&gt;</code> 此方法适用于内联渲染，而且不会产生重复装载问题</li><li><code>&lt;Route children&gt;</code></li></ul><p>当需要判断访问地址与路由是否匹配时，可以使用此方法。当不匹配时， <code>match</code> 为 null。</p><p>我们上面代码示例中使用的是第一种方法 <code>Route Component</code>，这三种渲染方法都会用到 <code>match</code> 、<code>location</code> 、 <code>history</code> 这些属性值。</p><p>需要注意的是 ：每一种渲染方法都有其适用背景, <code>&lt;Route component&gt;</code>的优先级比 <code>&lt;Route render&gt;</code>高，而他们又都优先于<code>&lt;Route children&gt;</code>，所以在同一个<code>&lt;Route&gt;</code>应该只使用一种方法，我们大多数使用的是 <code>component</code> 方法。</p><h5 id="说完第一种解决方法的原理，来剖析下第二种方法：-Switch-。"><a href="#说完第一种解决方法的原理，来剖析下第二种方法：-Switch-。" class="headerlink" title="说完第一种解决方法的原理，来剖析下第二种方法： Switch 。"></a>说完第一种解决方法的原理，来剖析下第二种方法： <code>Switch</code> 。</h5><p>该组件只渲染第一个与当前访问地址匹配的 <code>Route</code> 或 <code>Redirect</code> 。它和多个堆叠的<code>Route</code>组件之间的区别是： <code>Switch</code> 只渲染一个路由。</p><p>在解决方法 （2）中，当我们访问 <code>/card</code> ， <code>Switch</code> 将会开始寻找与之匹配的路由，查找到<code>&lt;Route path=&quot;/card&quot; /&gt;</code> 匹配后，<code>Switch</code> 将会停止寻找然后开始渲染 <code>/card</code> 。</p><ul><li>children: node</li></ul><p><code>&lt;Switch&gt;</code> 下的子节点只能是 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code> 元素且只有与当前访问地址匹配的第一个子节点才会被渲染。</p></li></ol><h3 id="3-如何定义默认访问页面"><a href="#3-如何定义默认访问页面" class="headerlink" title="3.如何定义默认访问页面"></a>3.如何定义默认访问页面</h3><blockquote><p>有时我们需要定义一个默认页面，重新引导用户的操作</p></blockquote><p>使用 <code>&lt;Redirect&gt;</code> 。比如当用户手动输入 <code>/test</code> 之后，我们需要跳转至首页，则代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">                &lt;Redirect to=<span class="string">"/"</span> /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><blockquote><p>方法解析：<code>&lt;Redirect&gt;</code> 渲染时将会导向一个新的地址，这个新的地址将会覆盖掉 <code>history</code> 堆栈中的当前地址。</p></blockquote><h5 id="lt-Redirect-gt-其常用的属性是："><a href="#lt-Redirect-gt-其常用的属性是：" class="headerlink" title="&lt;Redirect&gt;其常用的属性是："></a><code>&lt;Redirect&gt;</code>其常用的属性是：</h5><ul><li>to: string</li></ul><p>重定向的 url 地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">"/somewhere/else"</span> /&gt;</span><br></pre></td></tr></table></figure><ul><li>to: object</li></ul><p>重定向的 <code>location</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">'/login'</span>,</span><br><span class="line">  search: <span class="string">'?utm=your+face'</span>,</span><br><span class="line">  state: &#123; <span class="attr">referrer</span>: currentLocation &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure><ul><li>push: bool</li></ul><p>取值为 <code>true</code> 时，重定向操作将会把新地址加入到访问的历史记录里面，并不会替换掉当前的地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect push to=<span class="string">"/somewhere/else"</span>/&gt;</span><br></pre></td></tr></table></figure><ul><li>from: string</li></ul><p>需要匹配的将要被重定向的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">'/old-path'</span> to=<span class="string">'/new-path'</span>/&gt;</span><br><span class="line">  &lt;Route path=<span class="string">'/new-path'</span> component=&#123;Place&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：<code>&lt;Route&gt;</code> 元素使用 <code>path</code> 属性进行匹配，<code>Redirect</code> 元素使用 <code>from</code> 属性进行匹配。如果元素中没有对应的 <code>path</code> 或 <code>from</code>，那么它们将匹配任何当前的访问地址。</p></blockquote><h3 id="4-路由激活状态的控制"><a href="#4-路由激活状态的控制" class="headerlink" title="4. 路由激活状态的控制"></a>4. 路由激活状态的控制</h3><blockquote><p>使用<Link>组件或者<NavLink></p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeClassName=<span class="string">"selected"</span></span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><h5 id="lt-NavLink-gt-是-lt-Link-gt-的特殊版本，当遇到匹配的-URL-渲染元素时会添加样式属性，适用于页面导航部分。"><a href="#lt-NavLink-gt-是-lt-Link-gt-的特殊版本，当遇到匹配的-URL-渲染元素时会添加样式属性，适用于页面导航部分。" class="headerlink" title="&lt;NavLink&gt;是&lt;Link&gt; 的特殊版本，当遇到匹配的 URL 渲染元素时会添加样式属性，适用于页面导航部分。"></a><code>&lt;NavLink&gt;</code>是<code>&lt;Link&gt;</code> 的特殊版本，当遇到匹配的 URL 渲染元素时会添加样式属性，适用于页面导航部分。</h5><ul><li>activeClassName: string</li></ul><p>导航选中时的样式名，默认样式名为 <code>active</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeClassName=<span class="string">"selected"</span></span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>activeStyle: object</li></ul><p>导航选中时的样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/faq"</span></span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: <span class="string">'bold'</span>,</span><br><span class="line">    color: <span class="string">'red'</span></span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>exact: bool</li></ul><p>若值为 <code>true</code>，当访问地址严格匹配时激活样式才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  exact</span><br><span class="line">  to=<span class="string">"/profile"</span></span><br><span class="line">&gt;Profile&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>strict: bool</li></ul><p>若值为 <code>true</code>，只有当访问地址后缀斜杠严格匹配（有或无）时激活样式才会生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  strict</span><br><span class="line">  to=<span class="string">"/events/"</span></span><br><span class="line">&gt;Events&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><ul><li>isActive: func</li></ul><p>用于添加页面激活时的操作逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oddEvent = <span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID)</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">"/events/123"</span></span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;Event <span class="number">123</span>&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-页面跳转"><a href="#5-页面跳转" class="headerlink" title="5. 页面跳转"></a>5. 页面跳转</h3><ol><li><h5 id="使用-history-控制路由的跳转"><a href="#使用-history-控制路由的跳转" class="headerlink" title="使用 history 控制路由的跳转"></a>使用 history 控制路由的跳转</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.push(<span class="string">'/some/path'</span>);</span><br></pre></td></tr></table></figure><p><code>history</code> 指的是 <code>history</code> 包，是 4.x 中的重要依赖之一。常见的 <code>history</code> 路由方案有三种形式，分别是：</p><ul><li>browser history 在 DOM 上的实现，用于支持 HTML5 history API 的浏览器；</li><li>hash history 在 DOM 上的实现，用于旧版浏览器；</li><li>memory history 在内存上的实现，用于测试或非 DOM 环境（如 <code>React Native</code>）</li></ul><p><code>history</code> 对象包含的属性和方法如下所示：</p><ul><li><code>length</code>: number history 堆栈中的地址数目</li><li><code>action</code>: string 当前的动作 (PUSH , REPLACE , 或者是 POP )</li><li><code>location</code>: object 当前访问地址信息组成的对象</li><li><code>push(path, [state])</code>: func 在 history 堆栈信息里加入一个新路径</li><li><code>replace(path, [state])</code> : func 替换 history 堆栈信息里的当前路径</li><li><code>go(n)</code> : func 将 history 堆栈中的指针向前移动 n</li><li><code>goBack()</code>: func 等同于 go(-1)</li><li><code>goForward()</code>: func 等同于 go(1)</li><li><code>block(prompt)</code> : func 阻止跳转</li></ul><h5 id="需要注意的是：history-对象是可变的，所以不要从-history-location-直接获取，而是需要通过-lt-Route-gt-的prop-来获取-location。"><a href="#需要注意的是：history-对象是可变的，所以不要从-history-location-直接获取，而是需要通过-lt-Route-gt-的prop-来获取-location。" class="headerlink" title="需要注意的是：history 对象是可变的，所以不要从 history.location 直接获取，而是需要通过 &lt;Route&gt; 的prop 来获取 location。"></a>需要注意的是：<code>history</code> 对象是可变的，所以不要从 <code>history.location</code> 直接获取，而是需要通过 <code>&lt;Route&gt;</code> 的<code>prop</code> 来获取 <code>location</code>。</h5></li><li><h5 id="使用-Context，获得-router-对象"><a href="#使用-Context，获得-router-对象" class="headerlink" title="使用 Context，获得 router 对象"></a>使用 <code>Context</code>，获得 <code>router</code> 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">     <span class="keyword">super</span>(props, context);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  myFunction() &#123;</span><br><span class="line">    <span class="keyword">this</span>.context.router.history.push(<span class="string">"/some/Path"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-切换路由后，页面仍然停留在上一个页面的位置"><a href="#6-切换路由后，页面仍然停留在上一个页面的位置" class="headerlink" title="6.切换路由后，页面仍然停留在上一个页面的位置"></a>6.切换路由后，页面仍然停留在上一个页面的位置</h3><h5 id="问题：由-A-页面跳转到-B-页面，B-页面停留在-A-页面的位置，没有返回到顶部。"><a href="#问题：由-A-页面跳转到-B-页面，B-页面停留在-A-页面的位置，没有返回到顶部。" class="headerlink" title="问题：由 A 页面跳转到 B 页面，B 页面停留在 A 页面的位置，没有返回到顶部。"></a>问题：由 A 页面跳转到 B 页面，B 页面停留在 A 页面的位置，没有返回到顶部。</h5><p>用户可以对 window 和独立组件的滚动位置进行管理。可以使用 <code>withRouter</code> 组件： <code>withRouter</code> 可以访问历史对象的属性和最近的 <code>&lt;Route&gt;</code> 匹配项，当路由的属性值 { <code>match</code>, <code>location</code>, <code>history</code> } 改变时，<code>withRouter</code> 都会重新渲染。该组件可以携带组件的路由信息，避免组件之间一层层传递。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">withRouter(MyComponent)</span><br></pre></td></tr></table></figure><p>这样就可以获取到 MyComponent 组件的路由信息了。</p><p>解决方法：使用 <code>withRouter</code> 封装 <code>ScrollToTop</code> 组件。这里就用到了 <code>withRouter</code> 携带路由信息的特性，通过对比<code>props</code> 中 <code>location</code> 的变化，实现页面的滚动</p><ol><li><h5 id="定义-ScrollToTop-组件，代码如下："><a href="#定义-ScrollToTop-组件，代码如下：" class="headerlink" title="定义 ScrollToTop 组件，代码如下："></a>定义 <code>ScrollToTop</code> 组件，代码如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollToTop</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.props.location !== prevProps.location) &#123;</span><br><span class="line">          <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(ScrollToTop);</span><br></pre></td></tr></table></figure></li><li><h5 id="在定义路由处引用该组件，例如："><a href="#在定义路由处引用该组件，例如：" class="headerlink" title="在定义路由处引用该组件，例如："></a>在定义路由处引用该组件，例如：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;ScrollToTop&gt;</span><br><span class="line">            &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ScrollToTop&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    document.getElementById('app')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>这样处理之后，当跳转页面时都会自动回到该页面的顶部位置。</p></li></ol><h3 id="7-页面之间如何传值"><a href="#7-页面之间如何传值" class="headerlink" title="7.页面之间如何传值"></a>7.页面之间如何传值</h3><p>问题背景：当路由发生跳转时我们可能需要携带一些参数</p><p>解决方法：使用 <code>props</code> 属性，介绍以下三种传值方法：</p><ol><li><h5 id="props-params"><a href="#props-params" class="headerlink" title="props.params"></a><code>props.params</code></h5><p>指定一个 path ，然后指定通配符可以携带参数到指定的 <code>path</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/user/:name'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>跳转 UserPage 页面时，可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//link方法</span></span><br><span class="line">&lt;Link to=<span class="string">"/user/sam"</span>&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/push方法</span></span><br><span class="line"><span class="regexp">this.props.history.push("/u</span>ser/sam<span class="string">");</span></span><br></pre></td></tr></table></figure><p>在 UserPage 页面中通过 <code>this.props.params.name</code> 获取值。</p><p>上面的方法可以传递一个或多个值，但是每个值的类型都是字符串，没法传递一个对象。如果要传的话可以将 json 对象转换为字符串，传递过去之后再将 json 字符串转换为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line">data = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line"><span class="keyword">let</span> path = <span class="string">'/user/$&#123;data&#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在页面中获取值时</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.props.params.data);</span><br></pre></td></tr></table></figure></li><li><h5 id="query"><a href="#query" class="headerlink" title="query"></a><code>query</code></h5><p><code>query</code> 方式可以传递任意类型的值，但是页面的 <code>url</code> 也是由 <code>query</code> 的值拼接的，<code>url</code> 很长且是明文传输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义路由</span></span><br><span class="line">&lt;Route path=<span class="string">'/user'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据定义</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> path = &#123;</span><br><span class="line">    pathname: <span class="string">'/user'</span>,</span><br><span class="line">    query: data,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面跳转</span></span><br><span class="line">&lt;Link to=&#123;path&#125;&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">this.props.history.push(path);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/页面取值</span></span><br><span class="line"><span class="regexp">let data = this.props.location.query;</span></span><br><span class="line"><span class="regexp">let &#123;id,name,age&#125; = data;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h5><p><code>state</code> 方式类似于 <code>post</code>，依然可以传递任意类型的数据，而且可以不以明文方式传输。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义路由</span></span><br><span class="line">&lt;Route path=<span class="string">'/user'</span> component=&#123;UserPage&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据定义</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:sam,<span class="attr">age</span>:<span class="number">36</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> path = &#123;</span><br><span class="line">    pathname: <span class="string">'/user'</span>,</span><br><span class="line">    state: data,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面跳转</span></span><br><span class="line">&lt;Link to=&#123;path&#125;&gt;用户&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">this.props.history.push(path);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/页面取值</span></span><br><span class="line"><span class="regexp">let data = this.props.location.state;</span></span><br><span class="line"><span class="regexp">let &#123;id,name,age&#125; = data;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="8-使用-lt-BrowserRouter-gt-配置路由，上传页面至服务器后页面出现-404"><a href="#8-使用-lt-BrowserRouter-gt-配置路由，上传页面至服务器后页面出现-404" class="headerlink" title="8.使用 &lt;BrowserRouter&gt; 配置路由，上传页面至服务器后页面出现 404"></a>8.使用 <code>&lt;BrowserRouter&gt;</code> 配置路由，上传页面至服务器后页面出现 404</h3><h5 id="问题背景：项目中控制路由跳转使用的是-lt-BrowserRouter-gt-，代码如下："><a href="#问题背景：项目中控制路由跳转使用的是-lt-BrowserRouter-gt-，代码如下：" class="headerlink" title="问题背景：项目中控制路由跳转使用的是 &lt;BrowserRouter&gt;，代码如下："></a>问题背景：项目中控制路由跳转使用的是 <code>&lt;BrowserRouter&gt;</code>，代码如下：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;Route path=&#123;routePaths.INDEX&#125; exact component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=&#123;routePaths.CARD&#125; component=&#123;Card&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在开发过程中使用是没有问题的，但是将页面上传至服务器之后，问题就来了：用户访问的资源不存在，页面是空白的。</p><p>问题分析：`` 是使用 React-Router 应用推荐的 <code>history</code> 方案。它使用浏览器中的 History API 用于处理 url，创建一个像 <code>example.com/list/123</code> 这样真实的 url。当通过真实 url 访问网站的时候，由于路径是指向服务器的真实路径，但该路径下并没有相关资源，所以用户访问的资源不存在。</p><p>解决方法：</p><h5 id="1-使用-lt-HashRouter-gt-。"><a href="#1-使用-lt-HashRouter-gt-。" class="headerlink" title="1. 使用 &lt;HashRouter&gt;。"></a>1. 使用 <code>&lt;HashRouter&gt;</code>。</h5><p>它使用 url 中的 hash（#）部分去创建路由，举例来说，用户访问 <code>http://www.example.com/</code> ，实际会看到的是 <code>http://www.example.com/#/</code> 。<br>为什么本地开发时没有问题呢？那是因为我们的 <code>React</code> 脚手架中使用 <code>webpack-dev-server</code> 做了配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webpackConfig.devServer = &#123;</span><br><span class="line">    disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    contentBase: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">//gzip压缩</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-如果要使用-lt-BrowserRouter-gt-的话，服务器需要进行相关路由配置"><a href="#2-如果要使用-lt-BrowserRouter-gt-的话，服务器需要进行相关路由配置" class="headerlink" title="2.如果要使用 &lt;BrowserRouter&gt; 的话，服务器需要进行相关路由配置"></a>2.如果要使用 <code>&lt;BrowserRouter&gt;</code> 的话，服务器需要进行相关路由配置</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-React-Router-4&quot;&gt;&lt;a href=&quot;#1-React-Router-4&quot; class=&quot;headerlink&quot; title=&quot;1. React Router 4&quot;&gt;&lt;/a&gt;1. React Router 4&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Node中app.use中间件</title>
    <link href="http://yoursite.com/2020/01/13/Node%E4%B8%ADapp.use%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/01/13/Node%E4%B8%ADapp.use%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2020-01-13T08:00:19.963Z</published>
    <updated>2019-10-19T06:42:42.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Express中路由和中间件"><a href="#1-Express中路由和中间件" class="headerlink" title="1. Express中路由和中间件"></a>1. Express中路由和中间件</h3><h6 id="路由：就是如何处理HTTP请求中的路径部分"><a href="#路由：就是如何处理HTTP请求中的路径部分" class="headerlink" title="路由：就是如何处理HTTP请求中的路径部分"></a>路由：就是如何处理HTTP请求中的路径部分</h6><h6 id="中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数"><a href="#中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数" class="headerlink" title="中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数"></a>中间件：就是在收到请求后和发送响应之前这个阶段执行的一些函数</h6><h5 id="1-1-应用及中间件"><a href="#1-1-应用及中间件" class="headerlink" title="1.1 应用及中间件"></a>1.1 应用及中间件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next方法的作用就是将请求传递到下一个中间件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  当请求进来，会从第一个中间件开始进行匹配</span></span><br><span class="line"><span class="comment">     如果匹配，则进来</span></span><br><span class="line"><span class="comment">     如果请求进入中间件之后，没有调用 next 则代码会停在当前中间件</span></span><br><span class="line"><span class="comment">     如果调用了 next 则继续向后找到第一个匹配的中间件</span></span><br><span class="line"><span class="comment">     如果不匹配，则继续判断匹配下一个中间件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不关心请求路径的请求</span></span><br><span class="line"><span class="comment">// 不管以什么路径请求只要有next()传递</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>) <span class="comment">// 1</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)  <span class="comment">// 2</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">req,res.next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)  <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关心请求路径的请求</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/b'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 /a 开头的路径中间件</span></span><br><span class="line">app.use(<span class="string">'/a'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当在浏览器中以 /a 开头的请求时，会输出 1 a 2</span></span><br><span class="line"><span class="comment">// 当在浏览器中以 /b 开头的请求时，会输出 1 b,这里不会输出 2 因为当请求/b开头的请求后没有next()方法传递就会停留在那个请求中</span></span><br></pre></td></tr></table></figure><h5 id="1-2-错误处理中间件"><a href="#1-2-错误处理中间件" class="headerlink" title="1.2 错误处理中间件"></a>1.2 错误处理中间件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/user'</span>,(req,res,next) =&gt; &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(has error)</span><br><span class="line">       next()</span><br><span class="line">   &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">       next(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 全局错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack)</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'error message'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/a'</span>,(req,res,next) =&gt; &#123;</span><br><span class="line">  fs.readFile(path.join(__dirname,<span class="string">'./datas.txt'</span>),<span class="string">'utf8'</span>,(err,data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/a'</span>, (req,res,next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'/a'</span>)</span><br><span class="line">  res.send(<span class="string">'/a'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不匹配任何请求路径时 会进去此错误处理</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">'404 not Found'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="1-3-express中的router"><a href="#1-3-express中的router" class="headerlink" title="1.3 express中的router"></a>1.3 express中的router</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> public = <span class="built_in">require</span>(<span class="string">'./router/public'</span>)</span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'./router/user'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/public'</span>, public) <span class="comment">// 当请求以/public开头的路径时才会进来</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/user'</span>, user) <span class="comment">// 当请求以/uer开头的路径时才会进来</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,() =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// router</span></span><br><span class="line"><span class="comment">// 1.user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/a'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello node'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.public.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/b'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><ul><li><strong>app.router() 要挂载在所有第三方中间件的后面，因为前面配置的中间件是app.router()中请求处理函数的依赖</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Express中路由和中间件&quot;&gt;&lt;a href=&quot;#1-Express中路由和中间件&quot; class=&quot;headerlink&quot; title=&quot;1. Express中路由和中间件&quot;&gt;&lt;/a&gt;1. Express中路由和中间件&lt;/h3&gt;&lt;h6 id=&quot;路由：就是如何
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>express中cookie和session的使用</title>
    <link href="http://yoursite.com/2020/01/13/express%E4%B8%ADcookie%E5%92%8Csession%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/01/13/express%E4%B8%ADcookie%E5%92%8Csession%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-01-13T08:00:19.952Z</published>
    <updated>2020-01-13T11:20:34.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Cookie-和-Session"><a href="#1-Cookie-和-Session" class="headerlink" title="1.Cookie 和 Session"></a>1.Cookie 和 Session</h3><p>​       会话管理：客户端和服务端通信过程中的数据是如何管理的</p><p>​       会话管理的技术：数据存在客户端  Cookie</p><p>​                                      数据存在服务端 Session</p><p>​       <strong>Cookie</strong>: http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据</p><p>​     <strong>Session</strong>: session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源</p><h5 id="1-1-express中使用cookie-parser中间件"><a href="#1-1-express中使用cookie-parser中间件" class="headerlink" title="1.1 express中使用cookie-parser中间件"></a>1.1 express中使用cookie-parser中间件</h5><p><img src="../image/cookie/%E5%9B%BE%E7%89%871.png" alt="cookie"></p><h6 id="1-1-1-安装：npm-install-cookie-parser-S"><a href="#1-1-1-安装：npm-install-cookie-parser-S" class="headerlink" title="1.1.1 安装：npm install cookie-parser -S"></a>1.1.1 安装：npm install cookie-parser -S</h6><h6 id="1-1-2-引包：const-cookieParser-require-‘cookie-parser’"><a href="#1-1-2-引包：const-cookieParser-require-‘cookie-parser’" class="headerlink" title="1.1.2 引包：const cookieParser = require(‘cookie-parser’)"></a>1.1.2 引包：const cookieParser = require(‘cookie-parser’)</h6><h6 id="1-1-3-配置cookie-parser中间件"><a href="#1-1-3-配置cookie-parser中间件" class="headerlink" title="1.1.3 配置cookie-parser中间件"></a>1.1.3 配置cookie-parser中间件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>))</span><br></pre></td></tr></table></figure><h6 id="1-1-4在服务器通过res-cookie-方法创建一个cookie"><a href="#1-1-4在服务器通过res-cookie-方法创建一个cookie" class="headerlink" title="1.1.4在服务器通过res.cookie()方法创建一个cookie"></a>1.1.4在服务器通过res.cookie()方法创建一个cookie</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie的配置参数：</span><br><span class="line">maxAge  : 是cookie最大的有效时间 单位为毫秒</span><br><span class="line">expires ：是cookie的过期时间  是一个date对象</span><br><span class="line">httpOnly ： 当前cookie是否只能被web服务器获取</span><br><span class="line">singed:  是否对cookie进行签名(防止cookie被用户在浏览器修改)</span><br><span class="line">path：   是cookie的有效访问路径(如果没有设置，则默认为根路径)</span><br><span class="line">        比如我们设置了path:&quot;&#x2F;&quot; ，即意味着访问当前网站的任何接口都会携带cookie</span><br><span class="line">        比如我们设置了path:&quot;&#x2F;user&quot;，即意味着只有访问有&#x2F;user开头的接口才会在请求中携带cookie</span><br></pre></td></tr></table></figure><h6 id="1-1-5设置cookie的请求"><a href="#1-1-5设置cookie的请求" class="headerlink" title="1.1.5设置cookie的请求"></a>1.1.5设置cookie的请求</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/setCookie"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.cookie(<span class="string">"name"</span>,<span class="string">"cookiename"</span>,      &#123;<span class="attr">path</span>:<span class="string">"/user"</span>,<span class="attr">maxAge</span>:<span class="number">600000</span>,<span class="attr">httpOnly</span>:<span class="literal">true</span>,<span class="string">'signed'</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">    res.send(<span class="string">'setcookie'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="1-1-6-浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器-服务器此时可以通过req-cookies来查看当前的cookie"><a href="#1-1-6-浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器-服务器此时可以通过req-cookies来查看当前的cookie" class="headerlink" title="1.1.6 浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器,服务器此时可以通过req.cookies来查看当前的cookie"></a>1.1.6 浏览器再次请求服务器的时候会将之前创建的cookie放在请求头中发送给服务器,服务器此时可以通过req.cookies来查看当前的cookie</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">"/getCookie"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">//如果没有对cookie进行签名，则通过req.cookies来获取cookie</span></span><br><span class="line">    <span class="comment">//如果对cookie进行了签名，则通过req.signedCookies来获取cookie</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies,req.signedCookies)  <span class="comment">// &#123;&#125; &#123;&#125;</span></span><br><span class="line">    res.send(<span class="string">'getcookie'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/user"</span>,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies,req.signedCookies) <span class="comment">// &#123;&#125; &#123;name: 'cookiename'&#125;</span></span><br><span class="line">    res.send(<span class="string">'getcookie'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="1-1-7-Cookie记住用户名"><a href="#1-1-7-Cookie记住用户名" class="headerlink" title="1.1.7 Cookie记住用户名"></a>1.1.7 Cookie记住用户名</h6><p><img src="../image/cookie/%E5%9B%BE%E7%89%872.png" alt="cookie"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line"></span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;)</span><br><span class="line"></span><br><span class="line">const cookieParser &#x3D; require(&#39;cookie-parser&#39;)</span><br><span class="line"></span><br><span class="line">const app &#x3D; express()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: false &#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.engine(&#39;html&#39;, require(&#39;express-art-template&#39;))</span><br><span class="line">app.set(&#39;views&#39;, __dirname + &#39;&#x2F;views&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(cookieParser(&#39;xiaoxiong&#39;))</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;login&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.signedCookies.name) &#123;</span><br><span class="line">    res.render(&#39;login.html&#39;,&#123;</span><br><span class="line">      name: req.signedCookies.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.render(&#39;login.html&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;usercenter&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.signedCookies.name) &#123;</span><br><span class="line">    res.render(&#39;usercenter.html&#39;,&#123;</span><br><span class="line">      name: req.signedCookies.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.render(&#39;usercenter.html&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&#39;&#x2F;login&#39;,(req,res) &#x3D;&gt; &#123;</span><br><span class="line">  let name &#x3D; req.body.name</span><br><span class="line">  let pwd &#x3D; req.body.pwd</span><br><span class="line">  let rmbname &#x3D; req.body.rmbname</span><br><span class="line">  &#x2F;&#x2F; console.log(name+&#39;---&#39;+pwd+&#39;---&#39;+&#39;---&#39;+rmbname)</span><br><span class="line">  if(rmbname &#x3D;&#x3D; &#39;on&#39;) &#123;</span><br><span class="line">    if(name &#x3D;&#x3D; &#39;朱艳&#39; &amp;&amp; pwd &#x3D;&#x3D; &#39;zhuyan&#39;) &#123;</span><br><span class="line">      res.cookie(&#39;name&#39;,name,&#123;</span><br><span class="line">        maxAge: 60000,</span><br><span class="line">        httpOnly: true,</span><br><span class="line">        &#39;signed&#39;: true</span><br><span class="line">      &#125;)</span><br><span class="line">      res.redirect(&#39;&#x2F;usercenter&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.send(&#39;账号或者密码有误&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if(name &#x3D;&#x3D; &#39;朱艳&#39; &amp;&amp; pwd &#x3D;&#x3D; &#39;zhuyan&#39;) &#123;</span><br><span class="line">      res.redirect(&#39;&#x2F;usercenter&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.send(&#39;账号或者密码错误&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;running..&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="2-1express中express-session中间件"><a href="#2-1express中express-session中间件" class="headerlink" title="2.1express中express-session中间件"></a>2.1express中express-session中间件</h5><p><img src="../image/cookie/%E5%9B%BE%E7%89%873.png" alt="session"></p><h6 id="2-1-1-安装：npm-install-express-session-S"><a href="#2-1-1-安装：npm-install-express-session-S" class="headerlink" title="2.1.1 安装：npm install express-session -S"></a>2.1.1 安装：npm install express-session -S</h6><h6 id="2-1-2-引包：const-expressSession-require-‘express-session’"><a href="#2-1-2-引包：const-expressSession-require-‘express-session’" class="headerlink" title="2.1.2 引包：const expressSession = require(‘express-session’)"></a>2.1.2 引包：<em>const</em> expressSession = require(‘express-session’)</h6><h6 id="2-1-3-配置中间件"><a href="#2-1-3-配置中间件" class="headerlink" title="2.1.3 配置中间件"></a>2.1.3 配置中间件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(expressSession(&#123;</span><br><span class="line">  name : <span class="string">"cookieid"</span>,  <span class="comment">//指定所创建的session对应的cookie的名字</span></span><br><span class="line">  secret : <span class="string">'secret'</span>,  <span class="comment">//指定是否要签名这个cookie</span></span><br><span class="line">  <span class="comment">//resave: 强制保存 session 即使它并没有变化,。默认为 true。建议设置成 false。但是这个并不一定是必须的，如果客户端有两个并行的请求到你的服务端，</span></span><br><span class="line">  <span class="comment">// 一个请求对session的修改可能被另外一个请求覆盖掉，即使第二个请求并没有修改session</span></span><br><span class="line">  resave : <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// rolling:强制在每一个response中都发送session标识符的cookie。roling默认是false。如果把这个值设置为true但是  saveUnitialized设置为false,</span></span><br><span class="line">  <span class="comment">// 没有初始化的session的cookie不会被包含在响应中。主要作用：每次请求都重置cookie过期时间</span></span><br><span class="line">  rolling: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 强制没有“初始化”的session保存到storage(store:保存session的地方)中，</span></span><br><span class="line">  <span class="comment">// 没有初始化的session指的是刚被创建没有被修改。默认是true,但是不建议使用默认值</span></span><br><span class="line">  saveUninitialized: <span class="literal">false</span>, </span><br><span class="line">  cookie : &#123;</span><br><span class="line">      maxAge : <span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>,   <span class="comment">//指定session对应的cookie的有效时间</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h6 id="2-1-4设置session"><a href="#2-1-4设置session" class="headerlink" title="2.1.4设置session"></a>2.1.4设置session</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;setsession&#39;, (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  req.session.userinfo &#x3D; &#39;xiaoyang&#39;</span><br><span class="line">  res.send(&#39;setsession&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="2-1-5-得到session"><a href="#2-1-5-得到session" class="headerlink" title="2.1.5 得到session"></a>2.1.5 得到session</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/getsession'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.session)</span><br><span class="line">  res.send(req.session.userinfo)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="2-1-6-session登录案例"><a href="#2-1-6-session登录案例" class="headerlink" title="2.1.6 session登录案例"></a>2.1.6 session登录案例</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> expressSession = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'html'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>))</span><br><span class="line">app.set(<span class="string">'views'</span>, __dirname + <span class="string">'/views'</span>)</span><br><span class="line"></span><br><span class="line">app.use(expressSession(&#123;</span><br><span class="line">  name: <span class="string">"cookieid"</span>,  <span class="comment">//指定所创建的session对应的cookie的名字</span></span><br><span class="line">  secret: <span class="string">'secret'</span>,  <span class="comment">//指定是否要签名这个cookie</span></span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  rolling: <span class="literal">true</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">false</span>,</span><br><span class="line">  cookie: &#123;</span><br><span class="line">    maxAge: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">3</span>,   <span class="comment">//指定session对应的cookie的有效时间</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/login'</span>, (req,res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="built_in">console</span>.log(user)</span><br><span class="line">  res.render(<span class="string">'login.html'</span>,user)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取请求参数信息</span></span><br><span class="line">  <span class="keyword">let</span> name = req.body.name</span><br><span class="line">  <span class="keyword">let</span> pwd = req.body.pwd</span><br><span class="line">  <span class="comment">// 如果用户登录成功 则把用户的信息存储到session中</span></span><br><span class="line">  <span class="keyword">if</span> (name == <span class="string">'sessionName'</span> &amp;&amp; pwd == <span class="string">'123'</span>) &#123;</span><br><span class="line">    <span class="comment">// 存储会话数据</span></span><br><span class="line">    req.session.user = req.body</span><br><span class="line">    <span class="comment">// 跳转到用户中心页面</span></span><br><span class="line">    res.redirect(<span class="string">'/usercenter'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.send(<span class="string">'账号或者密码错误'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/usercenter'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从session中获取之前保存的数据</span></span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="built_in">console</span>.log(user)</span><br><span class="line">  <span class="keyword">if</span> (user &amp;&amp; user.name) &#123;</span><br><span class="line">    res.render(<span class="string">'usercenter.html'</span>, &#123;</span><br><span class="line">      name: user.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.render(<span class="string">'usercenter.html'</span>, &#123;</span><br><span class="line">      name: <span class="string">'default'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出的登录</span></span><br><span class="line">app.get(<span class="string">'/layout'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 清空session</span></span><br><span class="line">  req.session.destroy()</span><br><span class="line">  res.redirect(<span class="string">'/home'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/home'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = req.session.user</span><br><span class="line">  <span class="keyword">if</span> (user &amp;&amp; user.name) &#123;</span><br><span class="line">    res.render(<span class="string">"home.html"</span>, &#123; <span class="attr">name</span>: user.name &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    res.render(<span class="string">"home.html"</span>, &#123; <span class="attr">name</span>: <span class="string">"default"</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Cookie-和-Session&quot;&gt;&lt;a href=&quot;#1-Cookie-和-Session&quot; class=&quot;headerlink&quot; title=&quot;1.Cookie 和 Session&quot;&gt;&lt;/a&gt;1.Cookie 和 Session&lt;/h3&gt;&lt;p&gt;​     
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
